/* 
█████████████████████████████████████████████
🔥 **Cases que utilizam a API 'https://zero-two.online'** 🔥
█████████████████████████████████████████████

📅 Data de Geração: 6 de fevereiro de 2025
⏰ Hora: 03:42:15
📂 Arquivo gerado automaticamente pelo bot.
*/

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: animeimage-akiyama
└─────────────────────────────────────────────────┘
*/
case 'animeimage-akiyama':
reagir(from, "✨")
fonte = ['Instagram', 'Facebook', 'Pinterest', 'Internet']
gozeinonear = Math.floor(Math.random() * 1000)
let photos8 = await prepareWAMessageMedia({ image: {url: `${zerosite}/random/akiyama?apikey=`+API_KEY_ZEROTWO}}, { upload: zerotwo.waUploadToServer })
await zerotwo.relayMessage(from, 
{
interactiveMessage: {
header: {
title: '',
subtitle: '',
hasMediaAttachment: true,
imageMessage: photos8.imageMessage
},
footer: {
text: '',
},
contextInfo: { participant: sender, quotedMessage: info.message, forwardingScore: 999, isForwarded: true, forwardedNewsletterMessageInfo: {newsletterJid: channel, newsletterName: `𝙲𝙾𝙽𝙽𝙴𝙲𝚃𝙴𝙳 𝙲𝙾𝙽𝚃𝙴Ú𝙳𝙾𝚂`}},
body: { text: `❯❯ ZERO TWO - WALLPAPER ANIME ❮❮

❒ৣ͜͡Categoria: Wallpaper Animes
❒ৣ͜͡Fonte: ${fonte[Math.floor(Math.random() * fonte.length)]} 
❒ৣ͜͡Coleção: Zero Two Oficial 
❒ৣ͜͡Curtidas: ${gozeinonear}
${zerosite}
`,
},nativeFlowMessage: {
buttons: [{
name: "quick_reply",
buttonParamsJson: JSON.stringify({
display_text: "ꪶ͢PROXIMA͢ꫂ",
id: `${prefix}animeimage-akiyama`
}),},
],
messageParamsJson:"",
},
},
},
{}
).then((r) => console.log(r))
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: animeimage-anna
└─────────────────────────────────────────────────┘
*/
case 'animeimage-anna':
reagir(from, "✨")
fonte = ['Instagram', 'Facebook', 'Pinterest', 'Internet']
gozeinonear = Math.floor(Math.random() * 1000)
let photos24 = await prepareWAMessageMedia({ image: {url: `${zerosite}/random/anna?apikey=`+API_KEY_ZEROTWO}}, { upload: zerotwo.waUploadToServer })
await zerotwo.relayMessage(from, 
{
interactiveMessage: {
header: {
title: '',
subtitle: '',
hasMediaAttachment: true,
imageMessage: photos24.imageMessage
},
footer: {
text: '',
},
contextInfo: { participant: sender, quotedMessage: info.message, forwardingScore: 999, isForwarded: true, forwardedNewsletterMessageInfo: {newsletterJid: channel, newsletterName: `𝙲𝙾𝙽𝙽𝙴𝙲𝚃𝙴𝙳 𝙲𝙾𝙽𝚃𝙴Ú𝙳𝙾𝚂`}},
body: { text: `❯❯ ZERO TWO - WALLPAPER ANIME ❮❮

❒ৣ͜͡Categoria: Wallpaper Animes
❒ৣ͜͡Fonte: ${fonte[Math.floor(Math.random() * fonte.length)]} 
❒ৣ͜͡Coleção: Zero Two Oficial 
❒ৣ͜͡Curtidas: ${gozeinonear}
${zerosite}
`,
},nativeFlowMessage: {
buttons: [{
name: "quick_reply",
buttonParamsJson: JSON.stringify({
display_text: "ꪶ͢PROXIMA͢ꫂ",
id: `${prefix}animeimage-anna`
}),},
],
messageParamsJson:"",
},
},
},
{}
).then((r) => console.log(r))
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: animeimage-asuna
└─────────────────────────────────────────────────┘
*/
case 'animeimage-asuna':
reagir(from, "✨")
fonte = ['Instagram', 'Facebook', 'Pinterest', 'Internet']
gozeinonear = Math.floor(Math.random() * 1000)
let photos26 = await prepareWAMessageMedia({ image: {url: `${zerosite}/random/asuna?apikey=`+API_KEY_ZEROTWO}}, { upload: zerotwo.waUploadToServer })
await zerotwo.relayMessage(from, 
{
interactiveMessage: {
header: {
title: '',
subtitle: '',
hasMediaAttachment: true,
imageMessage: photos26.imageMessage
},
footer: {
text: '',
},
contextInfo: { participant: sender, quotedMessage: info.message, forwardingScore: 999, isForwarded: true, forwardedNewsletterMessageInfo: {newsletterJid: channel, newsletterName: `𝙲𝙾𝙽𝙽𝙴𝙲𝚃𝙴𝙳 𝙲𝙾𝙽𝚃𝙴Ú𝙳𝙾𝚂`}},
body: { text: `❯❯ ZERO TWO - WALLPAPER ANIME ❮❮

❒ৣ͜͡Categoria: Wallpaper Animes
❒ৣ͜͡Fonte: ${fonte[Math.floor(Math.random() * fonte.length)]} 
❒ৣ͜͡Coleção: Zero Two Oficial 
❒ৣ͜͡Curtidas: ${gozeinonear}
${zerosite}
`,
},nativeFlowMessage: {
buttons: [{
name: "quick_reply",
buttonParamsJson: JSON.stringify({
display_text: "ꪶ͢PROXIMA͢ꫂ",
id: `${prefix}animeimage-asuna`
}),},
],
messageParamsJson:"",
},
},
},
{}
).then((r) => console.log(r))
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: animeimage-ayuzawa
└─────────────────────────────────────────────────┘
*/
case 'animeimage-ayuzawa':
reagir(from, "✨")
fonte = ['Instagram', 'Facebook', 'Pinterest', 'Internet']
gozeinonear = Math.floor(Math.random() * 1000)
let photos27 = await prepareWAMessageMedia({ image: {url: `${zerosite}/random/ayuzawa?apikey=`+API_KEY_ZEROTWO}}, { upload: zerotwo.waUploadToServer })
await zerotwo.relayMessage(from, 
{
interactiveMessage: {
header: {
title: '',
subtitle: '',
hasMediaAttachment: true,
imageMessage: photos27.imageMessage
},
footer: {
text: '',
},
contextInfo: { participant: sender, quotedMessage: info.message, forwardingScore: 999, isForwarded: true, forwardedNewsletterMessageInfo: {newsletterJid: channel, newsletterName: `𝙲𝙾𝙽𝙽𝙴𝙲𝚃𝙴𝙳 𝙲𝙾𝙽𝚃𝙴Ú𝙳𝙾𝚂`}},
body: { text: `❯❯ ZERO TWO - WALLPAPER ANIME ❮❮

❒ৣ͜͡Categoria: Wallpaper Animes
❒ৣ͜͡Fonte: ${fonte[Math.floor(Math.random() * fonte.length)]} 
❒ৣ͜͡Coleção: Zero Two Oficial 
❒ৣ͜͡Curtidas: ${gozeinonear}
${zerosite}
`,
},nativeFlowMessage: {
buttons: [{
name: "quick_reply",
buttonParamsJson: JSON.stringify({
display_text: "ꪶ͢PROXIMA͢ꫂ",
id: `${prefix}animeimage-ayuzawa`
}),},
],
messageParamsJson:"",
},
},
},
{}
).then((r) => console.log(r))
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: animeimage-boruto
└─────────────────────────────────────────────────┘
*/
case 'animeimage-boruto':
reagir(from, "✨")
fonte = ['Instagram', 'Facebook', 'Pinterest', 'Internet']
gozeinonear = Math.floor(Math.random() * 1000)
let photos2 = await prepareWAMessageMedia({ image: {url: `${zerosite}/random/boruto?apikey=`+API_KEY_ZEROTWO}}, { upload: zerotwo.waUploadToServer })
await zerotwo.relayMessage(from, 
{
interactiveMessage: {
header: {
title: '',
subtitle: '',
hasMediaAttachment: true,
imageMessage: photos2.imageMessage
},
footer: {
text: '',
},
contextInfo: { participant: sender, quotedMessage: info.message, forwardingScore: 999, isForwarded: true, forwardedNewsletterMessageInfo: {newsletterJid: channel, newsletterName: `𝙲𝙾𝙽𝙽𝙴𝙲𝚃𝙴𝙳 𝙲𝙾𝙽𝚃𝙴Ú𝙳𝙾𝚂`}},
body: { text: `❯❯ ZERO TWO - WALLPAPER ANIME ❮❮

❒ৣ͜͡Categoria: Wallpaper Animes
❒ৣ͜͡Fonte: ${fonte[Math.floor(Math.random() * fonte.length)]} 
❒ৣ͜͡Coleção: Zero Two Oficial 
❒ৣ͜͡Curtidas: ${gozeinonear}
${zerosite}
`,
},nativeFlowMessage: {
buttons: [{
name: "quick_reply",
buttonParamsJson: JSON.stringify({
display_text: "ꪶ͢PROXIMA͢ꫂ",
id: `${prefix}animeimage-boruto`
}),},
],
messageParamsJson:"",
},
},
},
{}
).then((r) => console.log(r))
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: animeimage-chiho
└─────────────────────────────────────────────────┘
*/
case 'animeimage-chiho':
reagir(from, "✨")
fonte = ['Instagram', 'Facebook', 'Pinterest', 'Internet']
gozeinonear = Math.floor(Math.random() * 1000)
let photos1 = await prepareWAMessageMedia({ image: {url: `${zerosite}/random/chiho?apikey=`+API_KEY_ZEROTWO}}, { upload: zerotwo.waUploadToServer })
await zerotwo.relayMessage(from, 
{
interactiveMessage: {
header: {
title: '',
subtitle: '',
hasMediaAttachment: true,
imageMessage: photos1.imageMessage
},
footer: {
text: '',
},
contextInfo: { participant: sender, quotedMessage: info.message, forwardingScore: 999, isForwarded: true, forwardedNewsletterMessageInfo: {newsletterJid: channel, newsletterName: `𝙲𝙾𝙽𝙽𝙴𝙲𝚃𝙴𝙳 𝙲𝙾𝙽𝚃𝙴Ú𝙳𝙾𝚂`}},
body: { text: `❯❯ ZERO TWO - WALLPAPER ANIME ❮❮

❒ৣ͜͡Categoria: Wallpaper Animes
❒ৣ͜͡Fonte: ${fonte[Math.floor(Math.random() * fonte.length)]} 
❒ৣ͜͡Coleção: Zero Two Oficial 
❒ৣ͜͡Curtidas: ${gozeinonear}
${zerosite}
`,
},nativeFlowMessage: {
buttons: [{
name: "quick_reply",
buttonParamsJson: JSON.stringify({
display_text: "ꪶ͢PROXIMA͢ꫂ",
id: `${prefix}animeimage-chiho`
}),},
],
messageParamsJson:"",
},
},
},
{}
).then((r) => console.log(r))
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: animeimage-chitoge
└─────────────────────────────────────────────────┘
*/
case 'animeimage-chitoge':
reagir(from, "✨")
fonte = ['Instagram', 'Facebook', 'Pinterest', 'Internet']
gozeinonear = Math.floor(Math.random() * 1000)
let photos29 = await prepareWAMessageMedia({ image: {url: `${zerosite}/random/chitoge?apikey=`+API_KEY_ZEROTWO}}, { upload: zerotwo.waUploadToServer })
await zerotwo.relayMessage(from, 
{
interactiveMessage: {
header: {
title: '',
subtitle: '',
hasMediaAttachment: true,
imageMessage: photos29.imageMessage
},
footer: {
text: '',
},
contextInfo: { participant: sender, quotedMessage: info.message, forwardingScore: 999, isForwarded: true, forwardedNewsletterMessageInfo: {newsletterJid: channel, newsletterName: `𝙲𝙾𝙽𝙽𝙴𝙲𝚃𝙴𝙳 𝙲𝙾𝙽𝚃𝙴Ú𝙳𝙾𝚂`}},
body: { text: `❯❯ ZERO TWO - WALLPAPER ANIME ❮❮

❒ৣ͜͡Categoria: Wallpaper Animes
❒ৣ͜͡Fonte: ${fonte[Math.floor(Math.random() * fonte.length)]} 
❒ৣ͜͡Coleção: Zero Two Oficial 
❒ৣ͜͡Curtidas: ${gozeinonear}
${zerosite}
`,
},nativeFlowMessage: {
buttons: [{
name: "quick_reply",
buttonParamsJson: JSON.stringify({
display_text: "ꪶ͢PROXIMA͢ꫂ",
id: `${prefix}animeimage-chitoge`
}),},
],
messageParamsJson:"",
},
},
},
{}
).then((r) => console.log(r))
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: animeimage-cosplay
└─────────────────────────────────────────────────┘
*/
case 'animeimage-cosplay':
reagir(from, "✨")
fonte = ['Instagram', 'Facebook', 'Pinterest', 'Internet']
gozeinonear = Math.floor(Math.random() * 1000)
let images = await prepareWAMessageMedia({ image: {url: `${zerosite}/random/cosplay?apikey=`+API_KEY_ZEROTWO}}, { upload: zerotwo.waUploadToServer })
await zerotwo.relayMessage(from, 
{
interactiveMessage: {
header: {
title: '',
subtitle: '',
hasMediaAttachment: true,
imageMessage: images.imageMessage
},
footer: {
text: '',
},
contextInfo: { participant: sender, quotedMessage: info.message, forwardingScore: 999, isForwarded: true, forwardedNewsletterMessageInfo: {newsletterJid: channel, newsletterName: `𝙲𝙾𝙽𝙽𝙴𝙲𝚃𝙴𝙳 𝙲𝙾𝙽𝚃𝙴Ú𝙳𝙾𝚂`}},
body: { text: `❯❯ ZERO TWO - WALLPAPER ANIME ❮❮

❒ৣ͜͡Categoria: Wallpaper Animes
❒ৣ͜͡Fonte: ${fonte[Math.floor(Math.random() * fonte.length)]} 
❒ৣ͜͡Coleção: Zero Two Oficial 
❒ৣ͜͡Curtidas: ${gozeinonear}
${zerosite}
`,
},nativeFlowMessage: {
buttons: [{
name: "quick_reply",
buttonParamsJson: JSON.stringify({
display_text: "ꪶ͢PROXIMA͢ꫂ",
id: `${prefix}animeimage-cosplay`
}),},
],
messageParamsJson:"",
},
},
},
{}
).then((r) => console.log(r))
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: animeimage-deidara
└─────────────────────────────────────────────────┘
*/
case 'animeimage-deidara':
reagir(from, "✨")
fonte = ['Instagram', 'Facebook', 'Pinterest', 'Internet']
gozeinonear = Math.floor(Math.random() * 1000)
let photos25 = await prepareWAMessageMedia({ image: {url: `${zerosite}/random/deidara?apikey=`+API_KEY_ZEROTWO}}, { upload: zerotwo.waUploadToServer })
await zerotwo.relayMessage(from, 
{
interactiveMessage: {
header: {
title: '',
subtitle: '',
hasMediaAttachment: true,
imageMessage: photos25.imageMessage
},
footer: {
text: '',
},
contextInfo: { participant: sender, quotedMessage: info.message, forwardingScore: 999, isForwarded: true, forwardedNewsletterMessageInfo: {newsletterJid: channel, newsletterName: `𝙲𝙾𝙽𝙽𝙴𝙲𝚃𝙴𝙳 𝙲𝙾𝙽𝚃𝙴Ú𝙳𝙾𝚂`}},
body: { text: `❯❯ ZERO TWO - WALLPAPER ANIME ❮❮

❒ৣ͜͡Categoria: Wallpaper Animes
❒ৣ͜͡Fonte: ${fonte[Math.floor(Math.random() * fonte.length)]} 
❒ৣ͜͡Coleção: Zero Two Oficial 
❒ৣ͜͡Curtidas: ${gozeinonear}
${zerosite}
`,
},nativeFlowMessage: {
buttons: [{
name: "quick_reply",
buttonParamsJson: JSON.stringify({
display_text: "ꪶ͢PROXIMA͢ꫂ",
id: `${prefix}animeimage-deidara`
}),},
],
messageParamsJson:"",
},
},
},
{}
).then((r) => console.log(r))
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: animeimage-eba
└─────────────────────────────────────────────────┘
*/
case 'animeimage-eba':
reagir(from, "✨")
fonte = ['Instagram', 'Facebook', 'Pinterest', 'Internet']
gozeinonear = Math.floor(Math.random() * 1000)
let photos14 = await prepareWAMessageMedia({ image: {url: `${zerosite}/random/eba?apikey=`+API_KEY_ZEROTWO}}, { upload: zerotwo.waUploadToServer })
await zerotwo.relayMessage(from, 
{
interactiveMessage: {
header: {
title: '',
subtitle: '',
hasMediaAttachment: true,
imageMessage: photos14.imageMessage
},
footer: {
text: '',
},
contextInfo: { participant: sender, quotedMessage: info.message, forwardingScore: 999, isForwarded: true, forwardedNewsletterMessageInfo: {newsletterJid: channel, newsletterName: `𝙲𝙾𝙽𝙽𝙴𝙲𝚃𝙴𝙳 𝙲𝙾𝙽𝚃𝙴Ú𝙳𝙾𝚂`}},
body: { text: `❯❯ ZERO TWO - WALLPAPER ANIME ❮❮

❒ৣ͜͡Categoria: Wallpaper Animes
❒ৣ͜͡Fonte: ${fonte[Math.floor(Math.random() * fonte.length)]} 
❒ৣ͜͡Coleção: Zero Two Oficial 
❒ৣ͜͡Curtidas: ${gozeinonear}
${zerosite}
`,
},nativeFlowMessage: {
buttons: [{
name: "quick_reply",
buttonParamsJson: JSON.stringify({
display_text: "ꪶ͢PROXIMA͢ꫂ",
id: `${prefix}animeimage-eba`
}),},
],
messageParamsJson:"",
},
},
},
{}
).then((r) => console.log(r))
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: animeimage-elaina
└─────────────────────────────────────────────────┘
*/
case 'animeimage-elaina':
reagir(from, "✨")
fonte = ['Instagram', 'Facebook', 'Pinterest', 'Internet']
gozeinonear = Math.floor(Math.random() * 1000)
let photos17 = await prepareWAMessageMedia({ image: {url: `${zerosite}/random/elaina?apikey=`+API_KEY_ZEROTWO}}, { upload: zerotwo.waUploadToServer })
await zerotwo.relayMessage(from, 
{
interactiveMessage: {
header: {
title: '',
subtitle: '',
hasMediaAttachment: true,
imageMessage: photos17.imageMessage
},
footer: {
text: '',
},
contextInfo: { participant: sender, quotedMessage: info.message, forwardingScore: 999, isForwarded: true, forwardedNewsletterMessageInfo: {newsletterJid: channel, newsletterName: `𝙲𝙾𝙽𝙽𝙴𝙲𝚃𝙴𝙳 𝙲𝙾𝙽𝚃𝙴Ú𝙳𝙾𝚂`}},
body: { text: `❯❯ ZERO TWO - WALLPAPER ANIME ❮❮

❒ৣ͜͡Categoria: Wallpaper Animes
❒ৣ͜͡Fonte: ${fonte[Math.floor(Math.random() * fonte.length)]} 
❒ৣ͜͡Coleção: Zero Two Oficial 
❒ৣ͜͡Curtidas: ${gozeinonear}
${zerosite}
`,
},nativeFlowMessage: {
buttons: [{
name: "quick_reply",
buttonParamsJson: JSON.stringify({
display_text: "ꪶ͢PROXIMA͢ꫂ",
id: `${prefix}animeimage-elaina`
}),},
],
messageParamsJson:"",
},
},
},
{}
).then((r) => console.log(r))
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: animeimage-emilia
└─────────────────────────────────────────────────┘
*/
case 'animeimage-emilia':
reagir(from, "✨")
fonte = ['Instagram', 'Facebook', 'Pinterest', 'Internet']
gozeinonear = Math.floor(Math.random() * 1000)
let photos28 = await prepareWAMessageMedia({ image: {url: `${zerosite}/random/emilia?apikey=`+API_KEY_ZEROTWO}}, { upload: zerotwo.waUploadToServer })
await zerotwo.relayMessage(from, 
{
interactiveMessage: {
header: {
title: '',
subtitle: '',
hasMediaAttachment: true,
imageMessage: photos28.imageMessage
},
footer: {
text: '',
},
contextInfo: { participant: sender, quotedMessage: info.message, forwardingScore: 999, isForwarded: true, forwardedNewsletterMessageInfo: {newsletterJid: channel, newsletterName: `𝙲𝙾𝙽𝙽𝙴𝙲𝚃𝙴𝙳 𝙲𝙾𝙽𝚃𝙴Ú𝙳𝙾𝚂`}},
body: { text: `❯❯ ZERO TWO - WALLPAPER ANIME ❮❮

❒ৣ͜͡Categoria: Wallpaper Animes
❒ৣ͜͡Fonte: ${fonte[Math.floor(Math.random() * fonte.length)]} 
❒ৣ͜͡Coleção: Zero Two Oficial 
❒ৣ͜͡Curtidas: ${gozeinonear}
${zerosite}
`,
},nativeFlowMessage: {
buttons: [{
name: "quick_reply",
buttonParamsJson: JSON.stringify({
display_text: "ꪶ͢PROXIMA͢ꫂ",
id: `${prefix}animeimage-emilia`
}),},
],
messageParamsJson:"",
},
},
},
{}
).then((r) => console.log(r))
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: animeimage-erza
└─────────────────────────────────────────────────┘
*/
case 'animeimage-erza':
reagir(from, "✨")
fonte = ['Instagram', 'Facebook', 'Pinterest', 'Internet']
gozeinonear = Math.floor(Math.random() * 1000)
let photos16 = await prepareWAMessageMedia({ image: {url: `${zerosite}/random/erza?apikey=`+API_KEY_ZEROTWO}}, { upload: zerotwo.waUploadToServer })
await zerotwo.relayMessage(from, 
{
interactiveMessage: {
header: {
title: '',
subtitle: '',
hasMediaAttachment: true,
imageMessage: photos16.imageMessage
},
footer: {
text: '',
},
contextInfo: { participant: sender, quotedMessage: info.message, forwardingScore: 999, isForwarded: true, forwardedNewsletterMessageInfo: {newsletterJid: channel, newsletterName: `𝙲𝙾𝙽𝙽𝙴𝙲𝚃𝙴𝙳 𝙲𝙾𝙽𝚃𝙴Ú𝙳𝙾𝚂`}},
body: { text: `❯❯ ZERO TWO - WALLPAPER ANIME ❮❮

❒ৣ͜͡Categoria: Wallpaper Animes
❒ৣ͜͡Fonte: ${fonte[Math.floor(Math.random() * fonte.length)]} 
❒ৣ͜͡Coleção: Zero Two Oficial 
❒ৣ͜͡Curtidas: ${gozeinonear}
${zerosite}
`,
},nativeFlowMessage: {
buttons: [{
name: "quick_reply",
buttonParamsJson: JSON.stringify({
display_text: "ꪶ͢PROXIMA͢ꫂ",
id: `${prefix}animeimage-erza`
}),},
],
messageParamsJson:"",
},
},
},
{}
).then((r) => console.log(r))
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: animeimage-gremory
└─────────────────────────────────────────────────┘
*/
case 'animeimage-gremory':
reagir(from, "✨")
fonte = ['Instagram', 'Facebook', 'Pinterest', 'Internet']
gozeinonear = Math.floor(Math.random() * 1000)
let photos9 = await prepareWAMessageMedia({ image: {url: `${zerosite}/random/gremory?apikey=`+API_KEY_ZEROTWO}}, { upload: zerotwo.waUploadToServer })
await zerotwo.relayMessage(from, 
{
interactiveMessage: {
header: {
title: '',
subtitle: '',
hasMediaAttachment: true,
imageMessage: photos9.imageMessage
},
footer: {
text: '',
},
contextInfo: { participant: sender, quotedMessage: info.message, forwardingScore: 999, isForwarded: true, forwardedNewsletterMessageInfo: {newsletterJid: channel, newsletterName: `𝙲𝙾𝙽𝙽𝙴𝙲𝚃𝙴𝙳 𝙲𝙾𝙽𝚃𝙴Ú𝙳𝙾𝚂`}},
body: { text: `❯❯ ZERO TWO - WALLPAPER ANIME ❮❮

❒ৣ͜͡Categoria: Wallpaper Animes
❒ৣ͜͡Fonte: ${fonte[Math.floor(Math.random() * fonte.length)]} 
❒ৣ͜͡Coleção: Zero Two Oficial 
❒ৣ͜͡Curtidas: ${gozeinonear}
${zerosite}
`,
},nativeFlowMessage: {
buttons: [{
name: "quick_reply",
buttonParamsJson: JSON.stringify({
display_text: "ꪶ͢PROXIMA͢ꫂ",
id: `${prefix}animeimage-gremory`
}),},
],
messageParamsJson:"",
},
},
},
{}
).then((r) => console.log(r))
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: animeimage-hestia
└─────────────────────────────────────────────────┘
*/
case 'animeimage-hestia':
reagir(from, "✨")
fonte = ['Instagram', 'Facebook', 'Pinterest', 'Internet']
gozeinonear = Math.floor(Math.random() * 1000)
let photos30 = await prepareWAMessageMedia({ image: {url: `${zerosite}/random/hestia?apikey=`+API_KEY_ZEROTWO}}, { upload: zerotwo.waUploadToServer })
await zerotwo.relayMessage(from, 
{
interactiveMessage: {
header: {
title: '',
subtitle: '',
hasMediaAttachment: true,
imageMessage: photos30.imageMessage
},
footer: {
text: '',
},
contextInfo: { participant: sender, quotedMessage: info.message, forwardingScore: 999, isForwarded: true, forwardedNewsletterMessageInfo: {newsletterJid: channel, newsletterName: `𝙲𝙾𝙽𝙽𝙴𝙲𝚃𝙴𝙳 𝙲𝙾𝙽𝚃𝙴Ú𝙳𝙾𝚂`}},
body: { text: `❯❯ ZERO TWO - WALLPAPER ANIME ❮❮

❒ৣ͜͡Categoria: Wallpaper Animes
❒ৣ͜͡Fonte: ${fonte[Math.floor(Math.random() * fonte.length)]} 
❒ৣ͜͡Coleção: Zero Two Oficial 
❒ৣ͜͡Curtidas: ${gozeinonear}
${zerosite}
`,
},nativeFlowMessage: {
buttons: [{
name: "quick_reply",
buttonParamsJson: JSON.stringify({
display_text: "ꪶ͢PROXIMA͢ꫂ",
id: `${prefix}animeimage-hestia`
}),},
],
messageParamsJson:"",
},
},
},
{}
).then((r) => console.log(r))
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: animeimage-hinata
└─────────────────────────────────────────────────┘
*/
case 'animeimage-hinata':
reagir(from, "✨")
fonte = ['Instagram', 'Facebook', 'Pinterest', 'Internet']
gozeinonear = Math.floor(Math.random() * 1000)
let photos18 = await prepareWAMessageMedia({ image: {url: `${zerosite}/random/hinata?apikey=`+API_KEY_ZEROTWO}}, { upload: zerotwo.waUploadToServer })
await zerotwo.relayMessage(from, 
{
interactiveMessage: {
header: {
title: '',
subtitle: '',
hasMediaAttachment: true,
imageMessage: photos18.imageMessage
},
footer: {
text: '',
},
contextInfo: { participant: sender, quotedMessage: info.message, forwardingScore: 999, isForwarded: true, forwardedNewsletterMessageInfo: {newsletterJid: channel, newsletterName: `𝙲𝙾𝙽𝙽𝙴𝙲𝚃𝙴𝙳 𝙲𝙾𝙽𝚃𝙴Ú𝙳𝙾𝚂`}},
body: { text: `❯❯ ZERO TWO - WALLPAPER ANIME ❮❮

❒ৣ͜͡Categoria: Wallpaper Animes
❒ৣ͜͡Fonte: ${fonte[Math.floor(Math.random() * fonte.length)]} 
❒ৣ͜͡Coleção: Zero Two Oficial 
❒ৣ͜͡Curtidas: ${gozeinonear}
${zerosite}
`,
},nativeFlowMessage: {
buttons: [{
name: "quick_reply",
buttonParamsJson: JSON.stringify({
display_text: "ꪶ͢PROXIMA͢ꫂ",
id: `${prefix}animeimage-hinata`
}),},
],
messageParamsJson:"",
},
},
},
{}
).then((r) => console.log(r))
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: animeimage-inori
└─────────────────────────────────────────────────┘
*/
case 'animeimage-inori':
reagir(from, "✨")
fonte = ['Instagram', 'Facebook', 'Pinterest', 'Internet']
gozeinonear = Math.floor(Math.random() * 1000)
let photos31 = await prepareWAMessageMedia({ image: {url: `${zerosite}/random/inori?apikey=`+API_KEY_ZEROTWO}}, { upload: zerotwo.waUploadToServer })
await zerotwo.relayMessage(from, 
{
interactiveMessage: {
header: {
title: '',
subtitle: '',
hasMediaAttachment: true,
imageMessage: photos31.imageMessage
},
footer: {
text: '',
},
contextInfo: { participant: sender, quotedMessage: info.message, forwardingScore: 999, isForwarded: true, forwardedNewsletterMessageInfo: {newsletterJid: channel, newsletterName: `𝙲𝙾𝙽𝙽𝙴𝙲𝚃𝙴𝙳 𝙲𝙾𝙽𝚃𝙴Ú𝙳𝙾𝚂`}},
body: { text: `❯❯ ZERO TWO - WALLPAPER ANIME ❮❮

❒ৣ͜͡Categoria: Wallpaper Animes
❒ৣ͜͡Fonte: ${fonte[Math.floor(Math.random() * fonte.length)]} 
❒ৣ͜͡Coleção: Zero Two Oficial 
❒ৣ͜͡Curtidas: ${gozeinonear}
${zerosite}
`,
},nativeFlowMessage: {
buttons: [{
name: "quick_reply",
buttonParamsJson: JSON.stringify({
display_text: "ꪶ͢PROXIMA͢ꫂ",
id: `${prefix}animeimage-inori`
}),},
],
messageParamsJson:"",
},
},
},
{}
).then((r) => console.log(r))
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: animeimage-itachi
└─────────────────────────────────────────────────┘
*/
case 'animeimage-itachi':
reagir(from, "✨")
fonte = ['Instagram', 'Facebook', 'Pinterest', 'Internet']
gozeinonear = Math.floor(Math.random() * 1000)
let photos32 = await prepareWAMessageMedia({ image: {url: `${zerosite}/random/itachi?apikey=`+API_KEY_ZEROTWO}}, { upload: zerotwo.waUploadToServer })
await zerotwo.relayMessage(from, 
{
interactiveMessage: {
header: {
title: '',
subtitle: '',
hasMediaAttachment: true,
imageMessage: photos32.imageMessage
},
footer: {
text: '',
},
contextInfo: { participant: sender, quotedMessage: info.message, forwardingScore: 999, isForwarded: true, forwardedNewsletterMessageInfo: {newsletterJid: channel, newsletterName: `𝙲𝙾𝙽𝙽𝙴𝙲𝚃𝙴𝙳 𝙲𝙾𝙽𝚃𝙴Ú𝙳𝙾𝚂`}},
body: { text: `❯❯ ZERO TWO - WALLPAPER ANIME ❮❮

❒ৣ͜͡Categoria: Wallpaper Animes
❒ৣ͜͡Fonte: ${fonte[Math.floor(Math.random() * fonte.length)]} 
❒ৣ͜͡Coleção: Zero Two Oficial 
❒ৣ͜͡Curtidas: ${gozeinonear}
${zerosite}
`,
},nativeFlowMessage: {
buttons: [{
name: "quick_reply",
buttonParamsJson: JSON.stringify({
display_text: "ꪶ͢PROXIMA͢ꫂ",
id: `${prefix}animeimage-itachi`
}),},
],
messageParamsJson:"",
},
},
},
{}
).then((r) => console.log(r))
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: animeimage-izuku
└─────────────────────────────────────────────────┘
*/
case 'animeimage-izuku':
reagir(from, "✨")
fonte = ['Instagram', 'Facebook', 'Pinterest', 'Internet']
gozeinonear = Math.floor(Math.random() * 1000)
let photos10 = await prepareWAMessageMedia({ image: {url: `${zerosite}/random/izuku?apikey=`+API_KEY_ZEROTWO}}, { upload: zerotwo.waUploadToServer })
await zerotwo.relayMessage(from, 
{
interactiveMessage: {
header: {
title: '',
subtitle: '',
hasMediaAttachment: true,
imageMessage: photos10.imageMessage
},
footer: {
text: '',
},
contextInfo: { participant: sender, quotedMessage: info.message, forwardingScore: 999, isForwarded: true, forwardedNewsletterMessageInfo: {newsletterJid: channel, newsletterName: `𝙲𝙾𝙽𝙽𝙴𝙲𝚃𝙴𝙳 𝙲𝙾𝙽𝚃𝙴Ú𝙳𝙾𝚂`}},
body: { text: `❯❯ ZERO TWO - WALLPAPER ANIME ❮❮

❒ৣ͜͡Categoria: Wallpaper Animes
❒ৣ͜͡Fonte: ${fonte[Math.floor(Math.random() * fonte.length)]} 
❒ৣ͜͡Coleção: Zero Two Oficial 
❒ৣ͜͡Curtidas: ${gozeinonear}
${zerosite}
`,
},nativeFlowMessage: {
buttons: [{
name: "quick_reply",
buttonParamsJson: JSON.stringify({
display_text: "ꪶ͢PROXIMA͢ꫂ",
id: `${prefix}animeimage-izuku`
}),},
],
messageParamsJson:"",
},
},
},
{}
).then((r) => console.log(r))
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: animeimage-kaga
└─────────────────────────────────────────────────┘
*/
case 'animeimage-kaga':
reagir(from, "✨")
fonte = ['Instagram', 'Facebook', 'Pinterest', 'Internet']
gozeinonear = Math.floor(Math.random() * 1000)
let photos5 = await prepareWAMessageMedia({ image: {url: `${zerosite}/random/kaga?apikey=`+API_KEY_ZEROTWO}}, { upload: zerotwo.waUploadToServer })
await zerotwo.relayMessage(from, 
{
interactiveMessage: {
header: {
title: '',
subtitle: '',
hasMediaAttachment: true,
imageMessage: photos5.imageMessage
},
footer: {
text: '',
},
contextInfo: { participant: sender, quotedMessage: info.message, forwardingScore: 999, isForwarded: true, forwardedNewsletterMessageInfo: {newsletterJid: channel, newsletterName: `𝙲𝙾𝙽𝙽𝙴𝙲𝚃𝙴𝙳 𝙲𝙾𝙽𝚃𝙴Ú𝙳𝙾𝚂`}},
body: { text: `❯❯ ZERO TWO - WALLPAPER ANIME ❮❮

❒ৣ͜͡Categoria: Wallpaper Animes
❒ৣ͜͡Fonte: ${fonte[Math.floor(Math.random() * fonte.length)]} 
❒ৣ͜͡Coleção: Zero Two Oficial 
❒ৣ͜͡Curtidas: ${gozeinonear}
${zerosite}
`,
},nativeFlowMessage: {
buttons: [{
name: "quick_reply",
buttonParamsJson: JSON.stringify({
display_text: "ꪶ͢PROXIMA͢ꫂ",
id: `${prefix}animeimage-kaga`
}),},
],
messageParamsJson:"",
},
},
},
{}
).then((r) => console.log(r))
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: animeimage-kagura
└─────────────────────────────────────────────────┘
*/
case 'animeimage-kagura':
reagir(from, "✨")
fonte = ['Instagram', 'Facebook', 'Pinterest', 'Internet']
gozeinonear = Math.floor(Math.random() * 1000)
let photos12 = await prepareWAMessageMedia({ image: {url: `${zerosite}/random/kagura?apikey=`+API_KEY_ZEROTWO}}, { upload: zerotwo.waUploadToServer })
await zerotwo.relayMessage(from, 
{
interactiveMessage: {
header: {
title: '',
subtitle: '',
hasMediaAttachment: true,
imageMessage: photos12.imageMessage
},
footer: {
text: '',
},
contextInfo: { participant: sender, quotedMessage: info.message, forwardingScore: 999, isForwarded: true, forwardedNewsletterMessageInfo: {newsletterJid: channel, newsletterName: `𝙲𝙾𝙽𝙽𝙴𝙲𝚃𝙴𝙳 𝙲𝙾𝙽𝚃𝙴Ú𝙳𝙾𝚂`}},
body: { text: `❯❯ ZERO TWO - WALLPAPER ANIME ❮❮

❒ৣ͜͡Categoria: Wallpaper Animes
❒ৣ͜͡Fonte: ${fonte[Math.floor(Math.random() * fonte.length)]} 
❒ৣ͜͡Coleção: Zero Two Oficial 
❒ৣ͜͡Curtidas: ${gozeinonear}
${zerosite}
`,
},nativeFlowMessage: {
buttons: [{
name: "quick_reply",
buttonParamsJson: JSON.stringify({
display_text: "ꪶ͢PROXIMA͢ꫂ",
id: `${prefix}animeimage-kagura`
}),},
],
messageParamsJson:"",
},
},
},
{}
).then((r) => console.log(r))
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: animeimage-kaori
└─────────────────────────────────────────────────┘
*/
case 'animeimage-kaori':
reagir(from, "✨")
fonte = ['Instagram', 'Facebook', 'Pinterest', 'Internet']
gozeinonear = Math.floor(Math.random() * 1000)
let photos3 = await prepareWAMessageMedia({ image: {url: `${zerosite}/random/kaori?apikey=`+API_KEY_ZEROTWO}}, { upload: zerotwo.waUploadToServer })
await zerotwo.relayMessage(from, 
{
interactiveMessage: {
header: {
title: '',
subtitle: '',
hasMediaAttachment: true,
imageMessage: photos3.imageMessage
},
footer: {
text: '',
},
contextInfo: { participant: sender, quotedMessage: info.message, forwardingScore: 999, isForwarded: true, forwardedNewsletterMessageInfo: {newsletterJid: channel, newsletterName: `𝙲𝙾𝙽𝙽𝙴𝙲𝚃𝙴𝙳 𝙲𝙾𝙽𝚃𝙴Ú𝙳𝙾𝚂`}},
body: { text: `❯❯ ZERO TWO - WALLPAPER ANIME ❮❮

❒ৣ͜͡Categoria: Wallpaper Animes
❒ৣ͜͡Fonte: ${fonte[Math.floor(Math.random() * fonte.length)]} 
❒ৣ͜͡Coleção: Zero Two Oficial 
❒ৣ͜͡Curtidas: ${gozeinonear}
${zerosite}
`,
},nativeFlowMessage: {
buttons: [{
name: "quick_reply",
buttonParamsJson: JSON.stringify({
display_text: "ꪶ͢PROXIMA͢ꫂ",
id: `${prefix}animeimage-kaori`
}),},
],
messageParamsJson:"",
},
},
},
{}
).then((r) => console.log(r))
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: animeimage-keneki
└─────────────────────────────────────────────────┘
*/
case 'animeimage-keneki':
reagir(from, "✨")
fonte = ['Instagram', 'Facebook', 'Pinterest', 'Internet']
gozeinonear = Math.floor(Math.random() * 1000)
let photos40 = await prepareWAMessageMedia({ image: {url: `${zerosite}/random/keneki?apikey=`+API_KEY_ZEROTWO}}, { upload: zerotwo.waUploadToServer })
await zerotwo.relayMessage(from, 
{
interactiveMessage: {
header: {
title: '',
subtitle: '',
hasMediaAttachment: true,
imageMessage: photos40.imageMessage
},
footer: {
text: '',
},
contextInfo: { participant: sender, quotedMessage: info.message, forwardingScore: 999, isForwarded: true, forwardedNewsletterMessageInfo: {newsletterJid: channel, newsletterName: `𝙲𝙾𝙽𝙽𝙴𝙲𝚃𝙴𝙳 𝙲𝙾𝙽𝚃𝙴Ú𝙳𝙾𝚂`}},
body: { text: `❯❯ ZERO TWO - WALLPAPER ANIME ❮❮

❒ৣ͜͡Categoria: Wallpaper Animes
❒ৣ͜͡Fonte: ${fonte[Math.floor(Math.random() * fonte.length)]} 
❒ৣ͜͡Coleção: Zero Two Oficial 
❒ৣ͜͡Curtidas: ${gozeinonear}
${zerosite}
`,
},nativeFlowMessage: {
buttons: [{
name: "quick_reply",
buttonParamsJson: JSON.stringify({
display_text: "ꪶ͢PROXIMA͢ꫂ",
id: `${prefix}animeimage-keneki`
}),},
],
messageParamsJson:"",
},
},
},
{}
).then((r) => console.log(r))
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: animeimage-kotori
└─────────────────────────────────────────────────┘
*/
case 'animeimage-kotori':
reagir(from, "✨")
fonte = ['Instagram', 'Facebook', 'Pinterest', 'Internet']
gozeinonear = Math.floor(Math.random() * 1000)
let photos6 = await prepareWAMessageMedia({ image: {url: `${zerosite}/random/kotori?apikey=`+API_KEY_ZEROTWO}}, { upload: zerotwo.waUploadToServer })
await zerotwo.relayMessage(from, 
{
interactiveMessage: {
header: {
title: '',
subtitle: '',
hasMediaAttachment: true,
imageMessage: photos6.imageMessage
},
footer: {
text: '',
},
contextInfo: { participant: sender, quotedMessage: info.message, forwardingScore: 999, isForwarded: true, forwardedNewsletterMessageInfo: {newsletterJid: channel, newsletterName: `𝙲𝙾𝙽𝙽𝙴𝙲𝚃𝙴𝙳 𝙲𝙾𝙽𝚃𝙴Ú𝙳𝙾𝚂`}},
body: { text: `❯❯ ZERO TWO - WALLPAPER ANIME ❮❮

❒ৣ͜͡Categoria: Wallpaper Animes
❒ৣ͜͡Fonte: ${fonte[Math.floor(Math.random() * fonte.length)]} 
❒ৣ͜͡Coleção: Zero Two Oficial 
❒ৣ͜͡Curtidas: ${gozeinonear}
${zerosite}
`,
},nativeFlowMessage: {
buttons: [{
name: "quick_reply",
buttonParamsJson: JSON.stringify({
display_text: "ꪶ͢PROXIMA͢ꫂ",
id: `${prefix}animeimage-kotori`
}),},
],
messageParamsJson:"",
},
},
},
{}
).then((r) => console.log(r))
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: animeimage-loli
└─────────────────────────────────────────────────┘
*/
case 'animeimage-loli':
reagir(from, "✨")
fonte = ['Instagram', 'Facebook', 'Pinterest', 'Internet']
gozeinonear = Math.floor(Math.random() * 1000)
let imagesss = await prepareWAMessageMedia({ image: {url: `${zerosite}/random/loli?apikey=`+API_KEY_ZEROTWO}}, { upload: zerotwo.waUploadToServer })
await zerotwo.relayMessage(from, 
{
interactiveMessage: {
header: {
title: '',
subtitle: '',
hasMediaAttachment: true,
imageMessage: imagesss.imageMessage
},
footer: {
text: '',
},
contextInfo: { participant: sender, quotedMessage: info.message, forwardingScore: 999, isForwarded: true, forwardedNewsletterMessageInfo: {newsletterJid: channel, newsletterName: `𝙲𝙾𝙽𝙽𝙴𝙲𝚃𝙴𝙳 𝙲𝙾𝙽𝚃𝙴Ú𝙳𝙾𝚂`}},
body: { text: `❯❯ ZERO TWO - WALLPAPER ANIME ❮❮

❒ৣ͜͡Categoria: Wallpaper Animes
❒ৣ͜͡Fonte: ${fonte[Math.floor(Math.random() * fonte.length)]} 
❒ৣ͜͡Coleção: Zero Two Oficial 
❒ৣ͜͡Curtidas: ${gozeinonear}
${zerosite}
`,
},nativeFlowMessage: {
buttons: [{
name: "quick_reply",
buttonParamsJson: JSON.stringify({
display_text: "ꪶ͢PROXIMA͢ꫂ",
id: `${prefix}animeimage-loli`
}),},
],
messageParamsJson:"",
},
},
},
{}
).then((r) => console.log(r))
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: animeimage-madara
└─────────────────────────────────────────────────┘
*/
case 'animeimage-madara':
reagir(from, "✨")
fonte = ['Instagram', 'Facebook', 'Pinterest', 'Internet']
gozeinonear = Math.floor(Math.random() * 1000)
let photos33 = await prepareWAMessageMedia({ image: {url: `${zerosite}/random/madara?apikey=`+API_KEY_ZEROTWO}}, { upload: zerotwo.waUploadToServer })
await zerotwo.relayMessage(from, 
{
interactiveMessage: {
header: {
title: '',
subtitle: '',
hasMediaAttachment: true,
imageMessage: photos33.imageMessage
},
footer: {
text: '',
},
contextInfo: { participant: sender, quotedMessage: info.message, forwardingScore: 999, isForwarded: true, forwardedNewsletterMessageInfo: {newsletterJid: channel, newsletterName: `𝙲𝙾𝙽𝙽𝙴𝙲𝚃𝙴𝙳 𝙲𝙾𝙽𝚃𝙴Ú𝙳𝙾𝚂`}},
body: { text: `❯❯ ZERO TWO - WALLPAPER ANIME ❮❮

❒ৣ͜͡Categoria: Wallpaper Animes
❒ৣ͜͡Fonte: ${fonte[Math.floor(Math.random() * fonte.length)]} 
❒ৣ͜͡Coleção: Zero Two Oficial 
❒ৣ͜͡Curtidas: ${gozeinonear}
${zerosite}
`,
},nativeFlowMessage: {
buttons: [{
name: "quick_reply",
buttonParamsJson: JSON.stringify({
display_text: "ꪶ͢PROXIMA͢ꫂ",
id: `${prefix}animeimage-madara`
}),},
],
messageParamsJson:"",
},
},
},
{}
).then((r) => console.log(r))
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: animeimage-megumin
└─────────────────────────────────────────────────┘
*/
case 'animeimage-megumin':
reagir(from, "✨")
fonte = ['Instagram', 'Facebook', 'Pinterest', 'Internet']
gozeinonear = Math.floor(Math.random() * 1000)
let photos41 = await prepareWAMessageMedia({ image: {url: `${zerosite}/random/megumin?apikey=`+API_KEY_ZEROTWO}}, { upload: zerotwo.waUploadToServer })
await zerotwo.relayMessage(from, 
{
interactiveMessage: {
header: {
title: '',
subtitle: '',
hasMediaAttachment: true,
imageMessage: photos41.imageMessage
},
footer: {
text: '',
},
contextInfo: { participant: sender, quotedMessage: info.message, forwardingScore: 999, isForwarded: true, forwardedNewsletterMessageInfo: {newsletterJid: channel, newsletterName: `𝙲𝙾𝙽𝙽𝙴𝙲𝚃𝙴𝙳 𝙲𝙾𝙽𝚃𝙴Ú𝙳𝙾𝚂`}},
body: { text: `❯❯ ZERO TWO - WALLPAPER ANIME ❮❮

❒ৣ͜͡Categoria: Wallpaper Animes
❒ৣ͜͡Fonte: ${fonte[Math.floor(Math.random() * fonte.length)]} 
❒ৣ͜͡Coleção: Zero Two Oficial 
❒ৣ͜͡Curtidas: ${gozeinonear}
${zerosite}
`,
},nativeFlowMessage: {
buttons: [{
name: "quick_reply",
buttonParamsJson: JSON.stringify({
display_text: "ꪶ͢PROXIMA͢ꫂ",
id: `${prefix}animeimage-megumin`
}),},
],
messageParamsJson:"",
},
},
},
{}
).then((r) => console.log(r))
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: animeimage-mikasa
└─────────────────────────────────────────────────┘
*/
case 'animeimage-mikasa':
reagir(from, "✨")
fonte = ['Instagram', 'Facebook', 'Pinterest', 'Internet']
gozeinonear = Math.floor(Math.random() * 1000)
let photos7 = await prepareWAMessageMedia({ image: {url: `${zerosite}/random/mikasa?apikey=`+API_KEY_ZEROTWO}}, { upload: zerotwo.waUploadToServer })
await zerotwo.relayMessage(from, 
{
interactiveMessage: {
header: {
title: '',
subtitle: '',
hasMediaAttachment: true,
imageMessage: photos7.imageMessage
},
footer: {
text: '',
},
contextInfo: { participant: sender, quotedMessage: info.message, forwardingScore: 999, isForwarded: true, forwardedNewsletterMessageInfo: {newsletterJid: channel, newsletterName: `𝙲𝙾𝙽𝙽𝙴𝙲𝚃𝙴𝙳 𝙲𝙾𝙽𝚃𝙴Ú𝙳𝙾𝚂`}},
body: { text: `❯❯ ZERO TWO - WALLPAPER ANIME ❮❮

❒ৣ͜͡Categoria: Wallpaper Animes
❒ৣ͜͡Fonte: ${fonte[Math.floor(Math.random() * fonte.length)]} 
❒ৣ͜͡Coleção: Zero Two Oficial 
❒ৣ͜͡Curtidas: ${gozeinonear}
${zerosite}
`,
},nativeFlowMessage: {
buttons: [{
name: "quick_reply",
buttonParamsJson: JSON.stringify({
display_text: "ꪶ͢PROXIMA͢ꫂ",
id: `${prefix}animeimage-mikasa`
}),},
],
messageParamsJson:"",
},
},
},
{}
).then((r) => console.log(r))
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: animeimage-minato
└─────────────────────────────────────────────────┘
*/
case 'animeimage-minato':
reagir(from, "✨")
fonte = ['Instagram', 'Facebook', 'Pinterest', 'Internet']
gozeinonear = Math.floor(Math.random() * 1000)
let photos20 = await prepareWAMessageMedia({ image: {url: `${zerosite}/random/minato?apikey=`+API_KEY_ZEROTWO}}, { upload: zerotwo.waUploadToServer })
await zerotwo.relayMessage(from, 
{
interactiveMessage: {
header: {
title: '',
subtitle: '',
hasMediaAttachment: true,
imageMessage: photos20.imageMessage
},
footer: {
text: '',
},
contextInfo: { participant: sender, quotedMessage: info.message, forwardingScore: 999, isForwarded: true, forwardedNewsletterMessageInfo: {newsletterJid: channel, newsletterName: `𝙲𝙾𝙽𝙽𝙴𝙲𝚃𝙴𝙳 𝙲𝙾𝙽𝚃𝙴Ú𝙳𝙾𝚂`}},
body: { text: `❯❯ ZERO TWO - WALLPAPER ANIME ❮❮

❒ৣ͜͡Categoria: Wallpaper Animes
❒ৣ͜͡Fonte: ${fonte[Math.floor(Math.random() * fonte.length)]} 
❒ৣ͜͡Coleção: Zero Two Oficial 
❒ৣ͜͡Curtidas: ${gozeinonear}
${zerosite}
`,
},nativeFlowMessage: {
buttons: [{
name: "quick_reply",
buttonParamsJson: JSON.stringify({
display_text: "ꪶ͢PROXIMA͢ꫂ",
id: `${prefix}animeimage-minato`
}),},
],
messageParamsJson:"",
},
},
},
{}
).then((r) => console.log(r))
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: animeimage-mobil
└─────────────────────────────────────────────────┘
*/
case 'animeimage-mobil':
reagir(from, "✨")
fonte = ['Instagram', 'Facebook', 'Pinterest', 'Internet']
gozeinonear = Math.floor(Math.random() * 1000)
let photos38 = await prepareWAMessageMedia({ image: {url: `${zerosite}/random/mobil?apikey=`+API_KEY_ZEROTWO}}, { upload: zerotwo.waUploadToServer })
await zerotwo.relayMessage(from, 
{
interactiveMessage: {
header: {
title: '',
subtitle: '',
hasMediaAttachment: true,
imageMessage: photos38.imageMessage
},
footer: {
text: '',
},
contextInfo: { participant: sender, quotedMessage: info.message, forwardingScore: 999, isForwarded: true, forwardedNewsletterMessageInfo: {newsletterJid: channel, newsletterName: `𝙲𝙾𝙽𝙽𝙴𝙲𝚃𝙴𝙳 𝙲𝙾𝙽𝚃𝙴Ú𝙳𝙾𝚂`}},
body: { text: `❯❯ ZERO TWO - WALLPAPER ANIME ❮❮

❒ৣ͜͡Categoria: Wallpaper Animes
❒ৣ͜͡Fonte: ${fonte[Math.floor(Math.random() * fonte.length)]} 
❒ৣ͜͡Coleção: Zero Two Oficial 
❒ৣ͜͡Curtidas: ${gozeinonear}
${zerosite}
`,
},nativeFlowMessage: {
buttons: [{
name: "quick_reply",
buttonParamsJson: JSON.stringify({
display_text: "ꪶ͢PROXIMA͢ꫂ",
id: `${prefix}animeimage-mobil`
}),},
],
messageParamsJson:"",
},
},
},
{}
).then((r) => console.log(r))
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: animeimage-montor
└─────────────────────────────────────────────────┘
*/
case 'animeimage-montor':
reagir(from, "✨")
fonte = ['Instagram', 'Facebook', 'Pinterest', 'Internet']
gozeinonear = Math.floor(Math.random() * 1000)
let photos39 = await prepareWAMessageMedia({ image: {url: `${zerosite}/random/montor?apikey=`+API_KEY_ZEROTWO}}, { upload: zerotwo.waUploadToServer })
await zerotwo.relayMessage(from, 
{
interactiveMessage: {
header: {
title: '',
subtitle: '',
hasMediaAttachment: true,
imageMessage: photos39.imageMessage
},
footer: {
text: '',
},
contextInfo: { participant: sender, quotedMessage: info.message, forwardingScore: 999, isForwarded: true, forwardedNewsletterMessageInfo: {newsletterJid: channel, newsletterName: `𝙲𝙾𝙽𝙽𝙴𝙲𝚃𝙴𝙳 𝙲𝙾𝙽𝚃𝙴Ú𝙳𝙾𝚂`}},
body: { text: `❯❯ ZERO TWO - WALLPAPER ANIME ❮❮

❒ৣ͜͡Categoria: Wallpaper Animes
❒ৣ͜͡Fonte: ${fonte[Math.floor(Math.random() * fonte.length)]} 
❒ৣ͜͡Coleção: Zero Two Oficial 
❒ৣ͜͡Curtidas: ${gozeinonear}
${zerosite}
`,
},nativeFlowMessage: {
buttons: [{
name: "quick_reply",
buttonParamsJson: JSON.stringify({
display_text: "ꪶ͢PROXIMA͢ꫂ",
id: `${prefix}animeimage-montor`
}),},
],
messageParamsJson:"",
},
},
},
{}
).then((r) => console.log(r))
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: animeimage-naruto
└─────────────────────────────────────────────────┘
*/
case 'animeimage-naruto':
reagir(from, "✨")
fonte = ['Instagram', 'Facebook', 'Pinterest', 'Internet']
gozeinonear = Math.floor(Math.random() * 1000)
let photos19 = await prepareWAMessageMedia({ image: {url: `${zerosite}/random/naruto?apikey=`+API_KEY_ZEROTWO}}, { upload: zerotwo.waUploadToServer })
await zerotwo.relayMessage(from, 
{
interactiveMessage: {
header: {
title: '',
subtitle: '',
hasMediaAttachment: true,
imageMessage: photos19.imageMessage
},
footer: {
text: '',
},
contextInfo: { participant: sender, quotedMessage: info.message, forwardingScore: 999, isForwarded: true, forwardedNewsletterMessageInfo: {newsletterJid: channel, newsletterName: `𝙲𝙾𝙽𝙽𝙴𝙲𝚃𝙴𝙳 𝙲𝙾𝙽𝚃𝙴Ú𝙳𝙾𝚂`}},
body: { text: `❯❯ ZERO TWO - WALLPAPER ANIME ❮❮

❒ৣ͜͡Categoria: Wallpaper Animes
❒ৣ͜͡Fonte: ${fonte[Math.floor(Math.random() * fonte.length)]} 
❒ৣ͜͡Coleção: Zero Two Oficial 
❒ৣ͜͡Curtidas: ${gozeinonear}
${zerosite}
`,
},nativeFlowMessage: {
buttons: [{
name: "quick_reply",
buttonParamsJson: JSON.stringify({
display_text: "ꪶ͢PROXIMA͢ꫂ",
id: `${prefix}animeimage-naruto`
}),},
],
messageParamsJson:"",
},
},
},
{}
).then((r) => console.log(r))
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: animeimage-nezuko
└─────────────────────────────────────────────────┘
*/
case 'animeimage-nezuko':
reagir(from, "✨")
fonte = ['Instagram', 'Facebook', 'Pinterest', 'Internet']
gozeinonear = Math.floor(Math.random() * 1000)
let photos22 = await prepareWAMessageMedia({ image: {url: `${zerosite}/random/nezuko?apikey=`+API_KEY_ZEROTWO}}, { upload: zerotwo.waUploadToServer })
await zerotwo.relayMessage(from, 
{
interactiveMessage: {
header: {
title: '',
subtitle: '',
hasMediaAttachment: true,
imageMessage: photos22.imageMessage
},
footer: {
text: '',
},
contextInfo: { participant: sender, quotedMessage: info.message, forwardingScore: 999, isForwarded: true, forwardedNewsletterMessageInfo: {newsletterJid: channel, newsletterName: `𝙲𝙾𝙽𝙽𝙴𝙲𝚃𝙴𝙳 𝙲𝙾𝙽𝚃𝙴Ú𝙳𝙾𝚂`}},
body: { text: `❯❯ ZERO TWO - WALLPAPER ANIME ❮❮

❒ৣ͜͡Categoria: Wallpaper Animes
❒ৣ͜͡Fonte: ${fonte[Math.floor(Math.random() * fonte.length)]} 
❒ৣ͜͡Coleção: Zero Two Oficial 
❒ৣ͜͡Curtidas: ${gozeinonear}
${zerosite}
`,
},nativeFlowMessage: {
buttons: [{
name: "quick_reply",
buttonParamsJson: JSON.stringify({
display_text: "ꪶ͢PROXIMA͢ꫂ",
id: `${prefix}animeimage-nezuko`
}),},
],
messageParamsJson:"",
},
},
},
{}
).then((r) => console.log(r))
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: animeimage-onepiece
└─────────────────────────────────────────────────┘
*/
case 'animeimage-onepiece':
reagir(from, "✨")
fonte = ['Instagram', 'Facebook', 'Pinterest', 'Internet']
gozeinonear = Math.floor(Math.random() * 1000)
let photos37 = await prepareWAMessageMedia({ image: {url: `${zerosite}/random/onepiece?apikey=`+API_KEY_ZEROTWO}}, { upload: zerotwo.waUploadToServer })
await zerotwo.relayMessage(from, 
{
interactiveMessage: {
header: {
title: '',
subtitle: '',
hasMediaAttachment: true,
imageMessage: photos37.imageMessage
},
footer: {
text: '',
},
contextInfo: { participant: sender, quotedMessage: info.message, forwardingScore: 999, isForwarded: true, forwardedNewsletterMessageInfo: {newsletterJid: channel, newsletterName: `𝙲𝙾𝙽𝙽𝙴𝙲𝚃𝙴𝙳 𝙲𝙾𝙽𝚃𝙴Ú𝙳𝙾𝚂`}},
body: { text: `❯❯ ZERO TWO - WALLPAPER ANIME ❮❮

❒ৣ͜͡Categoria: Wallpaper Animes
❒ৣ͜͡Fonte: ${fonte[Math.floor(Math.random() * fonte.length)]} 
❒ৣ͜͡Coleção: Zero Two Oficial 
❒ৣ͜͡Curtidas: ${gozeinonear}
${zerosite}
`,
},nativeFlowMessage: {
buttons: [{
name: "quick_reply",
buttonParamsJson: JSON.stringify({
display_text: "ꪶ͢PROXIMA͢ꫂ",
id: `${prefix}animeimage-onepiece`
}),},
],
messageParamsJson:"",
},
},
},
{}
).then((r) => console.log(r))
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: animeimage-rize
└─────────────────────────────────────────────────┘
*/
case 'animeimage-rize':
reagir(from, "✨")
fonte = ['Instagram', 'Facebook', 'Pinterest', 'Internet']
gozeinonear = Math.floor(Math.random() * 1000)
let photos23 = await prepareWAMessageMedia({ image: {url: `${zerosite}/random/rize?apikey=`+API_KEY_ZEROTWO}}, { upload: zerotwo.waUploadToServer })
await zerotwo.relayMessage(from, 
{
interactiveMessage: {
header: {
title: '',
subtitle: '',
hasMediaAttachment: true,
imageMessage: photos23.imageMessage
},
footer: {
text: '',
},
contextInfo: { participant: sender, quotedMessage: info.message, forwardingScore: 999, isForwarded: true, forwardedNewsletterMessageInfo: {newsletterJid: channel, newsletterName: `𝙲𝙾𝙽𝙽𝙴𝙲𝚃𝙴𝙳 𝙲𝙾𝙽𝚃𝙴Ú𝙳𝙾𝚂`}},
body: { text: `❯❯ ZERO TWO - WALLPAPER ANIME ❮❮

❒ৣ͜͡Categoria: Wallpaper Animes
❒ৣ͜͡Fonte: ${fonte[Math.floor(Math.random() * fonte.length)]} 
❒ৣ͜͡Coleção: Zero Two Oficial 
❒ৣ͜͡Curtidas: ${gozeinonear}
${zerosite}
`,
},nativeFlowMessage: {
buttons: [{
name: "quick_reply",
buttonParamsJson: JSON.stringify({
display_text: "ꪶ͢PROXIMA͢ꫂ",
id: `${prefix}animeimage-rize`
}),},
],
messageParamsJson:"",
},
},
},
{}
).then((r) => console.log(r))
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: animeimage-sagari
└─────────────────────────────────────────────────┘
*/
case 'animeimage-sagari':
reagir(from, "✨")
fonte = ['Instagram', 'Facebook', 'Pinterest', 'Internet']
gozeinonear = Math.floor(Math.random() * 1000)
let photos21 = await prepareWAMessageMedia({ image: {url: `${zerosite}/random/sagari?apikey=`+API_KEY_ZEROTWO}}, { upload: zerotwo.waUploadToServer })
await zerotwo.relayMessage(from, 
{
interactiveMessage: {
header: {
title: '',
subtitle: '',
hasMediaAttachment: true,
imageMessage: photos21.imageMessage
},
footer: {
text: '',
},
contextInfo: { participant: sender, quotedMessage: info.message, forwardingScore: 999, isForwarded: true, forwardedNewsletterMessageInfo: {newsletterJid: channel, newsletterName: `𝙲𝙾𝙽𝙽𝙴𝙲𝚃𝙴𝙳 𝙲𝙾𝙽𝚃𝙴Ú𝙳𝙾𝚂`}},
body: { text: `❯❯ ZERO TWO - WALLPAPER ANIME ❮❮

❒ৣ͜͡Categoria: Wallpaper Animes
❒ৣ͜͡Fonte: ${fonte[Math.floor(Math.random() * fonte.length)]} 
❒ৣ͜͡Coleção: Zero Two Oficial 
❒ৣ͜͡Curtidas: ${gozeinonear}
${zerosite}
`,
},nativeFlowMessage: {
buttons: [{
name: "quick_reply",
buttonParamsJson: JSON.stringify({
display_text: "ꪶ͢PROXIMA͢ꫂ",
id: `${prefix}animeimage-sagari`
}),},
],
messageParamsJson:"",
},
},
},
{}
).then((r) => console.log(r))
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: animeimage-sakura
└─────────────────────────────────────────────────┘
*/
case 'animeimage-sakura':
reagir(from, "✨")
fonte = ['Instagram', 'Facebook', 'Pinterest', 'Internet']
gozeinonear = Math.floor(Math.random() * 1000)
let photos34 = await prepareWAMessageMedia({ image: {url: `${zerosite}/random/sakura?apikey=`+API_KEY_ZEROTWO}}, { upload: zerotwo.waUploadToServer })
await zerotwo.relayMessage(from, 
{
interactiveMessage: {
header: {
title: '',
subtitle: '',
hasMediaAttachment: true,
imageMessage: photos34.imageMessage
},
footer: {
text: '',
},
contextInfo: { participant: sender, quotedMessage: info.message, forwardingScore: 999, isForwarded: true, forwardedNewsletterMessageInfo: {newsletterJid: channel, newsletterName: `𝙲𝙾𝙽𝙽𝙴𝙲𝚃𝙴𝙳 𝙲𝙾𝙽𝚃𝙴Ú𝙳𝙾𝚂`}},
body: { text: `❯❯ ZERO TWO - WALLPAPER ANIME ❮❮

❒ৣ͜͡Categoria: Wallpaper Animes
❒ৣ͜͡Fonte: ${fonte[Math.floor(Math.random() * fonte.length)]} 
❒ৣ͜͡Coleção: Zero Two Oficial 
❒ৣ͜͡Curtidas: ${gozeinonear}
${zerosite}
`,
},nativeFlowMessage: {
buttons: [{
name: "quick_reply",
buttonParamsJson: JSON.stringify({
display_text: "ꪶ͢PROXIMA͢ꫂ",
id: `${prefix}animeimage-sakura`
}),},
],
messageParamsJson:"",
},
},
},
{}
).then((r) => console.log(r))
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: animeimage-sasuke
└─────────────────────────────────────────────────┘
*/
case 'animeimage-sasuke':
reagir(from, "✨")
fonte = ['Instagram', 'Facebook', 'Pinterest', 'Internet']
gozeinonear = Math.floor(Math.random() * 1000)
let photos35 = await prepareWAMessageMedia({ image: {url: `${zerosite}/random/sasuke?apikey=`+API_KEY_ZEROTWO}}, { upload: zerotwo.waUploadToServer })
await zerotwo.relayMessage(from, 
{
interactiveMessage: {
header: {
title: '',
subtitle: '',
hasMediaAttachment: true,
imageMessage: photos35.imageMessage
},
footer: {
text: '',
},
contextInfo: { participant: sender, quotedMessage: info.message, forwardingScore: 999, isForwarded: true, forwardedNewsletterMessageInfo: {newsletterJid: channel, newsletterName: `𝙲𝙾𝙽𝙽𝙴𝙲𝚃𝙴𝙳 𝙲𝙾𝙽𝚃𝙴Ú𝙳𝙾𝚂`}},
body: { text: `❯❯ ZERO TWO - WALLPAPER ANIME ❮❮

❒ৣ͜͡Categoria: Wallpaper Animes
❒ৣ͜͡Fonte: ${fonte[Math.floor(Math.random() * fonte.length)]} 
❒ৣ͜͡Coleção: Zero Two Oficial 
❒ৣ͜͡Curtidas: ${gozeinonear}
${zerosite}
`,
},nativeFlowMessage: {
buttons: [{
name: "quick_reply",
buttonParamsJson: JSON.stringify({
display_text: "ꪶ͢PROXIMA͢ꫂ",
id: `${prefix}animeimage-sasuke`
}),},
],
messageParamsJson:"",
},
},
},
{}
).then((r) => console.log(r))
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: animeimage-shina
└─────────────────────────────────────────────────┘
*/
case 'animeimage-shina':
reagir(from, "✨")
fonte = ['Instagram', 'Facebook', 'Pinterest', 'Internet']
gozeinonear = Math.floor(Math.random() * 1000)
let photos11 = await prepareWAMessageMedia({ image: {url: `${zerosite}/random/shina?apikey=`+API_KEY_ZEROTWO}}, { upload: zerotwo.waUploadToServer })
await zerotwo.relayMessage(from, 
{
interactiveMessage: {
header: {
title: '',
subtitle: '',
hasMediaAttachment: true,
imageMessage: photos11.imageMessage
},
footer: {
text: '',
},
contextInfo: { participant: sender, quotedMessage: info.message, forwardingScore: 999, isForwarded: true, forwardedNewsletterMessageInfo: {newsletterJid: channel, newsletterName: `𝙲𝙾𝙽𝙽𝙴𝙲𝚃𝙴𝙳 𝙲𝙾𝙽𝚃𝙴Ú𝙳𝙾𝚂`}},
body: { text: `❯❯ ZERO TWO - WALLPAPER ANIME ❮❮

❒ৣ͜͡Categoria: Wallpaper Animes
❒ৣ͜͡Fonte: ${fonte[Math.floor(Math.random() * fonte.length)]} 
❒ৣ͜͡Coleção: Zero Two Oficial 
❒ৣ͜͡Curtidas: ${gozeinonear}
${zerosite}
`,
},nativeFlowMessage: {
buttons: [{
name: "quick_reply",
buttonParamsJson: JSON.stringify({
display_text: "ꪶ͢PROXIMA͢ꫂ",
id: `${prefix}animeimage-shina`
}),},
],
messageParamsJson:"",
},
},
},
{}
).then((r) => console.log(r))
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: animeimage-shinka
└─────────────────────────────────────────────────┘
*/
case 'animeimage-shinka':
reagir(from, "✨")
fonte = ['Instagram', 'Facebook', 'Pinterest', 'Internet']
gozeinonear = Math.floor(Math.random() * 1000)
let photos13 = await prepareWAMessageMedia({ image: {url: `${zerosite}/random/shinka?apikey=`+API_KEY_ZEROTWO}}, { upload: zerotwo.waUploadToServer })
await zerotwo.relayMessage(from, 
{
interactiveMessage: {
header: {
title: '',
subtitle: '',
hasMediaAttachment: true,
imageMessage: photos13.imageMessage
},
footer: {
text: '',
},
contextInfo: { participant: sender, quotedMessage: info.message, forwardingScore: 999, isForwarded: true, forwardedNewsletterMessageInfo: {newsletterJid: channel, newsletterName: `𝙲𝙾𝙽𝙽𝙴𝙲𝚃𝙴𝙳 𝙲𝙾𝙽𝚃𝙴Ú𝙳𝙾𝚂`}},
body: { text: `❯❯ ZERO TWO - WALLPAPER ANIME ❮❮

❒ৣ͜͡Categoria: Wallpaper Animes
❒ৣ͜͡Fonte: ${fonte[Math.floor(Math.random() * fonte.length)]} 
❒ৣ͜͡Coleção: Zero Two Oficial 
❒ৣ͜͡Curtidas: ${gozeinonear}
${zerosite}
`,
},nativeFlowMessage: {
buttons: [{
name: "quick_reply",
buttonParamsJson: JSON.stringify({
display_text: "ꪶ͢PROXIMA͢ꫂ",
id: `${prefix}animeimage-shinka`
}),},
],
messageParamsJson:"",
},
},
},
{}
).then((r) => console.log(r))
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: animeimage-shinomiya
└─────────────────────────────────────────────────┘
*/
case 'animeimage-shinomiya':
reagir(from, "✨")
fonte = ['Instagram', 'Facebook', 'Pinterest', 'Internet']
gozeinonear = Math.floor(Math.random() * 1000)
let imagessssss = await prepareWAMessageMedia({ image: {url: `${zerosite}/random/shinomiya?apikey=`+API_KEY_ZEROTWO}}, { upload: zerotwo.waUploadToServer })
await zerotwo.relayMessage(from, 
{
interactiveMessage: {
header: {
title: '',
subtitle: '',
hasMediaAttachment: true,
imageMessage: imagessssss.imageMessage
},
footer: {
text: '',
},
contextInfo: { participant: sender, quotedMessage: info.message, forwardingScore: 999, isForwarded: true, forwardedNewsletterMessageInfo: {newsletterJid: channel, newsletterName: `𝙲𝙾𝙽𝙽𝙴𝙲𝚃𝙴𝙳 𝙲𝙾𝙽𝚃𝙴Ú𝙳𝙾𝚂`}},
body: { text: `❯❯ ZERO TWO - WALLPAPER ANIME ❮❮

❒ৣ͜͡Categoria: Wallpaper Animes
❒ৣ͜͡Fonte: ${fonte[Math.floor(Math.random() * fonte.length)]} 
❒ৣ͜͡Coleção: Zero Two Oficial 
❒ৣ͜͡Curtidas: ${gozeinonear}
${zerosite}
`,
},nativeFlowMessage: {
buttons: [{
name: "quick_reply",
buttonParamsJson: JSON.stringify({
display_text: "ꪶ͢PROXIMA͢ꫂ",
id: `${prefix}animeimage-shinomiya`
}),},
],
messageParamsJson:"",
},
},
},
{}
).then((r) => console.log(r))
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: animeimage-shizuka
└─────────────────────────────────────────────────┘
*/
case 'animeimage-shizuka':
reagir(from, "✨")
fonte = ['Instagram', 'Facebook', 'Pinterest', 'Internet']
gozeinonear = Math.floor(Math.random() * 1000)
let photos4 = await prepareWAMessageMedia({ image: {url: `${zerosite}/random/shizuka?apikey=`+API_KEY_ZEROTWO}}, { upload: zerotwo.waUploadToServer })
await zerotwo.relayMessage(from, 
{
interactiveMessage: {
header: {
title: '',
subtitle: '',
hasMediaAttachment: true,
imageMessage: photos4.imageMessage
},
footer: {
text: '',
},
contextInfo: { participant: sender, quotedMessage: info.message, forwardingScore: 999, isForwarded: true, forwardedNewsletterMessageInfo: {newsletterJid: channel, newsletterName: `𝙲𝙾𝙽𝙽𝙴𝙲𝚃𝙴𝙳 𝙲𝙾𝙽𝚃𝙴Ú𝙳𝙾𝚂`}},
body: { text: `❯❯ ZERO TWO - WALLPAPER ANIME ❮❮

❒ৣ͜͡Categoria: Wallpaper Animes
❒ৣ͜͡Fonte: ${fonte[Math.floor(Math.random() * fonte.length)]} 
❒ৣ͜͡Coleção: Zero Two Oficial 
❒ৣ͜͡Curtidas: ${gozeinonear}
${zerosite}
`,
},nativeFlowMessage: {
buttons: [{
name: "quick_reply",
buttonParamsJson: JSON.stringify({
display_text: "ꪶ͢PROXIMA͢ꫂ",
id: `${prefix}animeimage-shizuka`
}),},
],
messageParamsJson:"",
},
},
},
{}
).then((r) => console.log(r))
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: animeimage-shota
└─────────────────────────────────────────────────┘
*/
case 'animeimage-shota':
reagir(from, "✨")
fonte = ['Instagram', 'Facebook', 'Pinterest', 'Internet']
gozeinonear = Math.floor(Math.random() * 1000)
let imagessss = await prepareWAMessageMedia({ image: {url: `${zerosite}/random/shota?apikey=`+API_KEY_ZEROTWO}}, { upload: zerotwo.waUploadToServer })
await zerotwo.relayMessage(from, 
{
interactiveMessage: {
header: {
title: '',
subtitle: '',
hasMediaAttachment: true,
imageMessage: imagessss.imageMessage
},
footer: {
text: '',
},
contextInfo: { participant: sender, quotedMessage: info.message, forwardingScore: 999, isForwarded: true, forwardedNewsletterMessageInfo: {newsletterJid: channel, newsletterName: `𝙲𝙾𝙽𝙽𝙴𝙲𝚃𝙴𝙳 𝙲𝙾𝙽𝚃𝙴Ú𝙳𝙾𝚂`}},
body: { text: `❯❯ ZERO TWO - WALLPAPER ANIME ❮❮

❒ৣ͜͡Categoria: Wallpaper Animes
❒ৣ͜͡Fonte: ${fonte[Math.floor(Math.random() * fonte.length)]} 
❒ৣ͜͡Coleção: Zero Two Oficial 
❒ৣ͜͡Curtidas: ${gozeinonear}
${zerosite}
`,
},nativeFlowMessage: {
buttons: [{
name: "quick_reply",
buttonParamsJson: JSON.stringify({
display_text: "ꪶ͢PROXIMA͢ꫂ",
id: `${prefix}animeimage-shota`
}),},
],
messageParamsJson:"",
},
},
},
{}
).then((r) => console.log(r))
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: animeimage-tejina
└─────────────────────────────────────────────────┘
*/
case 'animeimage-tejina':
reagir(from, "✨")
fonte = ['Instagram', 'Facebook', 'Pinterest', 'Internet']
gozeinonear = Math.floor(Math.random() * 1000)
let photos = await prepareWAMessageMedia({ image: {url: `${zerosite}/random/tejina?apikey=`+API_KEY_ZEROTWO}}, { upload: zerotwo.waUploadToServer })
await zerotwo.relayMessage(from, 
{
interactiveMessage: {
header: {
title: '',
subtitle: '',
hasMediaAttachment: true,
imageMessage: photos.imageMessage
},
footer: {
text: '',
},
contextInfo: { participant: sender, quotedMessage: info.message, forwardingScore: 999, isForwarded: true, forwardedNewsletterMessageInfo: {newsletterJid: channel, newsletterName: `𝙲𝙾𝙽𝙽𝙴𝙲𝚃𝙴𝙳 𝙲𝙾𝙽𝚃𝙴Ú𝙳𝙾𝚂`}},
body: { text: `❯❯ ZERO TWO - WALLPAPER ANIME ❮❮

❒ৣ͜͡Categoria: Wallpaper Animes
❒ৣ͜͡Fonte: ${fonte[Math.floor(Math.random() * fonte.length)]} 
❒ৣ͜͡Coleção: Zero Two Oficial 
❒ৣ͜͡Curtidas: ${gozeinonear}
${zerosite}
`,
},nativeFlowMessage: {
buttons: [{
name: "quick_reply",
buttonParamsJson: JSON.stringify({
display_text: "ꪶ͢PROXIMA͢ꫂ",
id: `${prefix}animeimage-tejina`
}),},
],
messageParamsJson:"",
},
},
},
{}
).then((r) => console.log(r))
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: animeimage-toukachan
└─────────────────────────────────────────────────┘
*/
case 'animeimage-toukachan':
reagir(from, "✨")
fonte = ['Instagram', 'Facebook', 'Pinterest', 'Internet']
gozeinonear = Math.floor(Math.random() * 1000)
let photos42 = await prepareWAMessageMedia({ image: {url: `${zerosite}/random/toukachan?apikey=`+API_KEY_ZEROTWO}}, { upload: zerotwo.waUploadToServer })
await zerotwo.relayMessage(from, 
{
interactiveMessage: {
header: {
title: '',
subtitle: '',
hasMediaAttachment: true,
imageMessage: photos42.imageMessage
},
footer: {
text: '',
},
contextInfo: { participant: sender, quotedMessage: info.message, forwardingScore: 999, isForwarded: true, forwardedNewsletterMessageInfo: {newsletterJid: channel, newsletterName: `𝙲𝙾𝙽𝙽𝙴𝙲𝚃𝙴𝙳 𝙲𝙾𝙽𝚃𝙴Ú𝙳𝙾𝚂`}},
body: { text: `❯❯ ZERO TWO - WALLPAPER ANIME ❮❮

❒ৣ͜͡Categoria: Wallpaper Animes
❒ৣ͜͡Fonte: ${fonte[Math.floor(Math.random() * fonte.length)]} 
❒ৣ͜͡Coleção: Zero Two Oficial 
❒ৣ͜͡Curtidas: ${gozeinonear}
${zerosite}
`,
},nativeFlowMessage: {
buttons: [{
name: "quick_reply",
buttonParamsJson: JSON.stringify({
display_text: "ꪶ͢PROXIMA͢ꫂ",
id: `${prefix}animeimage-toukachan`
}),},
],
messageParamsJson:"",
},
},
},
{}
).then((r) => console.log(r))
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: animeimage-tsunade
└─────────────────────────────────────────────────┘
*/
case 'animeimage-tsunade':
reagir(from, "✨")
fonte = ['Instagram', 'Facebook', 'Pinterest', 'Internet']
gozeinonear = Math.floor(Math.random() * 1000)
let photos36 = await prepareWAMessageMedia({ image: {url: `${zerosite}/random/tsunade?apikey=`+API_KEY_ZEROTWO}}, { upload: zerotwo.waUploadToServer })
await zerotwo.relayMessage(from, 
{
interactiveMessage: {
header: {
title: '',
subtitle: '',
hasMediaAttachment: true,
imageMessage: photos36.imageMessage
},
footer: {
text: '',
},
contextInfo: { participant: sender, quotedMessage: info.message, forwardingScore: 999, isForwarded: true, forwardedNewsletterMessageInfo: {newsletterJid: channel, newsletterName: `𝙲𝙾𝙽𝙽𝙴𝙲𝚃𝙴𝙳 𝙲𝙾𝙽𝚃𝙴Ú𝙳𝙾𝚂`}},
body: { text: `❯❯ ZERO TWO - WALLPAPER ANIME ❮❮

❒ৣ͜͡Categoria: Wallpaper Animes
❒ৣ͜͡Fonte: ${fonte[Math.floor(Math.random() * fonte.length)]} 
❒ৣ͜͡Coleção: Zero Two Oficial 
❒ৣ͜͡Curtidas: ${gozeinonear}
${zerosite}
`,
},nativeFlowMessage: {
buttons: [{
name: "quick_reply",
buttonParamsJson: JSON.stringify({
display_text: "ꪶ͢PROXIMA͢ꫂ",
id: `${prefix}animeimage-tsunade`
}),},
],
messageParamsJson:"",
},
},
},
{}
).then((r) => console.log(r))
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: animeimage-waifu
└─────────────────────────────────────────────────┘
*/
case 'animeimage-waifu':
reagir(from, "✨")
fonte = ['Instagram', 'Facebook', 'Pinterest', 'Internet']
gozeinonear = Math.floor(Math.random() * 1000)
let imagess = await prepareWAMessageMedia({ image: {url: `${zerosite}/random/waifu?apikey=`+API_KEY_ZEROTWO}}, { upload: zerotwo.waUploadToServer })
await zerotwo.relayMessage(from, 
{
interactiveMessage: {
header: {
title: '',
subtitle: '',
hasMediaAttachment: true,
imageMessage: imagess.imageMessage
},
footer: {
text: '',
},
contextInfo: { participant: sender, quotedMessage: info.message, forwardingScore: 999, isForwarded: true, forwardedNewsletterMessageInfo: {newsletterJid: channel, newsletterName: `𝙲𝙾𝙽𝙽𝙴𝙲𝚃𝙴𝙳 𝙲𝙾𝙽𝚃𝙴Ú𝙳𝙾𝚂`}},
body: { text: `❯❯ ZERO TWO - WALLPAPER ANIME ❮❮

❒ৣ͜͡Categoria: Wallpaper Animes
❒ৣ͜͡Fonte: ${fonte[Math.floor(Math.random() * fonte.length)]} 
❒ৣ͜͡Coleção: Zero Two Oficial 
❒ৣ͜͡Curtidas: ${gozeinonear}
${zerosite}
`,
},nativeFlowMessage: {
buttons: [{
name: "quick_reply",
buttonParamsJson: JSON.stringify({
display_text: "ꪶ͢PROXIMA͢ꫂ",
id: `${prefix}animeimage-waifu`
}),},
],
messageParamsJson:"",
},
},
},
{}
).then((r) => console.log(r))
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: animeimage-yotsuba
└─────────────────────────────────────────────────┘
*/
case 'animeimage-yotsuba':
reagir(from, "✨")
fonte = ['Instagram', 'Facebook', 'Pinterest', 'Internet']
gozeinonear = Math.floor(Math.random() * 1000)
let imagesssss = await prepareWAMessageMedia({ image: {url: `${zerosite}/random/yotsuba?apikey=`+API_KEY_ZEROTWO}}, { upload: zerotwo.waUploadToServer })
await zerotwo.relayMessage(from, 
{
interactiveMessage: {
header: {
title: '',
subtitle: '',
hasMediaAttachment: true,
imageMessage: imagesssss.imageMessage
},
footer: {
text: '',
},
contextInfo: { participant: sender, quotedMessage: info.message, forwardingScore: 999, isForwarded: true, forwardedNewsletterMessageInfo: {newsletterJid: channel, newsletterName: `𝙲𝙾𝙽𝙽𝙴𝙲𝚃𝙴𝙳 𝙲𝙾𝙽𝚃𝙴Ú𝙳𝙾𝚂`}},
body: { text: `❯❯ ZERO TWO - WALLPAPER ANIME ❮❮

❒ৣ͜͡Categoria: Wallpaper Animes
❒ৣ͜͡Fonte: ${fonte[Math.floor(Math.random() * fonte.length)]} 
❒ৣ͜͡Coleção: Zero Two Oficial 
❒ৣ͜͡Curtidas: ${gozeinonear}
${zerosite}
`,
},nativeFlowMessage: {
buttons: [{
name: "quick_reply",
buttonParamsJson: JSON.stringify({
display_text: "ꪶ͢PROXIMA͢ꫂ",
id: `${prefix}animeimage-yotsuba`
}),},
],
messageParamsJson:"",
},
},
},
{}
).then((r) => console.log(r))
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: animeimage-yumeko
└─────────────────────────────────────────────────┘
*/
case 'animeimage-yumeko':
reagir(from, "✨")
fonte = ['Instagram', 'Facebook', 'Pinterest', 'Internet']
gozeinonear = Math.floor(Math.random() * 1000)
let imagesssssss = await prepareWAMessageMedia({ image: {url: `${zerosite}/random/yumeko?apikey=`+API_KEY_ZEROTWO}}, { upload: zerotwo.waUploadToServer })
await zerotwo.relayMessage(from, 
{
interactiveMessage: {
header: {
title: '',
subtitle: '',
hasMediaAttachment: true,
imageMessage: imagesssssss.imageMessage
},
footer: {
text: '',
},
contextInfo: { participant: sender, quotedMessage: info.message, forwardingScore: 999, isForwarded: true, forwardedNewsletterMessageInfo: {newsletterJid: channel, newsletterName: `𝙲𝙾𝙽𝙽𝙴𝙲𝚃𝙴𝙳 𝙲𝙾𝙽𝚃𝙴Ú𝙳𝙾𝚂`}},
body: { text: `❯❯ ZERO TWO - WALLPAPER ANIME ❮❮

❒ৣ͜͡Categoria: Wallpaper Animes
❒ৣ͜͡Fonte: ${fonte[Math.floor(Math.random() * fonte.length)]} 
❒ৣ͜͡Coleção: Zero Two Oficial 
❒ৣ͜͡Curtidas: ${gozeinonear}
${zerosite}
`,
},nativeFlowMessage: {
buttons: [{
name: "quick_reply",
buttonParamsJson: JSON.stringify({
display_text: "ꪶ͢PROXIMA͢ꫂ",
id: `${prefix}animeimage-yumeko`
}),},
],
messageParamsJson:"",
},
},
},
{}
).then((r) => console.log(r))
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: animeimage-yuri
└─────────────────────────────────────────────────┘
*/
case 'animeimage-yuri':
reagir(from, "✨")
fonte = ['Instagram', 'Facebook', 'Pinterest', 'Internet']
gozeinonear = Math.floor(Math.random() * 1000)
let photos15 = await prepareWAMessageMedia({ image: {url: `${zerosite}/random/yuri?apikey=`+API_KEY_ZEROTWO}}, { upload: zerotwo.waUploadToServer })
await zerotwo.relayMessage(from, 
{
interactiveMessage: {
header: {
title: '',
subtitle: '',
hasMediaAttachment: true,
imageMessage: photos15.imageMessage
},
footer: {
text: '',
},
contextInfo: { participant: sender, quotedMessage: info.message, forwardingScore: 999, isForwarded: true, forwardedNewsletterMessageInfo: {newsletterJid: channel, newsletterName: `𝙲𝙾𝙽𝙽𝙴𝙲𝚃𝙴𝙳 𝙲𝙾𝙽𝚃𝙴Ú𝙳𝙾𝚂`}},
body: { text: `❯❯ ZERO TWO - WALLPAPER ANIME ❮❮

❒ৣ͜͡Categoria: Wallpaper Animes
❒ৣ͜͡Fonte: ${fonte[Math.floor(Math.random() * fonte.length)]} 
❒ৣ͜͡Coleção: Zero Two Oficial 
❒ৣ͜͡Curtidas: ${gozeinonear}
${zerosite}
`,
},nativeFlowMessage: {
buttons: [{
name: "quick_reply",
buttonParamsJson: JSON.stringify({
display_text: "ꪶ͢PROXIMA͢ꫂ",
id: `${prefix}animeimage-yuri`
}),},
],
messageParamsJson:"",
},
},
},
{}
).then((r) => console.log(r))
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: apibot
└─────────────────────────────────────────────────┘
*/
case 'apibot':
reagir(from, "✅")
if(!isOwner) return reply(`Não`)
api = await fetchJson(`${zerosite}/api/keyerrada?apikey=`+API_KEY_ZEROTWO)
api2 = `${tempo} ${pushname}

✔️ Você Tem『 ${api.limite_de_request} 』Downloads Disponíveis...

🔗 Rest Api『 ${zerosite} 』`
reply(api2)
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: applemusic
└─────────────────────────────────────────────────┘
*/
case 'applemusic':
try {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
//Canal: https://whatsapp.com/channel/0029Va6riekH5JLwLUFI7P2B
reagir(from, "🎵")
if (!q) return reply(`${prefix + command} nome da música ou artista`)
const response = await fetchJson(`${zerosite}/api/applemusic/search?query=${encodeURIComponent(q)}&apikey=${API_KEY_ZEROTWO}`)
if (!response.status || !response.resultado || response.resultado.length === 0) {
return reply("❌ Nenhum resultado encontrado para sua busca.")
}
const musica = response.resultado[0]
const caption = `🎵 *❒️ Título*: ${musica.title || "Desconhecido"}
🎙️ *❒️ Artista*: ${musica.artist.name || "Desconhecido"}
`
const thumb = musica.image
const botoes = [{ type: 'copy_url', text: '🎵 Ouvir no Apple Music', url: musica.song }]
await sendRouletteButton(from, { image: { url: thumb }, caption: caption.trim(), footer: NomeDoBot }, zerotwo, sender, botoes, selolucas )
const API_URL = `${zerosite}/api/applemusic/download?url=${musica.song}&apikey=${API_KEY_ZEROTWO}`
const getMusicData = async (url) => {
const response = await fetch(url)
const data = await response.json()
return data.resultado
}
const musicaData = await getMusicData(API_URL)
await zerotwo.sendMessage(from, { audio: { url: musicaData.download }, fileName: musicaData.metadata.name + '.mp3', mimetype: 'audio/mpeg', ptt: true, headerType: 4, contextInfo: { externalAdReply: { title: musicaData.metadata.name, body: `Artista: ${musicaData.metadata.artist} | Álbum: ${musicaData.metadata.album}`, showAdAttribution: true, thumbnail: await getBuffer(musica.image), mediaType: 2, mediaUrl: musicaData.metadata.url, sourceUrl: musicaData.metadata.url }}}, { quoted: selolucas })
} catch (e) {
console.log(e)
return reply("❌ Ocorreu um erro ao buscar ou exibir a música.")
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: as
└─────────────────────────────────────────────────┘
*/
case 'as':
if (!isVip && !isGroup) return reply(enviar.msg.vip)
if (!q) return reply(`Exemplo:\n\n${prefix + command} Seu Texto`)
if (q.length > 25) return reply("Texto muito grande")
try {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
const response = await fetch(`${zerosite}/api/amongus?texto=${encodeURI(q)}&apikey=${API_KEY_ZEROTWO}`)
if (!response.ok) throw new Error('Erro ao obter o sticker')
const buffer = await response.arrayBuffer()
const stickerBuffer = Buffer.from(buffer)
await zerotwo.sendMessage(from, { sticker: stickerBuffer }, { quoted: selolucas })
} catch (e) {
console.log(e)
reply("Erro ao criar o sticker.")
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: attp12
└─────────────────────────────────────────────────┘
*/
case 'attp12':
if (!q) return reply("Ei, cadê o texto?")
try {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
//Canal: https://whatsapp.com/channel/0029Va6riekH5JLwLUFI7P2B
const tempDir = path.join(__dirname, 'temp')
if (!fs.existsSync(tempDir)) {
fs.mkdirSync(tempDir, { recursive: true })
}
const url = `${zerosite}/attps?type=${command}&texto=${encodeURIComponent(q)}&apikey=${API_KEY_ZEROTWO}`
const response = await fetch(url)
if (!response.ok) {
console.error(`Erro na API: ${response.status} - ${response.statusText}`)
return reply("Houve um problema ao processar sua solicitação.")
}
const arrayBuffer = await response.arrayBuffer()
const stickerBuffer = Buffer.from(arrayBuffer)
const stickerPath = path.join(tempDir, 'sticker.webp')
const gifPath = path.join(tempDir, 'sticker.gif')
const finalStickerPath = path.join(tempDir, 'sticker_final.webp')
fs.writeFileSync(stickerPath, stickerBuffer)
exec(`ffmpeg -i ${stickerPath} ${gifPath}`, (error) => {
if (error) {
console.error(`Erro ao converter para GIF: ${error.message}`)
return reply("Erro ao processar a mídia. Tente novamente.")
}
exec(`ffmpeg -i ${gifPath} -vf "scale=512:512:force_original_aspect_ratio=decrease" -lossless 1 -preset default -an -vsync 0 ${finalStickerPath}`, async (error) => {
if (error) {
console.error(`Erro ao converter para WebP: ${error.message}`)
return reply("Erro ao processar a mídia. Tente novamente.")
}
const finalStickerBuffer = fs.readFileSync(finalStickerPath)
await zerotwo.sendMessage(from, { sticker: finalStickerBuffer }, { quoted: selolucas })
fs.unlinkSync(stickerPath)
fs.unlinkSync(gifPath)
fs.unlinkSync(finalStickerPath)
if (fs.existsSync(tempDir)) {
fs.rmdirSync(tempDir, { recursive: true })
}
})
})
} catch (error) {
console.error(error)
reply("Erro ao gerar a figurinha.")
}
break

//======================================\\

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: audiolink
└─────────────────────────────────────────────────┘
*/
case 'audiolink':
try {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
//Canal: https://whatsapp.com/channel/0029Va6riekH5JLwLUFI7P2B
if ((isMedia && (info.message.videoMessage || info.message.imageMessage || info.message.audioMessage)) || (isQuotedImage || isQuotedVideo || isQuotedAudio)) {
let boij
let owgi
let res
if (isQuotedImage || (isMedia && info.message.imageMessage)) {
boij = isQuotedImage && info.message.extendedTextMessage.contextInfo?.quotedMessage ? info.message.extendedTextMessage.contextInfo.quotedMessage.imageMessage : info.message.imageMessage
if (boij) {
owgi = await getFileBuffer(boij, 'image')
const uploadRes = await axios.post(`${zerosite}/api/upload`, {
apikey: API_KEY_ZEROTWO,
media: owgi
}, {
headers: { 'Content-Type': 'multipart/form-data' }
})
if (uploadRes.data.status) {
return sendUrlText(from, uploadRes.data.resultado, `Link da imagem gerado com sucesso ↴`, '', uploadRes.data.resultado, uploadRes.data.resultado, selolucas)
} else {
reply('Erro ao gerar o link da imagem.')
}
}
}
if ((isQuotedVideo || (isMedia && info.message.videoMessage))) {
reply('Gerando link do vídeo pra você...')
boij = isQuotedVideo ? info.message.extendedTextMessage.contextInfo.quotedMessage.videoMessage : info.message.videoMessage
if (boij) {
owgi = await getFileBuffer(boij, 'video')
const uploadRes = await axios.post(`${zerosite}/api/upload`, {
apikey: API_KEY_ZEROTWO,
media: owgi
}, {
headers: { 'Content-Type': 'multipart/form-data' }
})
if (uploadRes.data.status) {
return sendUrlText(from, uploadRes.data.resultado, `Link do vídeo gerado com sucesso ↴`, '', logoslink.menu, uploadRes.data.resultado, selolucas)
} else {
reply('Erro ao gerar o link do vídeo.')
}
}
}
if ((isQuotedAudio || (isMedia && info.message.audioMessage))) {
reply('Gerando link do áudio pra você...')
boij = isQuotedAudio ? info.message.extendedTextMessage.contextInfo.quotedMessage.audioMessage : info.message.audioMessage
if (boij) {
owgi = await getFileBuffer(boij, 'audio')
const uploadRes = await axios.post(`${zerosite}/api/upload`, {
apikey: API_KEY_ZEROTWO,
media: owgi
}, {
headers: { 'Content-Type': 'multipart/form-data' }
})
if (uploadRes.data.status) {
return sendUrlText(from, uploadRes.data.resultado, `Link do áudio gerado com sucesso ↴`, '', uploadRes.data.resultado, uploadRes.data.resultado, selolucas)
} else {
reply('Erro ao gerar o link do áudio.')
}
}
}
} else {
reply("Você deve marcar uma imagem, vídeo ou áudio.")
}
} catch (error) {
console.log('Erro:', error)
reply('Ocorreu um erro ao gerar o link. Tente novamente mais tarde.')
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: azsch
└─────────────────────────────────────────────────┘
*/
case 'azsch':
if(!q) return reply("Retorne um título para ser pesquisado, ex: "+prefix+command+" livro")
try {
ABC = await fetchJson(`${zerosite}/api/amazon?nome=${encodeURI(q)}&apikey=`+API_KEY_ZEROTWO)
luquinhas = ABC.resultado[Math.floor(Math.random()*ABC.resultado.length)]
zerotwo.sendMessage(from, {image: {url: luquinhas.imagem}, caption: `${luquinhas.titulo}
» ${luquinhas.valor} «

${luquinhas.link}`}, {quoted: selolucas})
} catch(e) {
console.log(e)
reply("Não foi possível encontrar produtos com o título \""+q+"\"")
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: bardimg
└─────────────────────────────────────────────────┘
*/
case 'bardimg':
if(!isVip && !isGroup) return reply(enviar.msg.pvnotvip)
if((isMedia && !info.message.videoMessage || isQuotedImage)) {
boij = isQuotedImage ? JSON.parse(JSON.stringify(selolucas).replace('quotedM','m')).message.extendedTextMessage.contextInfo.message.imageMessage : info.message.imageMessage
owgi = await getFileBuffer(boij, 'image')
link = await upload(owgi)
ABC = await fetchJson(zerosite+`/api/ia/bardimg?q=${encodeURI(q)}&url=${link}&apikey=`+API_KEY_ZEROTWO)
reply(ABC.resultado)
} else {
reply('Marque uma imagem para eu atribuir o efeito')
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: battle
└─────────────────────────────────────────────────┘
*/
case 'battle':
setTimeout(() => {reagir(from, `${reassao}`)}, 100)
try {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
let Usuario_Op = isGroup ? info.key.participant.includes(':') ? info.key.participant.split(':')[0] + '@s.whatsapp.net' : info.key.participant : info.key.remoteJid
let opponent;
if (!q.includes('@')) {
let allPlayers = Object.keys(rpgData).filter(player => player !== Usuario_Op)
if (allPlayers.length === 0) {
return await zerotwo.sendMessage(from, 'Não há outros jogadores disponíveis para batalhar.', { quoted: selolucas })
}
opponent = allPlayers[Math.floor(Math.random() * allPlayers.length)]
} else {
opponent = menc_jid
}
const char = rpgData[Usuario_Op]
const opp = rpgData[opponent]
if (!char || !opp) {
return await zerotwo.sendMessage(from, 'Ambos os jogadores precisam ter personagens para lutar!', { quoted: selolucas })
}
const userAttack = Math.floor(Math.random() * 20) + 1 + char.attack
const oppAttack = Math.floor(Math.random() * 20) + 1 + opp.attack
char.hp -= oppAttack
opp.hp -= userAttack
char.hp = Math.max(0, char.hp)
opp.hp = Math.max(0, opp.hp)
const getProfilePictureBuffer = async (jid) => {
try {
const profilePictureUrl = await zerotwo.profilePictureUrl(jid, 'image')
const response = await axios.get(profilePictureUrl, { responseType: 'arraybuffer' })
return Buffer.from(response.data)
} catch (err) {
console.log(`Erro ao obter foto de perfil de ${jid}, usando semfoto padrão.`, err)
return semfoto
}
}
const fotorpg1Buffer = await getProfilePictureBuffer(Usuario_Op.split('@')[0] + '@c.us')
const fotorpg1 = await upload(fotorpg1Buffer)
const fotorpg2Buffer = await getProfilePictureBuffer(opponent.split('@')[0] + '@c.us')
const fotorpg2 = await upload(fotorpg2Buffer)
const battleImageUrl = `${zerosite}/api/canvas/ship?foto1=${fotorpg1}&foto2=${fotorpg2}&mat=100&fundo=https://zero-two.info/uploads/images/file-1728956656679-212957343.jpeg`
let battleResponse;
if (char.hp <= 0) {
char.hp = 100
saveData(rpgData)
battleResponse = `@${Usuario_Op.split('@')[0]} foi derrotado por @${opponent.split('@')[0]}! 😢`
} else if (opp.hp <= 0) {
opp.hp = 100
saveData(rpgData)
battleResponse = `@${Usuario_Op.split('@')[0]} venceu @${opponent.split('@')[0]}! 🎉`
} else {
saveData(rpgData)
battleResponse = `@${Usuario_Op.split('@')[0]} causou ${userAttack} de dano a @${opponent.split('@')[0]}, e @${opponent.split('@')[0]} causou ${oppAttack} de dano a @${Usuario_Op.split('@')[0]}.`
}
await zerotwo.sendMessage(from, { image: { url: battleImageUrl }, caption: battleResponse, mentions: [Usuario_Op, opponent] }, { quoted: selolucas })
} catch (e) {
console.error('Erro na batalha:', e)
await zerotwo.sendMessage(from, 'Ocorreu um erro durante a batalha. Tente novamente mais tarde.', { quoted: selolucas })
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: bigtiddies
└─────────────────────────────────────────────────┘
*/
case 'bigtiddies':
if(isGroup && !isNsfw) return reply(enviar.msg.modonsfw)
reagir(from, "🔞")
fonte = ['Internet']
gozeinonear = Math.floor(Math.random() * 1000)
let imagesnsfw = await prepareWAMessageMedia({ image: {url: `${lolhumam}/api/random/nsfw/bigtiddies?apikey=${API_KEY_LOLHUMAM}`}}, { upload: zerotwo.waUploadToServer })
await zerotwo.relayMessage(from, 
{
interactiveMessage: {
header: {
title: '',
subtitle: '',
hasMediaAttachment: true,
imageMessage: imagesnsfw.imageMessage
},
footer: {
text: '',
},
contextInfo: { participant: sender, quotedMessage: info.message, forwardingScore: 999, isForwarded: true, forwardedNewsletterMessageInfo: {newsletterJid: channel, newsletterName: `𝙲𝙾𝙽𝙽𝙴𝙲𝚃𝙴𝙳 𝙲𝙾𝙽𝚃𝙴Ú𝙳𝙾𝚂`}},
body: { text: `❯❯ ZERO TWO - NSFW ❮❮

❒ৣ͜͡Categoria: Nsfw Anime
❒ৣ͜͡Fonte: ${fonte[Math.floor(Math.random() * fonte.length)]} 
❒ৣ͜͡Coleção: Zero Two Oficial 
❒ৣ͜͡Curtidas: ${gozeinonear}
${zerosite}
`,
},nativeFlowMessage: {
buttons: [{
name: "quick_reply",
buttonParamsJson: JSON.stringify({
display_text: "ꪶ͢PROXIMA͢ꫂ",
id: `${prefix}bigtiddies`
}),},
],
messageParamsJson:"",
},
},
},
{}
).then((r) => console.log(r))
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: blacklink
└─────────────────────────────────────────────────┘
*/
case 'blacklink':
reagir(from, "🌐")
sendUrlText(from,
`*Site oficial do black:*🍧.ᩦ୭✧ࣶᭂ\n\n`+blacksite,
`🔎 ${NomeDoBot} 🔍`,
`Um site para Dev's e programadores de bot`,
logoslink.menu,
zerosite,
selolucas)
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: blackpink2
└─────────────────────────────────────────────────┘
*/
case 'blackpink2':
//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
//Canal: https://whatsapp.com/channel/0029Va6riekH5JLwLUFI7P2B
textin = args.join(" ")
if(!textin) return reply("KD o texto ?")
reply(`ৎ❥̤֟٭ۣۜ𝙶𝚎𝚛𝚊𝚗𝚍𝚘 𝚂𝚞𝚊 𝙻𝚘𝚐𝚘🍧.ᩦ୭✧ࣶᭂ`)
bla = await fetchJson(`${zerosite}/api/blackpink?texto=${textin}&apikey=`+API_KEY_ZEROTWO)
blabla = await getBuffer(bla.resultado.imageUrl)
zerotwo.sendMessage(from, {image: blabla}, {quoted: selolucas}).catch(e =>{
reply("Erro ao criar sua logo! Tente novamente mais tarde.")
})
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: blk5
└─────────────────────────────────────────────────┘
*/
case 'blk5':
if(!isOwner) return
zerotwo.relayMessage(
from,
{
interactiveMessage: {
headerType: `IMAGE`,
body: {text: `Opa mn @${sender.split("@")[0]}`},
footer: {text: "@lucas_mod_domina"},
contextInfo: {participant: sender, mentionedJid: [sender], quotedMessage: info.message},
nativeFlowMessage: {
buttons: [{
name: "cta_url",
buttonParamsJson: JSON.stringify({
display_text: "Site da Zero Two",
url: `${zerosite}`,
merchant_url: `${zerosite}`
}),
},
{
name: "cta_copy",
buttonParamsJson: JSON.stringify({
display_text: "Copie Minha Bucetinha",
copy_code: "https://xvideos.com.br"
}),
},
{
name: "quick_reply",
buttonParamsJson: JSON.stringify({
display_text: "PLAY",
id: `${prefix}play`,
disabled: false
}),
},
{
name: "quick_reply",
buttonParamsJson: JSON.stringify({
display_text: "PING",
id: `${prefix}ping`,
disabled: false
}),
}],
messageParamsJson: "",
},
},
},
{}
)
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: book
└─────────────────────────────────────────────────┘
*/
case 'book':
if(!q) return reply("KD o nome do livro?")
try {
ABC = await fetchJson(`${zerosite}/api/book?livro=${encodeURI(q)}&apiKey=`+API_KEY_ZEROTWO)
i = ABC.resultado[0].volumeInfo
sendUrlText(from, i.description, `📖 LIVRO - `+i.title, i.subtitle || ``,
zerosite+`/api/convert/image?url=${i.imageLinks.thumbnail}&apikey=`+API_KEY_ZEROTWO,
zerosite, selolucas)
} catch(e) {
console.log(e)
reply("Erro")
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: botversion
└─────────────────────────────────────────────────┘
*/
case 'botversion':
botv = JSON.parse(fs.readFileSync(`./package.json`)).version
sendRouletteButton(from, {image: {url: links.logocapa3}, caption: `💖 Versão atual da bot - ${botv}`, footer: `New Zero Two Beta Oficial Update\nApi - ${zerosite}`}, zerotwo, sender, [{type: `copy_url`, text: NomeDoBot, url: `https://github.com/Otakump4`}], selolucas)
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: brasileirao
└─────────────────────────────────────────────────┘
*/
case 'brasileirao':
if(!isGroup) return reply(enviar.msg.grupo)
try {
ABC = await fetchJson(`${zerosite}/api/brasileirao?apikey=`+API_KEY_ZEROTWO)
txt = `_🇧🇷❒ 𝚃𝚊𝚋𝚎𝚕𝚊 𝙳𝚘 𝙱𝚛𝚊𝚜𝚒𝚕𝚎𝚒𝚛ã𝚘 𝙰𝚝𝚞𝚊𝚕𝚒𝚣𝚊𝚍𝚊 ↴_`
for( i of ABC.resultado ) {
txt += `\nৎ❥̤֟٭ۣۜ𝚃𝚒𝚖𝚎: ${i.equipe}
ৎ❥̤֟٭ۣۜ𝙿𝚘𝚗𝚝𝚘𝚜: ${i.pontos}
ৎ❥̤֟٭ۣۜ𝙹𝚘𝚐𝚘𝚜: ${i.jogosJogados}\n`
}
reply(txt)
} catch {
reply("Erro")
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: capcutmodel
└─────────────────────────────────────────────────┘
*/
case 'capcutmodel':
if (!q) return reply('Por favor, adicione um link de um modelo do CapCut.')
reagir(from, "😼")
try {
const data = await fetchJson(`${zerosite}/api/dl/capcut?url=${q}&apikey=${API_KEY_ZEROTWO}`)
if (!data.status) return reply('Ocorreu um erro ao processar o link fornecido.')
const videoBuffer = await getBuffer(data.resultado.video)
zerotwo.sendMessage(from, { video: videoBuffer, caption: `• *Título:* ${data.resultado.titulo}\n` + `• *Descrição:* ${data.resultado.descricao}\n` + `• *Visualizações:* ${data.resultado.visualizacoes}`, contextInfo: { mentionedJid: [sender], externalAdReply: { showAdAttribution: true, mediaType: 'VIDEO', mediaUrl: data.resultado.video, title: `Título: ${data.resultado.titulo}`, body: `Descrição: ${data.resultado.descricao}\n` +
`Visualizações: ${data.resultado.visualizacoes}`, sourceUrl: data.resultado.video, thumbnail: await getBuffer(data.resultado.miniatura)}}}, { quoted: zero })
} catch (e) {
console.log(e)
return reply("Erro ao processar a solicitação.")
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: casal
└─────────────────────────────────────────────────┘
*/
case 'casal':
setTimeout(() => { reagir(from, "😍") }, 300)
if (!isGroup) return reply(enviar.msg.grupo)
if (!isModobn) return reply(`Este tipo de comando só pode ser utilizado com o modobrincadeira ativo, fale com um adm ou se você for um, apenas digite ${prefix}modobrincadeira`)
try {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
async function obterFotoPerfil(userId) {
try {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
console.log(`Obtendo foto de perfil para: ${userId}`)
const profilePicUrl = await zerotwo.profilePictureUrl(`${userId}@c.us`, 'image')
const response = await axios.get(profilePicUrl, {
responseType: 'arraybuffer',
headers: {
'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3'
}
})
if (response.status === 200) {
console.log(`Foto de perfil obtida com sucesso para: ${userId}`)
const buffer = Buffer.from(response.data, 'binary')
return await uploadToCloudinary(buffer)
} else {
throw new Error(`Erro ao obter a imagem: ${response.status}`)
}
} catch (e) {
if (e.response && e.response.data) {
console.log(`Erro ao obter a foto de perfil para ${userId}:`, e.response.data)
} else {
console.log(`Erro ao obter a foto de perfil para ${userId}:`, e.message)
}
return semfoto
}
}
const usu1 = groupMembers[Math.floor(Math.random() * groupMembers.length)].id.split('@')[0]
const usu2 = groupMembers[Math.floor(Math.random() * groupMembers.length)].id.split('@')[0]
const foto1 = await obterFotoPerfil(usu1)
const foto2 = await obterFotoPerfil(usu2)
const mat = Math.floor(Math.random() * 100)
const txt = `*Hmmm.... Eu Shipo eles 2💘💘*\n1= @${usu1}\ne esse\n2= @${usu2}\ncom uma porcentagem de: ${mat}%`
mencionarIMG(txt, `${zerosite}/api/canvas/ship?foto1=${foto1}&foto2=${foto2}&mat=${mat}&fundo=https://telegra.ph/file/5074a25f281d46c10db04.jpg`)
} catch (e) {
console.log("Erro no comando 'casal':", e)
reply("Erro ao processar o comando.")
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: comprar-key
└─────────────────────────────────────────────────┘
*/
case 'comprar-key':
if(!q.includes("|")) return reply(`Retone após o comando a key e a quantidade de request, exemplo:
${prefix+command} zerotwokey|5000
_(lembre-se tbm que cada 1000 requests custa 1$)_`)
barra = q.replace(" |", "|").replace("| ", "|").replace(" | ", "|")
var [a, b] = barra.split("|")
if(a.toLowerCase() === "zerokey") return reply(`Bucetudo, isso é só um exemplo... Escolhe outro nome pra botar na tua key`)
buy = [{valor: 1, rq: 1000},
{valor: 2, rq: 2000},
{valor: 3, rq: 3000},
{valor: 4, rq: 4000},
{valor: 5, rq: 5000},
{valor: 6, rq: 6000},
{valor: 7, rq: 7000},
{valor: 8, rq: 8000},
{valor: 9, rq: 9000},
{valor: 10, rq: 10000},
{valor: 15, rq: 15000},
{valor: 25, rq: 25000},
{valor: 45, rq: null}]
if(Number(b) < 1 || Number(b) > buy.length) {
valores = []
for(i of buy) {valores.push({title: `Apikey ${i.rq > 0 ? `com ${i.rq / 1000} mil` : `infinitos`} requests 🔑`, description: `R$ ${(i.valor).toFixed(2)}`, id: prefix+command+` ${a}|${buy.map(x => x.rq).indexOf(i.rq) + 1}`, disabled: false})}
return zerotwo.relayMessage(from, {
interactiveMessage: {
body: {text: `Agora vamos escolher o valor a ser pago...`},
footer: {text: `Selecione abaixo a quantidade de requests na qual você deseja, para finalizar a compra ↴`},
contextInfo: {
participant: sender,
quotedMessage: info.message
},
nativeFlowMessage: {
buttons: [
{
name: "single_select",
buttonParamsJson: JSON.stringify({
title: `〘 𝗦𝗘𝗟𝗘𝗖𝗜𝗢𝗡𝗘 𝗔𝗤𝗨𝗜 〙`,
sections: [
{
title: `luquinhas t'mama`,
rows: valores
}
]
})
}
], messageParamsJson: ""
}
}
}, {})
}
valor = buy[Number(b) - 1].valor
rq = buy[Number(b) - 1].rq
rp = rq > 0 ? rq : `"INFINITO's ∞"`
AB = moedas.map(i => i.id).indexOf(sender)
if(moedas[AB].saldo < valor) return reply(`${rp} requests custarão R$ ${(valor).toFixed(2)}... Porém, vejo que seu saldo está abaixo disso 😕`)
try {
const response = await fetch(`${zerosite}/dono/puxar-senha`)
if (!response.ok) {
throw new Error(`Erro na resposta da API: ${response.statusText}`)
}
const data = await response.json()
if (!data.senha) {
throw new Error('Resposta da API não contém a senha')
}
const senha = data.senha
const ABC = await fetchJson(`${zerosite}/dono/adc-key?apikey=${encodeURIComponent(a)}&request=${rq}&senha=${senha}`)
moedas[AB].saldo -= valor
saveCoins()
if(isGroup) zerotwo.sendMessage(from, {delete: {remoteJid: from, fromMe: false, id: info.key.id, participant: sender}})
await sleep(1000)
rgkey(sender, a, rq)
zerotwo.relayMessage(sender, {
interactiveMessage: {
header: {
hasMediaAttachment: true,
imageMessage: links.logocapa3
}, headerType: `IMAGE`,
body: {text: `💖 _key gerada com sucesso_ 💖\n\n🔑 *Key:* ${a}\n📟 *Requests:* ${rp}`},
footer: {text: NomeDoBot},
contextInfo: {
participant: sender,
quotedMessage: info.message
},
nativeFlowMessage: {
buttons: [
{
name: "cta_copy",
buttonParamsJson: JSON.stringify({
display_text: `SUA KEY AQ`,
copy_code: a
})
}
], messageParamsJson: ""
}
}
}, {})
} catch(e) {
console.log(e)
return reply("Erro, chame meu dono.") }
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: cpfba
└─────────────────────────────────────────────────┘
*/
case 'cpfba':
if (!isChatOfc && !isAdvencedVip(sender) && !isAdvencedGroupVip(from)) return reply(enviar.msg.vip)
if (!q) return reply(`Cade o CPF da pessoa?`)
if (q.length !== 11) return reply(`🌸 Insira um CPF com 11 números 🌸`)
reply(`Espere 5s até o resultado..`)
try {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
let LucasMods = await fetch(`${zerosite}/vip/consultas?type=fotoba&query=${q}&apikey=`+API_KEY_ZEROTWO)
let Lucas = LucasMods.headers.get('content-type')
if (!Lucas || !Lucas.includes('application/json')) {
return reply(`Erro na API, formato inesperado`)
}
let lindeza = await LucasMods.json()
if (!lindeza.status) {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
console.log('Deu esse erro pae:', lindeza)
return reply(`vish pae`)
}
let response = await fetch(`${zerosite}/vip/consultas?type=cpf&query=${q}&apikey=`+API_KEY_ZEROTWO)
let contentType = response.headers.get('content-type')
if (!contentType || !contentType.includes('application/json')) {
return reply(`Erro na segunda API, formato inesperado`)
}
let dados = await response.json()
if (!dados.status) {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
console.log('Erro ao consultar a segunda API:', dados)
return reply(`Erro na segunda API.`)
}
let { cpf, foto, rg, mae, pai, nascimento } = lindeza.resultado
let caption = `*INFORMAÇÕES*:\n*RG*: ${rg}\n*MÃE*: ${mae}\n*PAI*: ${pai}\n*NASCIMENTO*: ${nascimento}\n\n` + dados.resultado
let buffer = Buffer.from(foto, 'base64')
zerotwo.sendMessage(from, { image: buffer, caption: caption }, {quoted: selolucas}).catch(e => {
console.log('Deu esse erro com a img pae:', e)
reply(`Deu erro pae nem insista.`)
})
} catch (e) {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
console.log('Deu esse erro ao consultar pae:', e)
reply(`Deu erro nessa merda`)
}
break

/*

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: cpfce
└─────────────────────────────────────────────────┘
*/
case 'cpfce':
if (!isChatOfc && !isAdvencedVip(sender) && !isAdvencedGroupVip(from)) return reply(enviar.msg.vip)
if (!q) return reply(`Cadê o CPF da pessoa?`)
if (q.length !== 11) return reply(`🌸 Insira um CPF com 11 números 🌸`)
reply(`Espere 5s até o resultado..`)
try {
let LucasMods = await fetch(`${zerosite}/vip/consultas?type=fotoce&query=${q}&apikey=` + API_KEY_ZEROTWO)
if (!LucasMods.ok) {
console.log('Erro ao consultar a primeira API, status:', LucasMods.status)
return reply(`Erro ao consultar a primeira API.`)
}
let Lucas = LucasMods.headers.get('content-type')
if (!Lucas || !Lucas.includes('application/json')) {
console.log('Erro na primeira API, formato inesperado, content-type:', Lucas)
return reply(`Erro na API, formato inesperado`)
}
let lindeza = await LucasMods.json()
if (!lindeza.status) {
try {
console.log('Erro na primeira consulta da API, detalhes do erro:', lindeza)
return reply(`vish pae`)
} catch (e) {
console.log('Erro capturado no bloco de falha da primeira consulta:', e)
reply(`Deu erro ao tentar processar a resposta da API.`)
}
}
let response = await fetch(`${zerosite}/vip/consultas?type=cpf&query=${q}&apikey=` + API_KEY_ZEROTWO)
if (!response.ok) {
console.log('Erro ao consultar a segunda API, status:', response.status)
return reply(`Erro ao consultar a segunda API.`)
}
let contentType = response.headers.get('content-type')
if (!contentType || !contentType.includes('application/json')) {
console.log('Erro na segunda API, formato inesperado, content-type:', contentType)
return reply(`Erro na segunda API, formato inesperado`)
}
let dados = await response.json()
if (!dados.status) {
try {
console.log('Erro ao consultar a segunda API, detalhes do erro:', dados)
return reply(`Erro na segunda API.`)
} catch (e) {
console.log('Erro capturado no bloco de falha da segunda consulta:', e)
reply(`Deu erro ao tentar processar a resposta da segunda API.`)
}
}
let { cpf, foto } = lindeza.resultado
let caption = dados.resultado
let buffer = Buffer.from(foto, 'base64')
await zerotwo.sendMessage(from, { image: buffer, caption: caption }, { quoted: selolucas })
.catch(e => {
console.log('Erro ao enviar a imagem:', e)
return reply(`Deu erro pae nem insista.`)
})
} catch (e) {
console.log('Erro geral no processamento do comando cpfce:', e)
return reply(`Deu erro nessa merda.`)
}
break

/*

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: cpfto
└─────────────────────────────────────────────────┘
*/
case 'cpfto':
if (!isChatOfc && !isAdvencedVip(sender) && !isAdvencedGroupVip(from)) return reply(enviar.msg.vip)
if (!q) return reply(`Cade o CPF da pessoa?`)
if (q.length !== 11) return reply(`🌸 Insira um CPF com 11 números 🌸`)
reply(`Espere 5s até o resultado..`)
try {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
let LucasMods = await fetch(`${zerosite}/vip/consultas?type=fototo&query=${q}&apikey=`+API_KEY_ZEROTWO)
let Lucas = LucasMods.headers.get('content-type')
if (!Lucas || !Lucas.includes('application/json')) {
return reply(`Erro na API, formato inesperado`)
}
let lindeza = await LucasMods.json()
if (!lindeza.status) {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
console.log('Deu esse erro pae:', lindeza)
return reply(`vish pae`)
}
let response = await fetch(`${zerosite}/vip/consultas?type=cpf&query=${q}&apikey=`+API_KEY_ZEROTWO)
let contentType = response.headers.get('content-type')
if (!contentType || !contentType.includes('application/json')) {
return reply(`Erro na segunda API, formato inesperado`)
}
let dados = await response.json()
if (!dados.status) {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
console.log('Erro ao consultar a segunda API:', dados)
return reply(`Erro na segunda API.`)
}
let { cpf, foto } = lindeza.resultado
let caption = dados.resultado
let buffer = Buffer.from(foto, 'base64')
zerotwo.sendMessage(from, { image: buffer, caption: caption }, {quoted: selolucas}).catch(e => {
console.log('Deu esse erro com a img pae:', e)
reply(`Deu erro pae nem insista.`)
})
} catch (e) {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
console.log('Deu esse erro ao consultar pae:', e)
reply(`Deu erro nessa merda`)
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: criador
└─────────────────────────────────────────────────┘
*/
case 'criador':
reagir(from, "🙂‍↔️")
{
audio_criador = "https://a.top4top.io/m_3023ahgcp2.mp3"
await zerotwo.sendMessage(from, {audio: {url: audio_criador }, mimetype: 'audio/mp4', ptt:true}, {quoted: selolucas})
ttgp = isGroup ? groupMembers.length * groupAdmins.length + somembros.length : 6
horar = moment.tz('America/Sao_Paulo').format('HH:mm')
datar = moment.tz('America/Sao_Paulo').format('DD/MM')
let vcard = `BEGIN:VCARD\nVERSION:3.0\nN:;𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄;;;\nFN:𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄\nX-WA-BIZ-NAME:𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄\nX-WA-BIZ-DESCRIPTION:Pix: 94991569380\nX-WA-BIZ-AUTOMATED-TYPE:3p_full\nORG:ORG: CRIADOR OFICIAL DA ZERO TWO;\nTEL;type=CELL;type=VOICE;waid=559491569380:+55 94 9156-9380\nEND:VCARD`
await zerotwo.sendMessage(from, { contacts: { displayName: '𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄 ', contacts: [{vcard}]}
})
reply(`> 🌟 *O contato dele, caso você precise de ajuda:* [Clique aqui]\n(https://wa.me/559491569380)\n\n> 🎥 *Inscreva-se no meu canal para não perder nenhuma novidade:* [Clique aqui]\n(https://youtube.com/@Otaku.mp4)\n\n> 🌐 *Minha API:* ${zerosite}\n\n> 🌐 *Meu site:* https://linktr.ee/LucasMod`)
criador = `🌸 *Ah, o meu criador? 𝑙𝑢𝑐𝑎𝑠_𝑚𝑜𝑑_𝑑𝑜𝑚𝑖𝑛𝑎, o nome da lenda...* 🌟
*✨ Ele foi o gênio por trás de todo esse sistema incrível que você está usando! ✨* 🍓`
await sendUrlDoc(from, criador, 'application/pdf', `${horar}H ┋ ${datar} 📆`, ttgp, NomeDoBot, ``, `https://telegra.ph/file/bafb1c69d7761d22e04ad.jpg`, `https://wa.me/559491569380`, selolucas)
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: criar-email
└─────────────────────────────────────────────────┘
*/
case 'criar-email':
if (!isChatOfc && !isAdvencedVip(sender) && !isAdvencedGroupVip(from)) return reply(enviar.msg.vip)
try {
ABC = await fetchJson(zerosite+`/api/tempmail/criar-email?apikey=`+API_KEY_ZEROTWO)
reply(`*✉️ Email temporário gerado com sucesso:*`)
await sleep(700)
sendMess(from, ABC.resultado)
} catch(e) { console.log(e)
reply(`Erro`) }
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: criardescricao
└─────────────────────────────────────────────────┘
*/
case 'criardescricao':
setTimeout(() => { reagir(from, react2) }, 300)
media = isMedia && (info.message.imageMessage || info.message.videoMessage)
quotedImage = isQuotedImage && info.message.extendedTextMessage.contextInfo.quotedMessage.imageMessage
if (media || quotedImage) {
try {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
const mediaToProcess = media ? info.message.imageMessage : quotedImage
console.log("🟢 Iniciando o processo de descrição da imagem")
console.log("🔵 Baixando e descriptografando a imagem...")
const stream = await downloadContentFromMessage(mediaToProcess, 'image')
let buffer = Buffer.from([])
for await (const chunk of stream) {
buffer = Buffer.concat([buffer, chunk])
}
console.log("🟢 Imagem baixada com sucesso. Tamanho do buffer: ", buffer.length)
const imageBase64 = buffer.toString('base64')
let prompt = 'Crie uma legenda divertida para esta imagem.'
if (args.length > 0) {
prompt = args.join(' ')
}
const url = 'https://image-description.p.rapidapi.com/ImageDescriptor';
const options = {
method: 'POST',
headers: {
'x-rapidapi-key': '5f91695c4emsh176b64963af605ap172104jsnb6345733c136',
'x-rapidapi-host': 'image-description.p.rapidapi.com',
'Content-Type': 'application/json'
},
body: JSON.stringify({
image: imageBase64,
prompt: prompt
})
}
console.log(`🟢 Enviando a imagem para a API com o prompt: "${prompt}"`)
const response = await fetch(url, options)
const result = await response.json()
console.log("🟢 Resposta da API recebida: ", result)
if (result && result.prompt) {
const respostaGemini = result.prompt || 'Descrição não encontrada.'
console.log("🟢 Descrição gerada com sucesso: ", respostaGemini)
const translateUrl = `${zerosite}/api/info/translate?texto=${encodeURIComponent(respostaGemini)}&ling=pt&apikey=${API_KEY_ZEROTWO}`
console.log("🟢 Traduzindo a descrição para PT...")
const traducao = await fetchJson(translateUrl)
if (traducao && traducao.resultado) {
const descricaoTraduzida = traducao.resultado || 'Erro na tradução.'
console.log("🟢 Tradução recebida com sucesso: ", descricaoTraduzida)
await sendImage(from, buffer, descricaoTraduzida)
} else {
console.log("❌ Erro na tradução: ", traducao)
reply(`❌ Erro ao traduzir a descrição da imagem: ${traducao.error || 'Erro desconhecido.'}`)
}
} else {
console.log("❌ Erro na resposta da API de descrição: ", result)
reply(`❌ Erro ao gerar a descrição da imagem: ${result.error || 'Erro desconhecido.'}`)
}
} catch (error) {
console.log("❌ Erro ao descrever a imagem:", error)
reply("❌ Ocorreu um erro ao descrever a imagem.")
}
} else {
reply("❌ Por favor, envie ou mencione uma imagem.")
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: d
└─────────────────────────────────────────────────┘
*/
case 'd': return timeValue * 60 * 60 * 24
default: throw new Error("Unidade de tempo inválida.")
}
}
async function getUserDisplayName(sender, pushname) {
console.log(chalk.blue(`🧑 Obtendo nome de exibição para o usuário: ${sender}`))
return pushname || 'Usuário'
}
function checkRegisteredGroups(mediaSettings) {
const groups = Object.keys(mediaSettings)
if (groups.length === 0) {
console.log(chalk.yellow("⚠️ Nenhum grupo registrado encontrado. O sistema está inativo."))
return false
}
console.log(chalk.green(`✅ Grupos registrados encontrados: ${groups.join(', ')}`))
return true
}
async function handleMediaControl(info, pushname, zerotwo, groupIds) {
console.log(chalk.blue(`🔍 Iniciando controle de mídia para o grupo: ${groupIds}`))
const { messageType, mediaType } = detectMediaType(info.message)
console.log(chalk.blue(`🖼️ Tipo de mídia detectado: ${messageType}, Tipo de conteúdo: ${mediaType ? mediaType : "Nenhum"}`))
let mediaSettings = loadMediaData()
if (!mediaSettings[groupIds]) {
mediaSettings[groupIds] = {
groupName: groupName, 
groupId: groupIds, 
users: {}, 
tempoLimite: 2
}
console.log(chalk.green(`✅ Grupo ${groupIds} adicionado às configurações.`))
}
if (!checkRegisteredGroups(mediaSettings)) {
return
}
const groupSettings = mediaSettings[groupIds]
if (groupSettings.tempoLimite) {
console.log(chalk.green(`🔄 Tempo limite de mídia: ${groupSettings.tempoLimite}`))
} else {
console.log(chalk.yellow(`⚠️ Tempo limite de mídia não definido para o grupo ${groupIds}.`))
}
const participantId = info.key.participant
const userId = participantId || info.key.remoteJid
if (!groupSettings.users[userId]) {
groupSettings.users[userId] = {
nome: await getUserDisplayName(userId, pushname),
id: userId,
ultimaMidia: null,
tempoLimite: null,
}
console.log(chalk.green(`✅ Usuário ${groupSettings.users[userId].nome} registrado.`))
}
const userMedia = groupSettings.users[userId]
if (userMedia.tempoLimite && Date.now() < new Date(userMedia.tempoLimite).getTime()) {
console.log(chalk.yellow(`⚠️ Usuário ${userMedia.nome} tentou enviar mídia, mas está fora do limite de tempo.`))
await zerotwo.sendMessage(from, { text: `❌ Você não pode enviar mídia agora. Por favor, aguarde o tempo limite.` }, { quoted: selolucas })
return
}
userMedia.ultimaMidia = new Date()
userMedia.tempoLimite = new Date(Date.now() + (groupSettings.tempoLimite * 1000))
console.log(chalk.green(`✅ Usuário ${userMedia.nome} enviou mídia: ${mediaType}`))
saveMediaData(mediaSettings)
await zerotwo.sendMessage(from, { text: `✅ Mídia recebida com sucesso, ${userMedia.nome}. Você pode enviar novamente em ${groupSettings.tempoLimite / 1000} segundos.` }, { quoted: selolucas })
}

zerotwo.ev.on('messages.upsert', async (selolucas) => {
await handleMediaControl(info, pushname, zerotwo, groupIds)
})

(async () => {
console.log(chalk.blue("🔄 Iniciando o sistema de controle de mídia..."))
const mediaSettings = loadMediaData()
console.log(chalk.green("✅ Sistema de controle de mídia iniciado com sucesso."))
})()
*/

// SISTEMA RPG CRIADO POR 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
let Usuario_Op = isGroup ? info.key.participant.includes(':') ? info.key.participant.split(':')[0] +'@s.whatsapp.net': info.key.participant : info.key.remoteJid
let opponent = isGroup ? info.key.participant.includes(':') ? info.key.participant.split(':')[0] +'@s.whatsapp.net': info.key.participant : info.key.remoteJid
const mentionUser = (userId) => {
return userId.replace('@s.whatsapp.net', '')
}
function loadData() {
try {
if (!fs.existsSync('./funções_rpg/rpg_data.json')) {
fs.writeFileSync('./funções_rpg/rpg_data.json', JSON.stringify({}))
return {}
}
return JSON.parse(fs.readFileSync('./funções_rpg/rpg_data.json'))
} catch (error) {
console.error("Erro ao carregar os dados:", error)
return {}
}
}
function saveData(data) {
try {
const existingData = loadData()
const updatedData = { ...existingData, ...data }
fs.writeFileSync('./funções_rpg/rpg_data.json', JSON.stringify(updatedData, null, 2))
} catch (error) {
console.error("Erro ao salvar os dados:", error)
}
}
function formatDateTime(date) {
const formattedDate = date.toLocaleDateString('pt-BR', { day: 'numeric', month: 'long', year: 'numeric' })
const options = { hour: 'numeric', minute: 'numeric', hour12: false }
const formattedTime = date.toLocaleTimeString('pt-BR', options)
return `${formattedDate} | ${formattedTime} AM`
}
const rpgData = loadData()
function getRandomOpponent() {
const players = Object.keys(rpgData)
if (players.length === 0) {
return null
}
const randomIndex = Math.floor(Math.random() * players.length)
return players[randomIndex]
}
const shopItems = [
{ name: 'Espada de Aço', type: 'weapon', price: 100, bonus: { attack: 10 } },
{ name: 'Escudo de Ferro', type: 'armor', price: 80, bonus: { defense: 8 } },
{ name: 'Poção de Vida', type: 'consumable', price: 20, bonus: { hp: 30 } },
{ name: 'Elmo de Bronze', type: 'helmet', price: 50, bonus: { defense: 5 } },
{ name: 'Anel da Força', type: 'accessory', price: 200, bonus: { attack: 15 } },
{ name: 'Botas de Velocidade', type: 'boots', price: 70, bonus: { defense: 2, speed: 5 } }
]
function createCharacter(Usuario_Op) {
if (!Usuario_Op) return 'Usuário inválido!'
if (!rpgData[Usuario_Op]) {
rpgData[Usuario_Op] = {
level: 1,
exp: 0,
hp: 100,
energy: 100,
gold: 0,
attack: 10,
defense: 5,
items: [],
equipped: null,
clan: null,
dailyMissions: { completed: false, lastCompletion: null }
}
saveData(rpgData)
return `Personagem criado para @${mentionUser(Usuario_Op)} com sucesso!`
} else {
return `Você já possui um personagem, @${mentionUser(Usuario_Op)}!`
}
}
function showStatus(Usuario_Op) {
const char = rpgData[Usuario_Op]
if (char) {
return `
👤 *Status de @${mentionUser(Usuario_Op)}*:\n
🏅 Nível: ${char.level}\n
❤️ HP: ${char.hp}\n
⚡ Energia: ${char.energy}\n
💰 Ouro: ${char.gold}\n
⚔️ Ataque: ${char.attack}\n
🛡️ Defesa: ${char.defense}\n
🎒 Itens: ${char.items.length > 0 ? char.items.map(item => item.name).join(', ') : 'Nenhum'}\n
⚔️ Equipado: ${char.equipped ? char.equipped.name : 'Nenhum'}\n
👥 Clã: ${char.clan ? char.clan : 'Nenhum'}\n
🎯 Missão Diária: ${char.dailyMissions.completed}\n
🗓️ Última Conclusão: ${char.dailyMissions.lastCompletion}`
} else {
return `@${mentionUser(Usuario_Op)}, você ainda não criou um personagem! Use ${prefix}create para começar.`
}
}
function levelUp(Usuario_Op) {
const char = rpgData[Usuario_Op]
const expToLevelUp = char.level * 100
if (char.exp >= expToLevelUp) {
char.level++
char.exp -= expToLevelUp
char.hp += 50
saveData(rpgData)
return `Parabéns @${mentionUser(Usuario_Op)}, você subiu para o nível ${char.level}! Seu HP aumentou para ${char.hp}!`
}
return null
}
async function battle(Usuario_Op, opponent) {
const char = rpgData[Usuario_Op]
const opp = rpgData[opponent]
if (!char || !opp) return `Ambos os jogadores precisam ter personagens para lutar!`
const userAttack = Math.floor(Math.random() * 20) + 1 + char.attack
const oppAttack = Math.floor(Math.random() * 20) + 1 + opp.attack
char.hp -= oppAttack
opp.hp -= userAttack
char.hp = Math.max(0, char.hp)
opp.hp = Math.max(0, opp.hp)
opponent2 = q.includes("@") ? menc_jid : sender
try {
fotorpg1 = await zerotwo.profilePictureUrl(`${Usuario_Op('@')[0]}@c.us`, 'image')
} catch {
fotorpg1 = semfoto
}
try {
fotorpg2 = await zerotwo.profilePictureUrl(`${opponent2('@')[0]}@c.us`, 'image')
} catch {
fotorpg2 = semfoto
}
const battleImageUrl = `${zerosite}/api/canvas/ship?foto1=${fotorpg1}&foto2=${fotorpg2}&mat=100&fundo=https://zero-two.info/uploads/images/file-1728956656679-212957343.jpeg`
let battleResponse
if (char.hp <= 0) {
char.hp = 100
saveData(rpgData)
battleResponse = `@${mentionUser(Usuario_Op)} foi derrotado por @${mentionUser(opponent)}! 😢`
} else if (opp.hp <= 0) {
opp.hp = 100
saveData(rpgData)
battleResponse = `@${mentionUser(Usuario_Op)} venceu @${mentionUser(opponent)}! 🎉`
} else {
saveData(rpgData)
battleResponse = `@${mentionUser(Usuario_Op)} causou ${userAttack} de dano a @${mentionUser(opponent)}, e @${mentionUser(opponent)} causou ${oppAttack} de dano a @${mentionUser(Usuario_Op)}.`
}
return { battleResponse, battleImageUrl }
}
function showShop() {
let message = '🏪 *Loja de Itens*:\n'
shopItems.forEach((item, index) => {
message += `${index + 1}. ${item.name} (${item.type}) - 💰 ${item.price} - Bônus: ${JSON.stringify(item.bonus)}\n`
})
message += `\nUse ${prefix}buy <número do item> para comprar.`
return message
}
function buyItem(Usuario_Op, itemIndex) {
const char = rpgData[Usuario_Op]
if (!char) return `Você precisa criar um personagem primeiro, @${mentionUser(Usuario_Op)}!`
const item = shopItems[itemIndex - 1]
if (!item) return `Item inválido. Verifique o número do item.`
if (char.gold < item.price) return `Você não tem ouro suficiente para comprar ${item.name}, @${mentionUser(Usuario_Op)}!`
char.gold -= item.price
char.items.push(item)
saveData(rpgData)
return `@${mentionUser(Usuario_Op)}, você comprou ${item.name} por 💰 ${item.price}.`
}
function equipItem(Usuario_Op, itemName) {
const char = rpgData[Usuario_Op]
if (!char) return `Crie um personagem primeiro, @${mentionUser(Usuario_Op)}!`
const item = char.items.find(i => i.name.toLowerCase() === itemName.toLowerCase())
if (!item) return `Você não possui esse item, @${mentionUser(Usuario_Op)}!`
if (char.equipped && char.equipped.name === item.name) {
return `@${mentionUser(Usuario_Op)}, você já está usando ${item.name}.`
}
char.equipped = item
saveData(rpgData)
return `@${mentionUser(Usuario_Op)}, você equipou ${item.name}.`
}
function startDailyMission(Usuario_Op) {
const char = rpgData[Usuario_Op]
if (!char) return `Crie um personagem primeiro, @${mentionUser(Usuario_Op)}!`
const today = new Date().toDateString()
const lastCompletionDate = char.dailyMissions.lastCompletion ? new Date(char.dailyMissions.lastCompletion).toDateString() : null
if (lastCompletionDate === today) {
return `@${mentionUser(Usuario_Op)}, você já completou sua missão diária hoje. Volte amanhã!`
}
const missionReward = Math.floor(Math.random() * 100) + 50
char.gold += missionReward
char.dailyMissions.completed = true
char.dailyMissions.lastCompletion = formatDateTime(new Date())
saveData(rpgData)
return `@${mentionUser(Usuario_Op)}, você completou a missão diária e ganhou ${missionReward} ouro!`
}
function createClan(Usuario_Op, clanName) {
const char = rpgData[Usuario_Op]
if (!char) return `Crie um personagem primeiro, @${mentionUser(Usuario_Op)}!`
if (char.clan) return `@${mentionUser(Usuario_Op)}, você já pertence a um clã: ${char.clan}.`
char.clan = clanName
saveData(rpgData)
return `@${mentionUser(Usuario_Op)}, você criou o clã "${clanName}"!`
}
function joinClan(Usuario_Op, clanName) {
const char = rpgData[Usuario_Op]
if (!char) return `Crie um personagem primeiro, @${mentionUser(Usuario_Op)}!`
if (char.clan) return `@${mentionUser(Usuario_Op)}, você já pertence a um clã: ${char.clan}.`
char.clan = clanName
saveData(rpgData)
return `@${mentionUser(Usuario_Op)}, você entrou no clã "${clanName}"!`
}
function leaveClan(Usuario_Op) {
const char = rpgData[Usuario_Op]
if (!char) return `Crie um personagem primeiro, @${mentionUser(Usuario_Op)}!`
if (!char.clan) return `@${mentionUser(Usuario_Op)}, você não pertence a nenhum clã!`
const clanName = char.clan
char.clan = null
saveData(rpgData)
return `@${mentionUser(Usuario_Op)}, você saiu do clã "${clanName}".`
}
function randomEvent(Usuario_Op) {
const char = rpgData[Usuario_Op]
if (!char) return ''
const events = [
{ message: 'Você encontrou um baú cheio de ouro!', bonus: { gold: 50 } },
{ message: 'Você foi atacado por bandidos e perdeu ouro!', penalty: { gold: 30 } },
{ message: 'Você descansou em um oásis e recuperou energia.', bonus: { energy: 10 } },
{ message: 'Um comerciante lhe deu uma poção de cura!', bonus: { hp: 20 } }
]
const event = events[Math.floor(Math.random() * events.length)]
if (event.bonus) {
for (let stat in event.bonus) {
char[stat] += event.bonus[stat]
}
} else if (event.penalty) {
for (let stat in event.penalty) {
char[stat] = Math.max(0, char[stat] - event.penalty[stat])
}
}
saveData(rpgData)
return `@${mentionUser(Usuario_Op)}, ${event.message}`
}
// FIM DO RPG

// SISTEMA TRANSCRIÇÃO AUTOMÁTICA DE ÁUDIOS 
if (isGroup && isAudio && isAutoTranscricao) {
console.log(`[INFO] - Iniciando processo de transcrição para áudio do usuário: ${sender}`)
var audioMessage = info?.message?.audioMessage
try {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
if (audioMessage.fileLength <= 2100000) {
console.log(`[INFO] - Tamanho do áudio verificado: ${audioMessage.fileLength} bytes. Continuando processamento...`)
var mediaData = await downloadContentFromMessage(audioMessage, 'audio')
let bufferArray = []
console.log(`[INFO] - Baixando áudio...`)
for await (var chunk of mediaData) {
bufferArray.push(chunk)
}
var audioBuffer = Buffer.concat(bufferArray)
var audioFilePath = `./armor/assets/translate/totext-${sender}.mp3`
fs.writeFileSync(audioFilePath, audioBuffer)
console.log(`[INFO] - Áudio salvo em: ${audioFilePath}`)
var uploadResponse = await axios.post('https://api.assemblyai.com/v2/upload', audioBuffer, {
headers: {
'authorization': assemblyApiKey,
'content-type': 'application/octet-stream'
}
})
var audioUrl = uploadResponse.data.upload_url
console.log(`[INFO] - Upload bem-sucedido. URL do áudio: ${audioUrl}`)
var transcriptResponse = await axios.post('https://api.assemblyai.com/v2/transcript', {
audio_url: audioUrl,
speaker_labels: true,
language_code: 'pt'
}, {
headers: {
'authorization': assemblyApiKey,
'content-type': 'application/json'
}
})
var transcriptId = transcriptResponse.data.id
console.log(`[INFO] - Solicitação de transcrição enviada. ID da transcrição: ${transcriptId}`)
let transcriptStatus = 'processing'
let transcriptData;
console.log(`[INFO] - Status inicial da transcrição: ${transcriptStatus}`)
while (transcriptStatus === 'processing') {
var statusResponse = await axios.get(`https://api.assemblyai.com/v2/transcript/${transcriptId}`, {
headers: {
'authorization': assemblyApiKey
}
})
transcriptData = statusResponse.data
transcriptStatus = transcriptData.status
console.log(`[INFO] - Status atual da transcrição: ${transcriptStatus}`)
if (transcriptStatus === 'failed') {
throw new Error("A transcrição falhou.")
}
if (transcriptStatus === 'processing') {
await new Promise(resolve => setTimeout(resolve, 3000))
}
}
if (transcriptData.text) {
console.log(`[INFO] - Transcrição concluída com sucesso. Texto transcrito: ${transcriptData.text}`)
reply(transcriptData.text)
fs.unlinkSync(audioFilePath)
console.log(`[INFO] - Arquivo temporário removido: ${audioFilePath}`)
}
} else {
console.log(`[WARN] - O tamanho do arquivo de áudio (${audioMessage.fileLength} bytes) excede o limite permitido de 2MB.`)
}
} catch (e) {
console.error(`[ERROR] - Erro no processo de transcrição: ${e.message}`)
}
}

//========== ◤AUTO DOWNLOAD - TIKTOK ◢ ==========\\
// SISTEMA DE DOWNLOAD AUTOMÁTICO 
// REALIZA O DOWNLOAD DE VÍDEO E ÁUDIO 
// DO YOUTUBE AUTOMATICAMENTE 
// APOS ATIVAÇÃO DO SISTEMA 
// IRA DETECTAR O LINK RECEBIDO 
// E FAZER O DOWNLOAD E ENVIO 
// BY: LICHT BACH 
// CHAT: wa.me/559491569380
// Staff ZERO TWO STORE
let sentVideo = false
let sentAudio = false
const tiktokRegex = /^(https?:\/\/)?(www\.)?(tiktok\.com|vm\.tiktok\.com)\/.+$/
if (isAutoBaixar && tiktokRegex.test(budy.toLowerCase()) && isGroup) {
const originalUrl = budy
try {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
reagir(from, "⬇️")
reply(`Realizando Download, Aguarde...`)
console.log(`Link fornecido: ${originalUrl}`)
const Tiktok = require('tiktokapi-src')
console.log('Módulo TikTok carregado:', Tiktok)
async function downloadTikTok(link) {
try {
console.log(`Tentando baixar o TikTok com o link: ${link}`)
const result = await Tiktok.Downloader(link, { version: 'v2' })
console.log('Resultado da API do TikTok:', JSON.stringify(result, null, 2))
return result
} catch (error) {
console.error('Erro ao baixar o TikTok:', error)
return null
}
}
const tiktokData = await downloadTikTok(originalUrl)
if (tiktokData && tiktokData.status === 'error') {
console.log('Erro na resposta da API:', tiktokData.message)
reply(`Erro: ${tiktokData.message}`)
} else if (tiktokData && tiktokData.status === 'success') {
const { result } = tiktokData
const videoUrl = result.video || ''
const type = result.type || '🔒 Não disponível'
const author = result.author?.nickname || '🔒 Não disponível'
const likeCount = result.statistics?.likeCount || '🔒 Não disponível'
const commentCount = result.statistics?.commentCount || '🔒 Não disponível'
const shareCount = result.statistics?.shareCount || '🔒 Não disponível'
const description = result.desc || '🔒 Não disponível'
if (!videoUrl) {
console.error('Erro: URL do vídeo não encontrada.')
reply('Erro: Não foi possível encontrar o link de download do vídeo.')
return
}
if (!sentVideo) {
reply(`❪𝙴𝚗𝚟𝚒𝚊𝚗𝚍𝚘 𝚂𝚎𝚞 𝚅í𝚍𝚎𝚘ฺ࣭࣪͘ꕸ▸`)
await zerotwo.sendMessage(from, { video: { url: videoUrl }, caption: `❯❯ ZERO TWO - DOWNLOAD TIKTOK ❮❮\n\n🌟 *✨ Detalhes do TikTok ✨* 🌟\n❯ ❒ *Tipo:* ${type}\n❯ ❒ *Autor:* ${author}\n❯ ❒ *Curtidas:* ${likeCount}\n❯ ❒ *Comentários:* ${commentCount}\n❯ ❒ *Compartilhamentos:* ${shareCount}\n❯ ❒ *Descrição:* ${description}\n\n❒ 🌈 *✨ Não se esqueça de seguir o autor para mais conteúdos incríveis!✨* 🌈\n\n❒ 💖 *Obrigada por assistir!*` }, {quoted: selolucas})
sentVideo = true
}
await sleep(1200)
if (!sentAudio) {
reply(`❪𝙴𝚗𝚟𝚒𝚊𝚗𝚍𝚘 𝚂𝚎𝚞 Á𝚞𝚍𝚒𝚘ฺ࣭࣪͘ꕸ▸`)
zerotwo.sendMessage(from, {audio: { url: videoUrl }, mimetype: 'audio/mpeg', ptt: true }, { quoted: selolucas })
sentAudio = true
}
} else {
console.log('Erro na resposta ou link de download não encontrado:', tiktokData ? tiktokData.message : 'Nenhum dado retornado.')
reply('Erro ao processar o TikTok.')
}
} catch (error) {
console.error('Erro inesperado ao tentar baixar o TikTok:', error)
reply('Ocorreu um erro inesperado ao processar o TikTok.')
}
}

//========== ◤AUTO DOWNLOAD - YOUTUBE ◢ ==========\\
let sentVideo2 = false
let sentAudio2 = false
function removerQueryParams(url) {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
return url.split('?')[0]
}
const youtubeRegex = /^(https?:\/\/)?(www\.)?(youtube\.com|youtu\.be)\/.+$/
if (isAutoBaixar && youtubeRegex.test(budy2.toLowerCase()) && isGroup) {
const cleanUrl = removerQueryParams(budy2)
try {
reply('Obtendo as Informações Para Download')
const response = await fetchJson(`${zerosite}/api/ytsrc?q=${encodeURIComponent(cleanUrl)}&apikey=` + API_KEY_ZEROTWO)
if (!response || !response.status || !response.resultado || response.resultado.length === 0) {
return reply("https://zero-two.online não forneceu Informações Suficiente.")
}
const firstVideo = response.resultado[0]
const { title, author, url, views, timestamp, thumbnail } = firstVideo
const emojis = ['👍', '🔥', '🎉', '😁', '👌', '👏', '💪']
const emojiAleatorio = emojis[Math.floor(Math.random() * emojis.length)]
reagir(from, emojiAleatorio)
if (!sentVideo2) {
reply('Realizando Download do Vídeo.')
const videoUrl = zerosite + `/api/dl/ytvideo?url=${encodeURIComponent(url)}&apikey=` + API_KEY_ZEROTWO
const message = `*❯❯ ZERO TWO - DOWNLOAD YOUTUBE ❮❮*\n\n` +
`*❒ Título:* ${title}\n` +
`*❒ Canal:* ${author.name}\n` +
`*❒ Visualizações:* ${views}\n` +
`*❒ Duração:* ${timestamp}`
await zerotwo.sendMessage(from, {video: { url: videoUrl }, caption: message, thumbnail: thumbnail, mimetype: "video/mp4" }, { quoted: selolucas })
sentVideo2 = true
reply('Realizando Download do Áudio.')
}
if (!sentAudio2) {
const audioUrl = `${zerosite}/api/dl/ytaudio?url=${encodeURIComponent(url)}&apikey=` + API_KEY_ZEROTWO
await zerotwo.sendMessage(from, {audio: { url: audioUrl }, mimetype: 'audio/mpeg', ptt: true }, { quoted: selolucas })
sentAudio2 = true
}
} catch (error) {
console.log("Erro ao processar o link do YouTube:", error)
reply('Ocorreu um erro ao processar o link do YouTube. Verifique o link e tente novamente.')
}
}

//========== ◤AUTO DOWNLOAD - INSTAGRAM ◢ ==========\\
let sentInstagramVideo = false
let sentInstagramAudio = false
function removerQueryParams(url) {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
return url.split('?')[0]
}
const instagramRegex = /^(https?:\/\/)?(www\.)?(instagram\.com|instagr\.am)\/.+$/
if (isAutoBaixar && instagramRegex.test(budy.toLowerCase()) && isGroup) {
const cleanUrl = removerQueryParams(budy)
try {
reply('Obtendo as Informações Para Download')
fetch(`${zerosite}/api/dl/instagram?url=${encodeURIComponent(cleanUrl)}&apikey=${API_KEY_ZEROTWO}`)
.then(res => res.json())
.then(async (json) => {
if (!json || !json.status || !json.resultado || json.resultado.length === 0) {
return reply("Falha ao obter informações do vídeo do Instagram.")
}
const resultados = json.resultado
const creator = json.criador || 'Desconhecido'
const emojis = ['👍', '🔥', '🎉', '😁', '👌', '👏', '💪']
const emojiAleatorio = emojis[Math.floor(Math.random() * emojis.length)]
reagir(from, emojiAleatorio)
if (!sentInstagramVideo) {
for (let i = 0; i < resultados.length; i++) {
const videoUrl = resultados[i].url
const thumbnail = resultados[i].thumbnail
const message = `*❯❯ ZERO TWO - DOWNLOAD INSTAGRAM ❮❮*\n\n*❒ Criador:* ${creator}\n*❒ Vídeo ${i + 1} baixado com sucesso!*`
await zerotwo.sendMessage(from, { video: { url: videoUrl }, caption: message, thumbnail: await getBuffer(thumbnail), mimetype: "video/mp4" }, { quoted: selolucas })
await sleep(1500)
}
sentInstagramVideo = true
reply('📥 Todos os vídeos foram enviados com sucesso!')
}
if (!sentInstagramAudio && resultados[0]?.url) {
const videoUrl = resultados[0].url
await zerotwo.sendMessage(from, { audio: { url: videoUrl }, mimetype: 'audio/mpeg', ptt: true }, { quoted: selolucas })
sentInstagramAudio = true
reply('📥 O áudio foi enviado com sucesso!')
}
})
.catch(error => {
console.log("Erro ao processar o link do Instagram:", error)
reply('Ocorreu um erro ao processar o link do Instagram. Verifique o link e tente novamente.')
})
} catch (error) {
console.log("Erro ao processar o link do Instagram:", error)
reply('Ocorreu um erro ao processar o link do Instagram. Verifique o link e tente novamente.')
} finally {
sentInstagramVideo = false
sentInstagramAudio = false
}
}

//========== ◤AUTO DOWNLOAD - THREADS ◢ ==========\\
let sentThreadsVideo = false
let sentThreadsImage = false
let sentThreadsAudio = false
function removerQueryParams(url) {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
return url.split('?')[0]
}
const threadsRegex = /^(https?:\/\/)?(www\.)?(threads\.net)\/.+$/
if (isAutoBaixar && threadsRegex.test(budy.toLowerCase()) && isGroup) {
const cleanUrl = removerQueryParams(budy)
try {
reply('Obtendo as Informações Para Download')
fetch(`${zerosite}/api/dl/threads?url=${encodeURIComponent(cleanUrl)}&apikey=${API_KEY_ZEROTWO}`)
.then(res => res.json())
.then(async (json) => {
if (!json || !json.status || (!json.resultado.image_urls && !json.resultado.video_urls)) {
return reply("Falha ao obter informações do conteúdo do Threads.")
}
const resultados = json.resultado
const creator = json.criador || 'Desconhecido'
const emojis = ['👍', '🔥', '🎉', '😁', '👌', '👏', '💪']
const emojiAleatorio = emojis[Math.floor(Math.random() * emojis.length)]
reagir(from, emojiAleatorio)
if (!sentThreadsImage && resultados.image_urls?.length > 0) {
for (let imageUrl of resultados.image_urls) {
const message = `*❯❯ ZERO TWO - DOWNLOAD ❮❮*\n\n*❒ Criador:* ${creator}\n*❒ Imagem baixada com sucesso!*`
await zerotwo.sendMessage(from, { image: { url: imageUrl }, caption: message }, { quoted: selolucas });
await sleep(1500)
}
sentThreadsImage = true
reply('📥 Todas as imagens foram enviadas com sucesso!')
}
if (!sentThreadsVideo && resultados.video_urls?.length > 0) {
for (let video of resultados.video_urls) {
const videoUrl = video.download_url
const message = `*❯❯ ZERO TWO - DOWNLOAD THREADS ❮❮*\n\n*❒ Criador:* ${creator}\n*❒ Vídeo baixado com sucesso!*`
await zerotwo.sendMessage(from, { video: { url: videoUrl }, caption: message, mimetype: "video/mp4" }, { quoted: selolucas })
await sleep(1500)
if (!sentThreadsAudio) {
await zerotwo.sendMessage(from, { audio: { url: videoUrl }, mimetype: 'audio/mpeg', ptt: true }, { quoted: selolucas })
sentThreadsAudio = true
reply('📥 O áudio do vídeo foi enviado com sucesso!')
}
}
sentThreadsVideo = true
reply('📥 Todos os vídeos foram enviados com sucesso!')
}
})
.catch(error => {
console.log("Erro ao processar o link do Threads:", error)
reply('Ocorreu um erro ao processar o link do Threads. Verifique o link e tente novamente.')
})
} catch (error) {
console.log("Erro ao processar o link do Threads:", error)
reply('Ocorreu um erro ao processar o link do Threads. Verifique o link e tente novamente.')
} finally {
sentThreadsVideo = false
sentThreadsImage = false
sentThreadsAudio = false
}
}

//========== ◤AUTO DOWNLOAD - MEGA ◢ ==========\\
let sentMegaVideo = false
let sentMegaAudio = false
let sentMegaImage = false
let sentMegaOther = false
function removerQueryParams(url) {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
return url.split('?')[0]
}
function ensureTempDir() {
const tempDir = './temp'
if (!fs.existsSync(tempDir)) {
fs.mkdirSync(tempDir, { recursive: true })
}
}
const megaRegex = /^(https?:\/\/)?(mega\.nz\/file\/[a-zA-Z0-9_-]+#[a-zA-Z0-9_-]+)/
if (isAutoBaixar && megaRegex.test(budy.toLowerCase()) && isGroup) {
const cleanUrl = removerQueryParams(budy)
try {
reply('Obtendo as Informações para Download do Mega...')
ensureTempDir()
const linkParts = cleanUrl.match(/\/file\/([a-zA-Z0-9_-]+)#([a-zA-Z0-9_-]+)/)
if (!linkParts) {
return reply("❌ Link do Mega inválido. Por favor, forneça um link válido.")
}
const [_, downloadId, key] = linkParts
const file = new mega.File({ downloadId, key })
file.loadAttributes()
.then(async () => {
const fileName = file.name || 'arquivoMega'
const fileSize = (file.size / (1024 * 1024)).toFixed(2) + " MB"
const tempFilePath = `./temp/${fileName}`
reply(`📥 Iniciando o download do arquivo: ${fileName} (${fileSize})`)
file.download()
.pipe(fs.createWriteStream(tempFilePath))
.on('finish', async () => {
const extension = fileName.split('.').pop().toLowerCase()
if (fs.existsSync(tempFilePath)) {
if (!sentMegaImage && ['jpg', 'jpeg', 'png', 'gif'].includes(extension)) {
await zerotwo.sendMessage(from, { image: { url: tempFilePath }, caption: `*Imagem baixada com sucesso!*\n*Arquivo:* ${fileName}\n*Tamanho:* ${fileSize}` }, { quoted: selolucas })
sentMegaImage = true
reply('📥 A imagem foi enviada com sucesso!')
} else if (!sentMegaVideo && ['mp4', 'mkv', 'mov'].includes(extension)) {
await zerotwo.sendMessage(from, { video: { url: tempFilePath }, caption: `*Vídeo baixado com sucesso!*\n*Arquivo:* ${fileName}\n*Tamanho:* ${fileSize}`, mimetype: "video/mp4" }, { quoted: selolucas })
sentMegaVideo = true
reply('📥 O vídeo foi enviado com sucesso!')
if (!sentMegaAudio) {
await zerotwo.sendMessage(from, { audio: { url: tempFilePath }, mimetype: 'audio/mpeg', ptt: true }, { quoted: selolucas })
sentMegaAudio = true
reply('📥 O áudio do vídeo foi enviado com sucesso!')
}
} else if (!sentMegaAudio && ['mp3', 'wav', 'flac'].includes(extension)) {
await zerotwo.sendMessage(from, { audio: { url: tempFilePath }, mimetype: 'audio/mpeg', ptt: true }, { quoted: selolucas })
sentMegaAudio = true
reply('📥 O áudio foi enviado com sucesso!')
} else if (!sentMegaOther) {
await zerotwo.sendMessage(from, { document: { url: tempFilePath }, mimetype: "application/octet-stream", fileName: fileName }, { quoted: selolucas })
sentMegaOther = true
reply(`📥 O arquivo foi enviado com sucesso!`)
}
fs.unlink(tempFilePath, (err) => {
if (err) console.log("Erro ao deletar o arquivo temporário:", err)
})
} else {
reply('❌ Erro ao salvar o arquivo baixado.')
}
})
.on('error', (error) => {
console.log("Erro no download do Mega:", error)
reply("Ocorreu um erro ao fazer o download do arquivo do Mega.")
})
})
.catch(error => {
console.log("Erro ao carregar os metadados do Mega:", error)
reply('Ocorreu um erro ao carregar as informações do arquivo do Mega. Verifique o link e tente novamente.')
})
} catch (error) {
console.log("Erro ao processar o link do Mega:", error)
reply('Ocorreu um erro ao processar o link do Mega. Verifique o link e tente novamente.')
} finally {
sentMegaVideo = false
sentMegaAudio = false
sentMegaImage = false
sentMegaOther = false
}
}

//========== ◤ FIM DOS AUTO DOWNLOADS ◢ ==========\\

// Configurações de agendamento
const tempFolder = path.join(__dirname, 'temp')
const configFilePath = path.join(tempFolder, 'configuracoes_grupo.json')
let groupSchedules = {}
if (!fs.existsSync(tempFolder)) {
fs.mkdirSync(tempFolder)
}
if (fs.existsSync(configFilePath)) {
groupSchedules = JSON.parse(fs.readFileSync(configFilePath))
}
const saveSchedules = () => {
fs.writeFileSync(configFilePath, JSON.stringify(groupSchedules, null, 2))
}
const getBRTDateTime = () => {
return moment().tz("America/Sao_Paulo").format('YYYY-MM-DD HH:mm')
}
const checkGroupSchedules = () => {
const nowTime = moment().tz("America/Sao_Paulo").format('HH:mm')
const today = moment().tz("America/Sao_Paulo").format('YYYY-MM-DD')
for (const groupId in groupSchedules) {
const schedule = groupSchedules[groupId]
const lastClosureDate = schedule.lastClosureDate || ""
if (schedule.scheduledTime && nowTime === schedule.scheduledTime) {
if (lastClosureDate !== today) {
zerotwo.groupSettingUpdate(groupId, 'announcement')
console.log(`Grupo ${groupId} fechado automaticamente às ${getBRTDateTime()} (Horário de Brasília).`)
//reply(`Grupo ${groupId} fechado automaticamente às ${getBRTDateTime()} (Horário de Brasília).`)
schedule.lastClosureDate = today
saveSchedules()
}
}
}
}
setInterval(checkGroupSchedules, 60000)

// Configurações de agendamento 2
const tempFolder2 = path.join(__dirname, 'temp')
const configFilePath2 = path.join(tempFolder2, 'configuracoes_grupo2.json')
let groupSchedules2 = {}
if (!fs.existsSync(tempFolder2)) {
fs.mkdirSync(tempFolder2)
}
if (fs.existsSync(configFilePath2)) {
groupSchedules2 = JSON.parse(fs.readFileSync(configFilePath2))
}
const saveSchedules2 = () => {
fs.writeFileSync(configFilePath2, JSON.stringify(groupSchedules2, null, 2))
}
const getBRTDateTime2 = () => {
return moment().tz("America/Sao_Paulo").format('YYYY-MM-DD HH:mm')
}
const checkGroupSchedules2 = () => {
const nowTime = moment().tz("America/Sao_Paulo").format('HH:mm')
const today = moment().tz("America/Sao_Paulo").format('YYYY-MM-DD')
for (const groupId in groupSchedules2) {
const schedule = groupSchedules2[groupId]
const lastOpenDate = schedule.lastOpenDate || ""
if (schedule.scheduledTime && nowTime === schedule.scheduledTime) {
if (lastOpenDate !== today) {
zerotwo.groupSettingUpdate(groupId, 'not_announcement')
console.log(`Grupo ${groupId} aberto automaticamente às ${getBRTDateTime2()} (Horário de Brasília).`)
//reply(`Grupo ${groupId} aberto automaticamente às ${getBRTDateTime2()} (Horário de Brasília).`)
schedule.lastOpenDate = today
saveSchedules2()
}
}
}
}
setInterval(checkGroupSchedules2, 60000)

// SISTEMA BAN REAÇÃO 
//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
/* ESTAREI DESATIVANDO O SISTEMA POR QUE NÃO VEJO NECESSIDADE DE USO AINDA *\
const emojiBan = '☠️'
const seuNumero = '559491569380@s.whatsapp.net'
const DEBUG_MODE = false // Altere para true se quiser ver os logs
zerotwo.ev.on('messages.upsert', (data) => {
if (DEBUG_MODE) {
console.log('Recebido evento de inserção de mensagens:', data)
}
if (data.messages && Array.isArray(data.messages)) {
for (const message of data.messages) {
if (DEBUG_MODE) {
console.log('Processando mensagem:', message)
}
const msgContent = message.message
if (msgContent && typeof msgContent === 'object') {
if (msgContent.reactionMessage) {
const reaction = msgContent.reactionMessage
if (DEBUG_MODE) {
console.log('Mensagem de reação encontrada:', reaction)
}
if (reaction.text === emojiBan) {
const participant = reaction.key.participant
if (participant !== seuNumero) {
console.log(`Banimento de usuário ${participant} iniciado.`)
zerotwo.groupParticipantsUpdate(message.key.remoteJid, [participant], 'remove').then(() => {
console.log(`Usuário ${participant} removido com sucesso.`)
const banMessage = `@${participant.split('@')[0]} foi banido!`
zerotwo.sendMessage(from, { text: banMessage, mentions: [participant] }).then(() => {
if (DEBUG_MODE) {
console.log(`Mensagem de banimento enviada para o chat ${message.key.remoteJid}.`)
}
}).catch((err) => {
if (DEBUG_MODE) {
console.error('Erro ao enviar mensagem de banimento:', err)
}
});
}).catch((err) => {
if (DEBUG_MODE) {
console.error('Erro ao remover usuário:', err)
}
});
} else {
if (DEBUG_MODE) {
console.log('O usuário que reagiu é o mesmo que pode banir.')
}
}
} else {
if (DEBUG_MODE) {
console.log(`Reação não corresponde ao emoji de banimento. Emoji: ${reaction.text}`)
}
}
} else {
if (DEBUG_MODE) {
console.log('Mensagem não é uma mensagem de reação.')
}
}
} else {
if (DEBUG_MODE) {
console.log('Conteúdo da mensagem inválido ou não é um objeto:', msgContent)
}
}
}
} else {
if (DEBUG_MODE) {
console.log('Nenhuma mensagem encontrada no evento de inserção.')
}
}
})
*/

// Função para processar a mídia
async function salvarLinkNaCategoria(buffer, tipo, sender) {
console.log(chalk.blue(`[LOG] Estado da coleta antes da verificação: coletaAtiva = ${coletaAtiva}, categoriaSalva = ${categoriaSalva}`));

// Verificar se a coleta está ativa e se a categoria está salva
if (!coletaAtiva || !categoriaSalva) {
console.log(chalk.red('[ERRO] A coleta não está ativa ou categoria não definida.'));
return reply('_❲❗❳ A coleta de links não está ativa ou a categoria não foi definida. Use #salvarlinks <categoria> para ativar._');
}

// Processa a mídia e salva o link
try {
const mediaType = tipo;
console.log(chalk.green(`[LOG] Iniciando upload da mídia para Cloudinary...`));
const linkGerado = await uploadToCloudinary(buffer, mediaType, sender);
console.log(chalk.green(`[LOG] Link gerado: ${linkGerado}`));

const caminhoArquivo = path.join(__dirname, 'temp', `${categoriaSalva}.json`);
let linksCarregados = {};

if (fs.existsSync(caminhoArquivo)) {
try {
linksCarregados = JSON.parse(fs.readFileSync(caminhoArquivo, 'utf-8'));
} catch (parseError) {
console.error(chalk.red(`[ERRO] Falha ao carregar JSON existente: ${parseError.message}`));
}
}

if (!linksCarregados[categoriaSalva]) {
linksCarregados[categoriaSalva] = [];
}

linksCarregados[categoriaSalva].push({
nome: `${sender}-${mediaType}`,
link: linkGerado
});

fs.writeFileSync(caminhoArquivo, JSON.stringify(linksCarregados, null, 2));
console.log(chalk.green('[LOG] Link salvo na categoria com sucesso.'));
reply(`✅ Link salvo na categoria "${categoriaSalva}" com sucesso.`);
} catch (error) {
console.error(chalk.red(`[ERRO] Falha ao processar a mídia: ${error.message}`));
}
}

// INICIO DE COMANDO DE PREFIXO
switch (command) {

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: ddd
└─────────────────────────────────────────────────┘
*/
case 'ddd':
setTimeout(() => {reagir(from, "📱")}, 300)
if(args.length < 1) return reply(`*Digite o DDD para puxar...*\n*Exemplo:* ${prefix + command} 91`)
try {
ABC = await fetchJson(zerosite+`/api/ddd?ddd=${q}&apikey=`+API_KEY_ZEROTWO)
dddlist = `Lista de Cidades de ${ABC.cidade} com este DDD ${q} ↴

${ABC.resultado.map(i => `»${(ABC.resultado.indexOf(i)) + 1}« ${i}`).join("\n")}`
reply(dddlist)
} catch(e) { console.log(e)
reply("Erro") }
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: deletarkey
└─────────────────────────────────────────────────┘
*/
case 'deletarkey':
if (!isOwner) return reply(enviar.msg.donosmt)
if (!q) return reply("KD o nome da key pra eu deletar? Ex: " + prefix + command + " luquinhas")
const keyToDelete = encodeURIComponent(q)
fetch(`${zerosite}/dono/puxar-senha`)
.then(response => {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
if (!response.ok) {
throw new Error(`Erro na resposta da API: ${response.statusText}`)
}
return response.json()
})
.then(data => {
if (!data.senha) {
throw new Error('Resposta da API não contém a senha')
}
const senha = data.senha
return fetch(`${zerosite}/dono/del-key?apikey=${keyToDelete}&senha=${senha}`)
})
.then(response => response.json())
.then(data => {
if (data.message.includes("✖️")) {
reply(data.message)
} else {
reply("[❗] Erro apikey não encontrada")
}
})
.catch(error => {
console.log('Erro ao se conectar com a API:', error)
reply("[❗] Erro ao se conectar com a API")
})
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: dupla
└─────────────────────────────────────────────────┘
*/
case 'dupla':
reagir(from, "❤️‍🩹")
if(!userEstaNamorando(sender)) return reply(`Você não está casado (a) com ninguém... Sinto muito 😕`)
if(isWaitUsuFZ_namoro(sender)) return reply(`A pessoa quem você pediu em namoro não aceitou o pedido ainda... Portanto, não é possível consultar os dados da dupla 😶‍🌫️`)
i = getDBFZuser(sender)
n = i.namoro
c = i.casamento

//============contador de tempo================\\

data_pedido = `📆❒ Namorando desde ${n.day}/${n.mm}/${n.year}`

if(!userEstaCasado(sender)) {
tipo = "Namoro"
tempo_total = "_Namorando a "
sub = contarDias(sendHours("DD/MM/YYYY")) - contarDias(`${n.day}/${n.mm}/${n.year}`)
horas = (sub * 24) + (Number(sendHours("HH")) - n.hora)
if(horas <= 0) {
sec = "aproximadamente "
if((Number(sendHours("mm")) - n.minuto) <= 0) {
sec += Number(sendHours("ss")) - n.segundo
sec += ` segundo${(Number(sendHours("ss")) - n.segundo) != 1 ? "s" : ""}`
} else {
sec += Number(sendHours("mm")) - n.minuto
sec += ` minuto${(Number(sendHours("mm")) - n.minuto) != 1 ? "s" : ""}`
}
tempo_total += sec
} else if(horas > 0 && horas <= 24) {
tempo_total += `aproximadamente ${horas} hora${horas != 1 ? "s" : ""}`
} else tempo_total += converterDias(sub)
tempo_total += "_\n"
if(Number(sendHours("DD")) === n.day && horas > 24) {
if(Number(sendHours("MM")) === n.mm && Number(sendHours("YYYY")) !== n.year) {
ano = Number(sendHours("YYYY")) - n.year
tempo_total = `_Namorando a exatamente ${ano} ano${ano != 1 ? "s" : ""}_`
tempo_total += "\n"
tempo_total += "*_Parabéns_* 💖✨"
} else {
mês = ((Number(sendHours("YYYY")) - n.year) * 12) + (Number(sendHours("MM")) - n.mm)
tempo_total = `_Namorando a exatamente ${mês} m${mês != 1 ? "eses" : "ês"}_`
tempo_total += "\n"
tempo_total += "*_Parabéns_* 💗😍"
}
}
} else {
tipo = "Casamento"
tempo_total = "_Casados a "
sub = contarDias(sendHours("DD/MM/YYYY")) - contarDias(`${c.day}/${c.mm}/${c.year}`)
horas = (sub * 24) + (Number(sendHours("HH")) - c.hora)
if(horas <= 0) {
sec = "aproximadamente "
if((Number(sendHours("mm")) - c.minuto) <= 0) {
sec += Number(sendHours("ss")) - c.segundo
sec += ` segundo${(Number(sendHours("ss")) - c.segundo) != 1 ? "s" : ""}`
} else {
sec += Number(sendHours("mm")) - c.minuto
sec += ` minuto${(Number(sendHours("mm")) - c.minuto) != 1 ? "s" : ""}`
}
tempo_total += sec
} else if(horas > 0 && horas <= 24) {
tempo_total += `aproximadamente ${horas} hora${horas != 1 ? "s" : ""}`
} else tempo_total += converterDias(sub)
tempo_total += "_\n"
data_pedido += `\n💍❒ Casados desde ${c.day}/${c.mm}/${c.year}`
if(Number(sendHours("DD")) === c.day && horas > 24) {
if(Number(sendHours("MM")) === c.mm && Number(sendHours("YYYY")) !== c.year) {
ano = Number(sendHours("YYYY")) - c.year
tempo_total = `_Namorando a exatamente ${ano} ano${ano != 1 ? "s" : ""}_ 🎂`
tempo_total += "\n"
tempo_total += "*_Feliz aniversário_* 💖✨"
} else {
mês = ((Number(sendHours("YYYY")) - c.year) * 12) + (Number(sendHours("MM")) - c.mm)
tempo_total = `_Namorando a exatamente ${mês} m${mês != 1 ? "eses" : "ês"}_ 🎂`
tempo_total += "\n"
tempo_total += "*_Feliz aniversário_* 💗😍"
}
}
}

//===================fotos=======================\\
db = getDBFZuser(sender)

try {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
const profilePicUrl = await zerotwo.profilePictureUrl(`${db.usu1.split('@')[0]}@c.us`, 'image')
const response = await axios.get(profilePicUrl, {
responseType: 'arraybuffer',
headers: {
'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3'
}
})
if (response.status === 200) {
const buffer = Buffer.from(response.data, 'binary')
foto1 = await upload(buffer)
} else {
throw new Error(`Erro ao obter a imagem: ${response.status}`)
}
} catch (e) {
console.log("Erro ao obter a imagem de perfil:", e.message)
foto1 = semfoto
}

try {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
const profilePicUrl = await zerotwo.profilePictureUrl(`${db.usu2}@c.us`, 'image')
const response = await axios.get(profilePicUrl, {
responseType: 'arraybuffer',
headers: {
'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3'
}
})
if (response.status === 200) {
const buffer = Buffer.from(response.data, 'binary')
foto2 = await upload(buffer)
} else {
throw new Error(`Erro ao obter a imagem: ${response.status}`)
}
} catch (e) {
console.log("Erro ao obter a imagem de perfil:", e.message)
foto2 = semfoto
}

logocasal = zerosite+`/api/canvas/ship?foto1=${foto1}&foto2=${foto2}&mat=100&fundo=https://telegra.ph/file/070ced9a362da470ae3f9.jpg`

//=========distribuição de informações===========\\

txt = `
💕 ${tipo} entre ↴
『😍』@${db.usu1.split('@')[0]}
ㅤ &
〘❤️‍🩹〙@${db.usu2}
⇒ ${tempo_total}
---------------------------------------------------------
${data_pedido}`
mencionarIMG(txt, logocasal)
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: edit-anime
└─────────────────────────────────────────────────┘
*/
case 'edit-anime':
reagir(from, "🙂")
const { animess } = require('./database/EditAnime.js')
var edits = animess[Math.floor(Math.random() * animess.length)] 
const videoUrl = `${zerosite}` // Substitua pelo link do vídeo personalizado
const votos = Math.floor(Math.random() * 1000)
const textoPersonalizado = `
❯❯ ZERO TWO - EDITS ❮❮

❯ Fonte: Instagram 
❯ Coleção: Zero Two Oficial 
❯ Curtidas: ${votos}
❯ Categoria: Edits Animes`
const video = await prepareWAMessageMedia({ video: { url: edits, gifPlayback: true } }, { upload: zerotwo.waUploadToServer })
zerotwo.relayMessage(
from,
{//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
interactiveMessage: {
header: {
hasMediaAttachment: true,
videoMessage: { ...video.videoMessage, gifPlayback: true }
},
headerType: 'VIDEO',
body: { text: textoPersonalizado },
footer: { text: `${zerosite}\nBy: lucas_mod_domina` },
contextInfo: {forwardingScore: 999, isForwarded: true, forwardedNewsletterMessageInfo: {newsletterJid: channel, newsletterName: `𝙲𝙾𝙽𝙽𝙴𝙲𝚃𝙴𝙳 𝙲𝙾𝙽𝚃𝙴Ú𝙳𝙾𝚂`}},
nativeFlowMessage: {
buttons: [
{
name: "cta_copy",
buttonParamsJson: JSON.stringify({
display_text: "❯❯ COPIAR LINK ❮❮",
copy_code: `${videoUrl}`
}),
},
{//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
name: "quick_reply",
buttonParamsJson: JSON.stringify({//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
display_text: "❯❯ PRÓXIMA ❮❮",
id: `${prefix+command}`,
disabled: false
}),
}
],
messageParamsJson: "",
},
},
},
{}
)
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: editanime-bleach
└─────────────────────────────────────────────────┘
*/
case 'editanime-bleach':
reagir(from, "✨")
fonte = ['Instagram', 'Tiktok', 'YouTube', 'Kwai', 'Facebook', 'Internet']
gozeinonear = Math.floor(Math.random() * 1000)
let videoss = await prepareWAMessageMedia({ video: {url: `${zerosite}/random/bleach?apikey=${API_KEY_ZEROTWO}&categoria=bleach`}}, { upload: zerotwo.waUploadToServer })
await zerotwo.relayMessage(from, 
{
interactiveMessage: {
header: {
title: '',
subtitle: '',
hasMediaAttachment: true,
videoMessage: videoss.videoMessage
},
footer: {
text: '',
},
contextInfo: { participant: sender, quotedMessage: info.message, forwardingScore: 999, isForwarded: true, forwardedNewsletterMessageInfo: {newsletterJid: channel, newsletterName: `𝙲𝙾𝙽𝙽𝙴𝙲𝚃𝙴𝙳 𝙲𝙾𝙽𝚃𝙴Ú𝙳𝙾𝚂`}},
body: { text: `❯❯ ZERO TWO - EDIT ANIME ❮❮

❒ৣ͜͡Categoria: Edit Animes
❒ৣ͜͡Fonte: ${fonte[Math.floor(Math.random() * fonte.length)]} 
❒ৣ͜͡Coleção: Zero Two Oficial 
❒ৣ͜͡Curtidas: ${gozeinonear}
${zerosite}
`,
},nativeFlowMessage: {
buttons: [{
name: "quick_reply",
buttonParamsJson: JSON.stringify({
display_text: "ꪶ͢PROXIMA͢ꫂ",
id: `${prefix}editanime-bleach`
}),},
],
messageParamsJson:"",
},
},
},
{}
).then((r) => console.log(r))
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: editanime-chainsaw
└─────────────────────────────────────────────────┘
*/
case 'editanime-chainsaw':
reagir(from, "✨")
fonte = ['Instagram', 'Tiktok', 'YouTube', 'Kwai', 'Facebook', 'Internet']
gozeinonear = Math.floor(Math.random() * 1000)
let videosss = await prepareWAMessageMedia({ video: {url: `${zerosite}/random/chainsaw?apikey=${API_KEY_ZEROTWO}&categoria=chainsaw`}}, { upload: zerotwo.waUploadToServer })
await zerotwo.relayMessage(from, 
{
interactiveMessage: {
header: {
title: '',
subtitle: '',
hasMediaAttachment: true,
videoMessage: videosss.videoMessage
},
footer: {
text: '',
},
contextInfo: { participant: sender, quotedMessage: info.message, forwardingScore: 999, isForwarded: true, forwardedNewsletterMessageInfo: {newsletterJid: channel, newsletterName: `𝙲𝙾𝙽𝙽𝙴𝙲𝚃𝙴𝙳 𝙲𝙾𝙽𝚃𝙴Ú𝙳𝙾𝚂`}},
body: { text: `❯❯ ZERO TWO - EDIT ANIME ❮❮

❒ৣ͜͡Categoria: Edit Animes
❒ৣ͜͡Fonte: ${fonte[Math.floor(Math.random() * fonte.length)]} 
❒ৣ͜͡Coleção: Zero Two Oficial 
❒ৣ͜͡Curtidas: ${gozeinonear}
${zerosite}
`,
},nativeFlowMessage: {
buttons: [{
name: "quick_reply",
buttonParamsJson: JSON.stringify({
display_text: "ꪶ͢PROXIMA͢ꫂ",
id: `${prefix}editanime-chainsaw`
}),},
],
messageParamsJson:"",
},
},
},
{}
).then((r) => console.log(r))
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: editanime-dragonball
└─────────────────────────────────────────────────┘
*/
case 'editanime-dragonball':
reagir(from, "✨")
fonte = ['Instagram', 'Tiktok', 'YouTube', 'Kwai', 'Facebook', 'Internet']
gozeinonear = Math.floor(Math.random() * 1000)
let videosssss = await prepareWAMessageMedia({ video: {url: `${zerosite}/random/dragonball?apikey=${API_KEY_ZEROTWO}&categoria=dragonball`}}, { upload: zerotwo.waUploadToServer })
await zerotwo.relayMessage(from, 
{
interactiveMessage: {
header: {
title: '',
subtitle: '',
hasMediaAttachment: true,
videoMessage: videosssss.videoMessage
},
footer: {
text: '',
},
contextInfo: { participant: sender, quotedMessage: info.message, forwardingScore: 999, isForwarded: true, forwardedNewsletterMessageInfo: {newsletterJid: channel, newsletterName: `𝙲𝙾𝙽𝙽𝙴𝙲𝚃𝙴𝙳 𝙲𝙾𝙽𝚃𝙴Ú𝙳𝙾𝚂`}},
body: { text: `❯❯ ZERO TWO - EDIT ANIME ❮❮

❒ৣ͜͡Categoria: Edit Animes
❒ৣ͜͡Fonte: ${fonte[Math.floor(Math.random() * fonte.length)]} 
❒ৣ͜͡Coleção: Zero Two Oficial 
❒ৣ͜͡Curtidas: ${gozeinonear}
${zerosite}
`,
},nativeFlowMessage: {
buttons: [{
name: "quick_reply",
buttonParamsJson: JSON.stringify({
display_text: "ꪶ͢PROXIMA͢ꫂ",
id: `${prefix}editanime-dragonball`
}),},
],
messageParamsJson:"",
},
},
},
{}
).then((r) => console.log(r))
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: editanime-hunter
└─────────────────────────────────────────────────┘
*/
case 'editanime-hunter':
reagir(from, "✨")
fonte = ['Instagram', 'Tiktok', 'YouTube', 'Kwai', 'Facebook', 'Internet']
gozeinonear = Math.floor(Math.random() * 1000)
let videossssssss = await prepareWAMessageMedia({ video: {url: `${zerosite}/random/hunter_edit?apikey=${API_KEY_ZEROTWO}&categoria=hunter_edit`}}, { upload: zerotwo.waUploadToServer })
await zerotwo.relayMessage(from, 
{
interactiveMessage: {
header: {
title: '',
subtitle: '',
hasMediaAttachment: true,
videoMessage: videossssssss.videoMessage
},
footer: {
text: '',
},
contextInfo: { participant: sender, quotedMessage: info.message, forwardingScore: 999, isForwarded: true, forwardedNewsletterMessageInfo: {newsletterJid: channel, newsletterName: `𝙲𝙾𝙽𝙽𝙴𝙲𝚃𝙴𝙳 𝙲𝙾𝙽𝚃𝙴Ú𝙳𝙾𝚂`}},
body: { text: `❯❯ ZERO TWO - EDIT ANIME ❮❮

❒ৣ͜͡Categoria: Edit Animes
❒ৣ͜͡Fonte: ${fonte[Math.floor(Math.random() * fonte.length)]} 
❒ৣ͜͡Coleção: Zero Two Oficial 
❒ৣ͜͡Curtidas: ${gozeinonear}
${zerosite}
`,
},nativeFlowMessage: {
buttons: [{
name: "quick_reply",
buttonParamsJson: JSON.stringify({
display_text: "ꪶ͢PROXIMA͢ꫂ",
id: `${prefix}editanime-hunter`
}),},
],
messageParamsJson:"",
},
},
},
{}
).then((r) => console.log(r))
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: editanime-jujutsu
└─────────────────────────────────────────────────┘
*/
case 'editanime-jujutsu':
reagir(from, "✨")
fonte = ['Instagram', 'Tiktok', 'YouTube', 'Kwai', 'Facebook', 'Internet']
gozeinonear = Math.floor(Math.random() * 1000)
let videossssss = await prepareWAMessageMedia({ video: {url: `${zerosite}/random/jujutsu_kaisen?apikey=${API_KEY_ZEROTWO}&categoria=jujutsu_kaisen`}}, { upload: zerotwo.waUploadToServer })
await zerotwo.relayMessage(from, 
{
interactiveMessage: {
header: {
title: '',
subtitle: '',
hasMediaAttachment: true,
videoMessage: videossssss.videoMessage
},
footer: {
text: '',
},
contextInfo: { participant: sender, quotedMessage: info.message, forwardingScore: 999, isForwarded: true, forwardedNewsletterMessageInfo: {newsletterJid: channel, newsletterName: `𝙲𝙾𝙽𝙽𝙴𝙲𝚃𝙴𝙳 𝙲𝙾𝙽𝚃𝙴Ú𝙳𝙾𝚂`}},
body: { text: `❯❯ ZERO TWO - EDIT ANIME ❮❮

❒ৣ͜͡Categoria: Edit Animes
❒ৣ͜͡Fonte: ${fonte[Math.floor(Math.random() * fonte.length)]} 
❒ৣ͜͡Coleção: Zero Two Oficial 
❒ৣ͜͡Curtidas: ${gozeinonear}
${zerosite}
`,
},nativeFlowMessage: {
buttons: [{
name: "quick_reply",
buttonParamsJson: JSON.stringify({
display_text: "ꪶ͢PROXIMA͢ꫂ",
id: `${prefix}editanime-jujutsu`
}),},
],
messageParamsJson:"",
},
},
},
{}
).then((r) => console.log(r))
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: editanime-kimetsu
└─────────────────────────────────────────────────┘
*/
case 'editanime-kimetsu':
reagir(from, "✨")
fonte = ['Instagram', 'Tiktok', 'YouTube', 'Kwai', 'Facebook', 'Internet']
gozeinonear = Math.floor(Math.random() * 1000)
let videossss = await prepareWAMessageMedia({ video: {url: `${zerosite}/random/demon_slayer?apikey=${API_KEY_ZEROTWO}&categoria=demon_slayer`}}, { upload: zerotwo.waUploadToServer })
await zerotwo.relayMessage(from, 
{
interactiveMessage: {
header: {
title: '',
subtitle: '',
hasMediaAttachment: true,
videoMessage: videossss.videoMessage
},
footer: {
text: '',
},
contextInfo: { participant: sender, quotedMessage: info.message, forwardingScore: 999, isForwarded: true, forwardedNewsletterMessageInfo: {newsletterJid: channel, newsletterName: `𝙲𝙾𝙽𝙽𝙴𝙲𝚃𝙴𝙳 𝙲𝙾𝙽𝚃𝙴Ú𝙳𝙾𝚂`}},
body: { text: `❯❯ ZERO TWO - EDIT ANIME ❮❮

❒ৣ͜͡Categoria: Edit Animes
❒ৣ͜͡Fonte: ${fonte[Math.floor(Math.random() * fonte.length)]} 
❒ৣ͜͡Coleção: Zero Two Oficial 
❒ৣ͜͡Curtidas: ${gozeinonear}
${zerosite}
`,
},nativeFlowMessage: {
buttons: [{
name: "quick_reply",
buttonParamsJson: JSON.stringify({
display_text: "ꪶ͢PROXIMA͢ꫂ",
id: `${prefix}editanime-kimetsu`
}),},
],
messageParamsJson:"",
},
},
},
{}
).then((r) => console.log(r))
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: editanime-naruto
└─────────────────────────────────────────────────┘
*/
case 'editanime-naruto':
reagir(from, "✨")
fonte = ['Instagram', 'Tiktok', 'YouTube', 'Kwai', 'Facebook', 'Internet']
gozeinonear = Math.floor(Math.random() * 1000)
let videosssssss = await prepareWAMessageMedia({ video: {url: `${zerosite}/random/narutoedit?apikey=${API_KEY_ZEROTWO}&categoria=narutoedit`}}, { upload: zerotwo.waUploadToServer })
await zerotwo.relayMessage(from, 
{
interactiveMessage: {
header: {
title: '',
subtitle: '',
hasMediaAttachment: true,
videoMessage: videosssssss.videoMessage
},
footer: {
text: '',
},
contextInfo: { participant: sender, quotedMessage: info.message, forwardingScore: 999, isForwarded: true, forwardedNewsletterMessageInfo: {newsletterJid: channel, newsletterName: `𝙲𝙾𝙽𝙽𝙴𝙲𝚃𝙴𝙳 𝙲𝙾𝙽𝚃𝙴Ú𝙳𝙾𝚂`}},
body: { text: `❯❯ ZERO TWO - EDIT ANIME ❮❮

❒ৣ͜͡Categoria: Edit Animes
❒ৣ͜͡Fonte: ${fonte[Math.floor(Math.random() * fonte.length)]} 
❒ৣ͜͡Coleção: Zero Two Oficial 
❒ৣ͜͡Curtidas: ${gozeinonear}
${zerosite}
`,
},nativeFlowMessage: {
buttons: [{
name: "quick_reply",
buttonParamsJson: JSON.stringify({
display_text: "ꪶ͢PROXIMA͢ꫂ",
id: `${prefix}editanime-naruto`
}),},
],
messageParamsJson:"",
},
},
},
{}
).then((r) => console.log(r))
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: editanime-random
└─────────────────────────────────────────────────┘
*/
case 'editanime-random':
reagir(from, "✨")
try {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
//Canal: https://whatsapp.com/channel/0029Va6riekH5JLwLUFI7P2B
const fontes = ['Instagram', 'Tiktok', 'YouTube', 'Kwai', 'Facebook', 'Internet']
const gozeinonear = Math.floor(Math.random() * 1000)
const randomFonte = fontes[Math.floor(Math.random() * fontes.length)]
const videoUrl = `${zerosite}/random/aleatorios?apikey=${API_KEY_ZEROTWO}&categoria=aleatorios`
const response = await axios({url: videoUrl, method: 'GET', responseType: 'arraybuffer'})
const buffer = response.data
const cloudUrl = await uploadToCloudinary(buffer)
await sendRouletteButton2(from, {video: { url: cloudUrl }, caption: `❯❯ ZERO TWO - EDIT ANIME ❮❮\n\n❒ৣ͜͡Categoria: Edit Animes\n❒ৣ͜͡Fonte: ${randomFonte}\n❒ৣ͜͡Coleção: Zero Two Oficial\n❒ৣ͜͡Curtidas: ${gozeinonear}\n${zerosite}`, footer: 'Zero Two Bot'}, zerotwo, sender, [{type: 'copy_url', text: '🔗 ABRIR SITE', url: cloudUrl}], selolucas)
} catch (e) {
console.log(`Erro no comando 'editanime-random':`, e)
zerotwo.sendMessage(from, {text: '⚠️ Ocorreu um erro ao processar seu pedido. Tente novamente mais tarde!'}, { quoted: selolucas })
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: editanime-zerotwo
└─────────────────────────────────────────────────┘
*/
case 'editanime-zerotwo':
reagir(from, "✨")
fonte = ['Instagram', 'Tiktok', 'YouTube', 'Kwai', 'Facebook', 'Internet']
gozeinonear = Math.floor(Math.random() * 1000)
let videosssssssss = await prepareWAMessageMedia({ video: {url: `${zerosite}/random/zerotwo?apikey=${API_KEY_ZEROTWO}&categoria=zerotwo`}}, { upload: zerotwo.waUploadToServer })
await zerotwo.relayMessage(from, 
{
interactiveMessage: {
header: {
title: '',
subtitle: '',
hasMediaAttachment: true,
videoMessage: videosssssssss.videoMessage
},
footer: {
text: '',
},
contextInfo: { participant: sender, quotedMessage: info.message, forwardingScore: 999, isForwarded: true, forwardedNewsletterMessageInfo: {newsletterJid: channel, newsletterName: `𝙲𝙾𝙽𝙽𝙴𝙲𝚃𝙴𝙳 𝙲𝙾𝙽𝚃𝙴Ú𝙳𝙾𝚂`}},
body: { text: `❯❯ ZERO TWO - EDIT ANIME ❮❮

❒ৣ͜͡Categoria: Edit Animes
❒ৣ͜͡Fonte: ${fonte[Math.floor(Math.random() * fonte.length)]} 
❒ৣ͜͡Coleção: Zero Two Oficial 
❒ৣ͜͡Curtidas: ${gozeinonear}
${zerosite}
`,
},nativeFlowMessage: {
buttons: [{
name: "quick_reply",
buttonParamsJson: JSON.stringify({
display_text: "ꪶ͢PROXIMA͢ꫂ",
id: `${prefix}editanime-zerotwo`
}),},
],
messageParamsJson:"",
},
},
},
{}
).then((r) => console.log(r))
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: emoji2
└─────────────────────────────────────────────────┘
*/
case 'emoji2':
var [emj1, emj2] = q.trim().split("+")
if(!q.includes("+")) return reply(`Olá, está faltando o +\nExemplo: ${prefix+command} 👿+😇`)
try {
reply(`❪∘̥⃟⸽⃟𝙼𝚒𝚜𝚝𝚞𝚛𝚊𝚗𝚍𝚘┋${emj1} e ${emj2}┋𝙴𝚖𝚘𝚓𝚒𝚜∘̥⃟৴▸`)
sendStickerFromUrl(from, `${zerosite}/api/emojimix?emoji1=${encodeURI(emj1)}&emoji2=${encodeURI(emj2)}&apikey=`+API_KEY_ZEROTWO)
} catch (e) {
if(JSON.stringify(e).includes(API_KEY_ZEROTWO)) {
return reply("A api caiu ou não foi possivel executar esta ação., espere retornar") 
} else {
reply('*Não consegui combinar esses emojis* 🙇🏻‍♂️')
}
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: encurtalink
└─────────────────────────────────────────────────┘
*/
case 'encurtalink':
if (!isChatOfc && !isAdvencedVip(sender) && !isAdvencedGroupVip(from)) return reply(enviar.msg.vip)
if(!q) return reply(`Ex: ${prefix+command} ${zerosite}`)
try {
link = q
lulu = await axios.get(`https://tinyurl.com/api-create.php?url=${link}`)
reply(`${lulu.data}`)
} catch (e) {
emror = String(e)
reply(`${e}`)
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: episodios-recentes
└─────────────────────────────────────────────────┘
*/
case 'episodios-recentes':
reagir(from, react2)
try {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
ABC = await fetchJson(zerosite+`/api/doramas/new-episodes?apikey=`+API_KEY_ZEROTWO)
caixa = []
for(i of ABC.resultado) {
caixa.push({name: `🎬 ${i.title}`, title: i.seasonEpisode, body: `Lançado: ${i.releaseInfo}`, command: prefix+`info-serie `+i.link})
}
if(caixa.length <= 0) return reply(`Sem resultados disponíveis..`)
sendRouletteButton(from, {text: `📺 DORAMAS - Exibindo ${caixa.length} resultados 🕹`, footer: `Escolha um episódio para ver...`}, zerotwo, sender, [{type: `list`, title: `❒ RESULTADOS ❒ `, rowId: [{title: NomeDoBot, options: caixa}]}], selolucas)
} catch (e) {
console.log(e)
return reply(`Erro 404`)
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: f
└─────────────────────────────────────────────────┘
*/
case 'f':
reagir(from, "✅")
//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
var RSM = info.message?.extendedTextMessage?.contextInfo?.quotedMessage
var boij = RSM?.imageMessage || info.message?.imageMessage || RSM?.viewOnceMessageV2?.message?.imageMessage || info.message?.viewOnceMessageV2?.message?.imageMessage || info.message?.viewOnceMessage?.message?.imageMessage || RSM?.viewOnceMessage?.message?.imageMessage
var boij2 = RSM?.videoMessage || info.message?.videoMessage || RSM?.viewOnceMessageV2?.message?.videoMessage || info.message?.viewOnceMessageV2?.message?.videoMessage || info.message?.viewOnceMessage?.message?.videoMessage || RSM?.viewOnceMessage?.message?.videoMessage
if(boij) {
var pack = permuteFigPackName(`❪👤𝚄𝚜𝚞á𝚛𝚒𝚘 (𝚊)ฺ࣭࣪͘ꕸ▸
❪🤖𝙱𝚘𝚝ฺ࣭࣪͘ꕸ▸
❪👑𝙳𝚘𝚗𝚘ฺ࣭࣪͘ꕸ▸
❪🌐𝚂𝚒𝚝𝚎ฺ࣭࣪͘ꕸ▸`)
var author2 = permuteFigAuthorName(`${pushname}
${NomeDoBot}
${NickDono}
${zerosite}`)
reply(`❪∘̥⃟⸽⃟𝙲𝚘𝚗𝚟𝚎𝚛𝚝𝚎𝚗𝚍𝚘 𝙴𝚖 𝙵𝚒𝚐𝚞𝚛𝚒𝚗𝚑𝚊∘̥⃟৴▸`)
owgi = await getFileBuffer(boij, 'image')
let encmediaa = await sendImageAsSticker(zerotwo, from, owgi, info, { packname:pack, author:author2})
await DLT_FL(encmediaa)
} else if(boij2 && boij2?.seconds < 11) {
var pack = permuteFigPackName(`❪👤𝚄𝚜𝚞á𝚛𝚒𝚘 (𝚊)ฺ࣭࣪͘ꕸ▸
❪🤖𝙱𝚘𝚝ฺ࣭࣪͘ꕸ▸
❪👑𝙳𝚘𝚗𝚘ฺ࣭࣪͘ꕸ▸
❪🌐𝚂𝚒𝚝𝚎ฺ࣭࣪͘ꕸ▸`)
var author2 = permuteFigAuthorName(`${pushname}
${NomeDoBot}
${NickDono}
${zerosite}`)
reply(`❪∘̥⃟⸽⃟𝙲𝚘𝚗𝚟𝚎𝚛𝚝𝚎𝚗𝚍𝚘 𝙴𝚖 𝙵𝚒𝚐𝚞𝚛𝚒𝚗𝚑𝚊∘̥⃟৴▸`)
owgi = await getFileBuffer(boij2, 'video')
let encmedia = await sendVideoAsSticker(zerotwo, from, owgi, info, { packname:pack, author:author2})
await DLT_FL(encmedia)
} else {
reply(`Marque uma imagem ou vídeo de até 10 segundos com o comando ${prefix+command}`)
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: faceaudio
└─────────────────────────────────────────────────┘
*/
case 'faceaudio':
try {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
if(!q.includes("facebook") && !q.includes("fb.watch")) return reply(`Exemplo: ${prefix+command} o link do Facebook`)
ABC = await fetchJson(`${zerosite}/download/facebook2?url=${q}&apikey=`+API_KEY_ZEROTWO)
reply(`❪𝙴𝚗𝚟𝚒𝚊𝚗𝚍𝚘 𝚂𝚎𝚞 Á𝚞𝚍𝚒𝚘ฺ࣭࣪͘ꕸ▸`)
zerotwo.sendMessage(from, {audio: {url: ABC.resultado.media.url}, mimetype: 'audio/mp4', ptt: true}).catch(e => {
return reply("Erro..")
})
} catch (e) {
console.log(e)
return reply("Erro..")
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: facebook3
└─────────────────────────────────────────────────┘
*/
case 'facebook3':
try {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
if(!q.includes("facebook") && !q.includes("fb.watch")) return reply(`Exemplo: ${prefix+command} o link do Facebook`)
ABC = await fetchJson(`${zerosite}/download/facebook2?url=${q}&apikey=`+API_KEY_ZEROTWO)
reply(`❪𝙴𝚗𝚟𝚒𝚊𝚗𝚍𝚘 𝚂𝚎𝚞 𝚅í𝚍𝚎𝚘ฺ࣭࣪͘ꕸ▸`)
zerotwo.sendMessage(from, {video: {url: ABC.resultado.media.url}, caption: ABC.resultado.description, mimetype: "video/mp4"}).catch(e => {
return reply("Erro..")
})
} catch (e) {
console.log(e)
return reply("Erro..")
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: facevideo
└─────────────────────────────────────────────────┘
*/
case 'facevideo':
try {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
//Canal: https://whatsapp.com/channel/0029Va6riekH5JLwLUFI7P2B
if (!q.includes("facebook") && !q.includes("fb.watch")) {
return reply(`Exemplo: ${prefix + command} o link do Facebook`)
}
const API_URL = `${zerosite}/download/facebook?url=${q}&apikey=${API_KEY_ZEROTWO}`
const response = await fetch(API_URL)
if (!response.ok) {
throw new Error("Erro na chamada à API")
}
const result = await response.json()
if (!result.resultado || result.resultado.length === 0) {
throw new Error("Nenhum dado retornado pela API.")
}
const videoHD = result.resultado.find(video => video.resolution.includes("HD"))
const videoSD = result.resultado.find(video => video.resolution.includes("SD"))
if (!videoHD && !videoSD) {
throw new Error("Nenhum vídeo disponível para download.")
}
const selectedVideo = videoHD || videoSD
reply(`❪𝙴𝚗𝚟𝚒𝚊𝚗𝚍𝚘 𝚂𝚎𝚞 𝚅í𝚍𝚎𝚘ฺ࣭࣪͘ꕸ▸`)
await zerotwo.sendMessage(from, { video: { url: selectedVideo.url }, caption: `❯❯〘 BAIXADO PELA ZERO TWO 〙❮❮`, mimetype: "video/mp4" }, {quoted: info})
await sleep(2000)
reply(`❪𝙴𝚗𝚟𝚒𝚊𝚗𝚍𝚘 𝙾 𝙰𝚞𝚍𝚒𝚘ฺ࣭࣪͘ꕸ▸`)
await zerotwo.sendMessage(from, { audio: { url: selectedVideo.url }, mimetype: 'audio/mpeg', ptt: true}, {quoted: info})
} catch (e) {
console.error(e)
return reply("Erro ao processar a solicitação.")
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: ffavatar2
└─────────────────────────────────────────────────┘
*/
case 'ffavatar2':
try {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
//Canal: https://whatsapp.com/channel/0029Va6riekH5JLwLUFI7P2B
const textin = args.join(" ")
if (!textin) return reply("KD o texto?")
reply(`ৎ❥̤֟٭ۣۜ𝙶𝚎𝚛𝚊𝚗𝚍𝚘 𝚂𝚞𝚊 𝙻𝚘𝚐𝚘🍧.ᩦ୭✧ࣶᭂ`)
const response = await fetch(`${zerosite}/api/ephoto/ffavatar?texto=${encodeURIComponent(textin)}&apikey=${API_KEY_ZEROTWO}`)
if (!response.ok) throw new Error("Erro ao acessar a API.")
const buffer = await response.arrayBuffer()
await zerotwo.sendMessage(from, { image: Buffer.from(buffer) }, { quoted: selolucas })
} catch (e) {
console.log(e)
reply("Erro ao criar sua logo! Tente novamente mais tarde.")
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: figroblox
└─────────────────────────────────────────────────┘
*/
case 'figroblox':
if(!isGroup) return mention(privateCmd(sender, prefix+command, `"não encontrado"`, 0))
if(!q) return reply(`Insira a quantidade de figurinhas que você deseja receber, exemplo: ${prefix + command} 2`)
if(!Number(args[0]) || Number(q.trim()) > 10 && !isOwner) return reply(`O máximo de figurinhas é 10`)
reply(`ヅ _Calma ae ${pushname}, enviando ${args[0]} figurinha${Number(args[0]) > 1 ? 's' : ''} no seu privado..._ 亗`)
for (i = 0; i < Number(args[0]); i++) {
await sleep(1000)
sendStickerFromUrl(sender, `${zerosite}/sticker/${command}?apikey=`+API_KEY_ZEROTWO)
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: figurinhas
└─────────────────────────────────────────────────┘
*/
case 'figurinhas':
if (!isGroup) return mention(privateCmd(sender, prefix + command, `"não encontrado"`, 0))
if (!q) return reply(`Insira a quantidade de figurinhas que você deseja receber, exemplo: ${prefix + command} 2`)
if (!Number(args[0]) || Number(q.trim()) > 15 && !isOwner) 
return reply(`O máximo de figurinhas é 15`)
reply(`ヅ _Calma ae ${pushname}, enviando ${args[0]} figurinha${Number(args[0]) > 1 ? 's' : ''} no seu privado..._ 亗`)
async function FigurinhasAleatorias() {
const apiUrl = `${zerosite}/api/figurinhas?apikey=${API_KEY_ZEROTWO}`
try {
await zerotwo.sendMessage(sender, { sticker: { url: apiUrl } }, {quoted: selolucas })
} catch (err) {
console.error("Erro ao enviar a figurinha:", err)
reply("Houve um erro ao tentar enviar as figurinhas.")
}
}
(async () => {
for (let i = 0; i < Number(args[0]); i++) {
await sleep(2000)
await FigurinhasAleatorias()
}
})()
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: figurinhas2
└─────────────────────────────────────────────────┘
*/
case 'figurinhas2':
if(!isGroup) return mention(privateCmd(sender, prefix+command, `"não encontrado"`, 0))
if(!q) return reply(`Insira a quantidade de figurinhas que você deseja receber, exemplo: ${prefix + command} 2`)
if(!Number(args[0]) || Number(q.trim()) > 10 && !isOwner) return reply(`O máximo de figurinhas é 10`)
reply(`ヅ _Calma ae ${pushname}, enviando ${args[0]} figurinha${Number(args[0]) > 1 ? 's' : ''} no seu privado..._ 亗`)
for (i = 0; i < Number(args[0]); i++) {
await sleep(1000)
sendStickerFromUrl(sender, `${zerosite}/api/figurinhas2?apikey=`+API_KEY_ZEROTWO)
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: frozen2
└─────────────────────────────────────────────────┘
*/
case 'frozen2':
try {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
//Canal: https://whatsapp.com/channel/0029Va6riekH5JLwLUFI7P2B
const textin = args.join(" ")
if (!textin) return reply("KD o texto?")
reply(`ৎ❥̤֟٭ۣۜ𝙶𝚎𝚛𝚊𝚗𝚍𝚘 𝚂𝚞𝚊 𝙻𝚘𝚐𝚘🍧.ᩦ୭✧ࣶᭂ`)
const response = await fetch(`${zerosite}/api/ephoto/frozen?texto=${encodeURIComponent(textin)}&apikey=${API_KEY_ZEROTWO}`)
if (!response.ok) throw new Error("Erro ao acessar a API.")
const buffer = await response.arrayBuffer()
await zerotwo.sendMessage(from, { image: Buffer.from(buffer) }, { quoted: selolucas })
} catch (e) {
console.log(e)
reply("Erro ao criar sua logo! Tente novamente mais tarde.")
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: fs
└─────────────────────────────────────────────────┘
*/
case 'fs':
if(!q) return reply("Retorne um título para ser pesquisado, ex: "+prefix+command+" amor")
try {
ABC = await fetchJson(`${zerosite}/api/pesquisa/pensador?text=${encodeURI(q)}&apikey=`+API_KEY_ZEROTWO)
luquinhas = ABC.resultado[Math.floor(Math.random()*ABC.resultado.length)]
zerotwo.sendMessage(from, {image: {url: luquinhas.image}, caption: luquinhas.frase+`\n`+`- `.repeat(20)+`\n`+luquinhas.compartilhamentos}, {quoted: selolucas})
} catch(e) {
console.log(e)
reply("Não foi possível achar frases motivacionais com o título \""+q+"\"")
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: funcionarios
└─────────────────────────────────────────────────┘
*/
case 'funcionarios': 
{ //By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
//Canal: https://whatsapp.com/channel/0029Va6riekH5JLwLUFI7P2B
if (!isChatOfc && !isAdvencedVip(sender) && !isAdvencedGroupVip(from)) return reply(enviar.msg.vip)
if (!q) {
let exampleUsage = {
nome: `${prefix}nome Jair Messias Bolsonaro`, nome2: `${prefix}nome2 Jair Messias Bolsonaro`, nome3: `${prefix}nome3 Jair Messias Bolsonaro`, nome4: `${prefix}nome4 Jair Messias Bolsonaro`, telefone: `${prefix}telefone 11999999999`, telefone2: `${prefix}telefone2 11999999999`, telefonefixo: `${prefix}telefonefixo 1133334444`, cpf: `${prefix}cpf 12345678909`, cpf2: `${prefix}cpf2 12345678909`, cpf3: `${prefix}cpf3 12345678909`, cpf4: `${prefix}cpf4 12345678909`, cpf5: `${prefix}cpf5 12345678909`, placa: `${prefix}placa ABC1234`, bin: `${prefix}bin 123456`, site: `${prefix}site www.exemplo.com`, cep: `${prefix}cep 12345678`, vizinhos: `${prefix}vizinhos 12345678`, cnpj: `${prefix}cnpj 12345678000195`, score: `${prefix}score 12345678909`, titulo: `${prefix}titulo 123456789012`, email: `${prefix}email exemplo@email.com`, vacina: `${prefix}vacina 12345678909`, parentes: `${prefix}parentes Jair Messias Bolsonaro`, rg: `${prefix}rg 12345678`, rg2: `${prefix}rg2 12345678`, senha: `${prefix}senha Jair Messias Bolsonaro`, mae: `${prefix}mae Nome da Mãe`, pai: `${prefix}pai Nome do Pai`, chassi: `${prefix}chassi ABC123456789`, motor: `${prefix}motor ABC123456789`, beneficios: `${prefix}beneficios 12345678909`, impostos: `${prefix}impostos 12345678909`, nascimento: `${prefix}nascimento 01/01/2000`, pfix: `${prefix}pfix 1133334444`, cns: `${prefix}cns 123456789012345`, cns2: `${prefix}cns2 123456789012345`, correios: `${prefix}correios 12345678`, radar: `${prefix}radar ABC1234`, dominio: `${prefix}dominio www.exemplo.com`, internet: `${prefix}internet www.exemplo.com`, compras: `${prefix}compras 12345678909`, cnh: `${prefix}cnh 12345678909`, funcionarios: `${prefix}funcionarios Nome da Empresa`
}
return reply(`Para usar este comando, insira o dado que deseja pesquisar.\nExemplo de uso: ${exampleUsage[command]}`)
}
let { key } = await zerotwo.sendMessage(from, { text: enviar.msg.consulta }, { quoted: selolucas })
await sleep(1000)
try {
const consulta = encodeURI(rmLetras(q))
const API_URL = `${zerosite}/consultas/${command}?query=${consulta}&apikey=` + API_KEY_ZEROTWO
const response = await fetch(API_URL)
const ABC = await response.json()
if (!ABC || typeof ABC !== 'object' || !ABC.resultado) {
return await zerotwo.sendMessage(from, { text: `⚠️ *NÃO ENCONTRADO* ⚠️`, edit: key }, { quoted: selolucas })
}
const folderPath = './consultas'
await fs.promises.mkdir(folderPath, { recursive: true })
let thumbnail = await getBuffer(links.logocapa)
const contextInfo = { mentionedJid: [sender], externalAdReply: { showAdAttribution: true, mediaType: 'VIDEO', mediaUrl: null, title: `💞 ${NomeDoBot} 💞\n》ｃｌｉｃｋ ａｑｕｉ《`, body: null, sourceUrl: links.linkss, thumbnail: thumbnail }}
let txt = `
==============================
${ABC.by}
==============================

${ABC.resultado}

👤 *for* ${pushname}
🤖 *by* ${NomeDoBot}`
const filePath = `${folderPath}/resultado_consulta_${command}.txt`
await fs.promises.writeFile(filePath, txt)
const fileData = await fs.promises.readFile(filePath)
await zerotwo.sendMessage(from, { document: fileData, fileName: `resultado_consulta_${command}.txt`, mimetype: 'text/plain', contextInfo }, { quoted: selolucas })
await fs.promises.unlink(filePath).catch(console.error)
} catch (e) {
console.log(e)
await zerotwo.sendMessage(from, { text: `📵 Comando usado de forma errada ou possível erro na busca de dados do sistema 💖`, edit: key }, { quoted: selolucas })
}
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: gemini
└─────────────────────────────────────────────────┘
*/
case 'gemini':
if (!q) return reply(`🌟 *Atenção:* Por favor, informe sua pergunta para que o Gemini possa ajudar. Você também pode mencionar uma imagem com o comando e fazer uma pergunta ao Gemini sobre a imagem.\n\n*• Exemplo:* ${prefix + command} Olá, tudo bem?\n\n*• Sobre:* Este comando utiliza o modelo Gemini-pro.`)
try {
const prompt = q
let imageUrl = null
if (isQuotedImage || isMedia) {
let post
if (isQuotedImage) {
post = JSON.parse(JSON.stringify(info).replace('quotedM', 'm')).message.extendedTextMessage.contextInfo.message.imageMessage
} else if (isMedia) {
post = info.message.imageMessage
}
const imagem = await downloadContentFromMessage(post, 'image')
if (!imagem || imagem.length === 0) {
return reply("😔 _Erro ao processar a imagem. Por favor, tente novamente._")
}
let buffer = Buffer.from([])
for await (const chunk of imagem) {
buffer = Buffer.concat([buffer, chunk])
}
imageUrl = await upload(buffer)
if (!imageUrl) {
return reply("😔 _Erro ao obter o link da imagem após o upload._")
}
}
const apiUrl = `${zerosite}/gemini/texto/imagem?query=${encodeURIComponent(prompt)}${imageUrl ? `&imageUrl=${encodeURIComponent(imageUrl)}` : ''}&apikey=${API_KEY_ZEROTWO}`
const { data } = await axios.get(apiUrl)
if (data.status) {
const caption = `🌟 *Gemini Respondeu:*\n\n${data.resposta}`
if (data.url) {
zerotwo.sendMessage(from, { image: { url: data.url }, caption: caption }, {quoted: selolucas})
} else {
reply(caption)
}
} else {
reply("😔 _Erro ao obter resposta da API Gemini._")
}
} catch (e) {
console.error(e)
return reply("😔 _Ocorreu um erro ao processar sua solicitação. Por favor, tente novamente._")
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: gemini2
└─────────────────────────────────────────────────┘
*/
case 'gemini2':
if (!isVip && !isGroup) return reply(enviar.msg.pvnotvip)
reagir(from, "🌐")
if (!q) return reply(`Pergunte algo, e o ${command} irá responder...`)
try {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
reply("*Aguarde enquanto eu pesquiso...* 🫡")
const response = await fetchJson(`${zerosite}/api/gemini?query=${encodeURIComponent(q)}&apikey=${API_KEY_ZEROTWO}`)
// console.log('Resposta da API:', response)
if (!response.resultado || typeof response.resultado !== 'object') {
return reply('Nenhum resultado encontrado.')
}
const imageUrl = /^https?:\/\//i.test(response.resultado.Image) ? response.resultado.Image : 'https://raw.githubusercontent.com/Otakump4/links-gerados/main/IMAGENS/gemini.jpeg'
let caption = '*Resultados Encontrados:*\n\n'
if (response.resultado.Abstract) caption += `*Resumo:* ${response.resultado.Abstract}\n`
if (response.resultado.AbstractURL) caption += `*Link da Fonte:* ${response.resultado.AbstractURL}\n`
if (response.resultado.Answer) caption += `*Resposta:* ${response.resultado.Answer}\n`
if (response.resultado.Definition) caption += `*Definição:* ${response.resultado.Definition}\n`
if (response.resultado.DefinitionURL) caption += `*Link da Definição:* ${response.resultado.DefinitionURL}\n`
if (response.resultado.Entity) caption += `*Entidade:* ${response.resultado.Entity}\n`
if (response.resultado.Heading) caption += `*Cabeça:* ${response.resultado.Heading}\n`
if (response.resultado.OfficialWebsite) caption += `*Site Oficial:* ${response.resultado.OfficialWebsite}\n`
if (response.resultado.Type) caption += `*Tipo:* ${response.resultado.Type}\n`
caption += `*Pergunta:* ${q}`
await zerotwo.sendMessage(from, {image: { url: imageUrl }, caption: caption.trim()}, { quoted: selolucas })
} catch (e) {
console.log(e)
reply('Ocorreu um erro ao tentar processar a solicitação.')
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: gemini3
└─────────────────────────────────────────────────┘
*/
case 'gemini3':
if (!isVip && !isGroup) return reply(enviar.msg.pvnotvip)
reagir(from, "🌐")
if (!q) return reply(`Pergunte algo, e o ${command} irá responder...`)
try {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
const limparTexto = (texto) => {
return texto.normalize("NFD").replace(/[\u0300-\u036f]/g, "").replace(/[^\w\s]/gi, '')
}
const perguntaLimpa = limparTexto(q)
const traducaoPergunta = await fetchJson(`${zerosite}/api/info/translate?texto=${encodeURIComponent(perguntaLimpa)}&ling=en&apikey=${API_KEY_ZEROTWO}`)
if (!traducaoPergunta || !traducaoPergunta.result) {
return reply('Erro ao tentar traduzir a pergunta.')
}
const perguntaEmIngles = traducaoPergunta.result
const geminiResponse = await fetchJson(`${zerosite}/api/gemini/v2?query=${encodeURIComponent(perguntaEmIngles)}&apikey=${API_KEY_ZEROTWO}`)
if (!geminiResponse.success) {
return reply('Nenhum resultado encontrado.')
}
const respostaGemini = geminiResponse.originalResponse || 'Nenhuma resposta encontrada.'
const traducaoResposta = await fetchJson(`${zerosite}/api/info/translate?texto=${encodeURIComponent(respostaGemini)}&ling=pt&apikey=${API_KEY_ZEROTWO}`)
if (!traducaoResposta || !traducaoResposta.result) {
return reply('Erro ao tentar traduzir a resposta.')
}
const respostaTraduzida = traducaoResposta.result
const imageUrl = 'https://raw.githubusercontent.com/Otakump4/links-gerados/main/IMAGENS/gemini.jpeg'
let caption = '*Resultado:*\n\n'
caption += `*Pergunta:* ${geminiResponse.originalPrompt || q}\n`
caption += '*Resposta:*\n\n'
const respostaFormatada = respostaTraduzida
.replace(/(\*\*.+?\*\*)/g, '\n\n$1\n\n')
.replace(/\*\*(.*?)\*\*/g, '*$1*')
.trim()
caption += respostaFormatada
await zerotwo.sendMessage(from, { image: { url: imageUrl }, caption: caption.trim() }, { quoted: selolucas })
} catch (e) {
console.log("Erro durante o processo:", e)
reply('Ocorreu um erro ao tentar processar a solicitação.')
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: gitbot
└─────────────────────────────────────────────────┘
*/
case 'gitbot':
reply(`🌐 *Git disponível no site:*
${zerosite}/docs`)
break

//========(FUNÇÕES-PREMIUM-AQUI)=======\\

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: glitter
└─────────────────────────────────────────────────┘
*/
case 'glitter':
try {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
//Canal: https://whatsapp.com/channel/0029Va6riekH5JLwLUFI7P2B
const textin = args.join(" ")
if (!textin) return reply("KD o texto?")
if (!textin.includes("/")) 
return reply(`Cade a / precisa dela para a separação..\nExemplo: ${prefix + command} zero/two`)
const [txt1, txt2] = textin.split("/")
if (!txt1 || !txt2) 
return reply("Você precisa informar dois textos separados por `/`.\nExemplo: `Texto1/Texto2`")
reply(`ৎ❥̤֟٭ۣۜ𝙶𝚎𝚛𝚊𝚗𝚍𝚘 𝚂𝚞𝚊 𝙻𝚘𝚐𝚘🍧.ᩦ୭✧ࣶᭂ`)
const response = await fetch(`${zerosite}/api/ephoto/${command}?texto=${encodeURIComponent(txt1)}&texto2=${encodeURIComponent(txt2)}&apikey=${API_KEY_ZEROTWO}`)
if (!response.ok) throw new Error("Erro ao acessar a API.")
const buffer = await response.arrayBuffer()
await zerotwo.sendMessage(from, { image: Buffer.from(buffer) }, { quoted: selolucas })
} catch (e) {
console.log(e)
reply("Erro ao criar sua logo! Tente novamente mais tarde.")
}
break

//=============(LOGOS DE 1 TEXTO)=============\\

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: googleimg
└─────────────────────────────────────────────────┘
*/
case 'googleimg':
if(!q) return reply(`Exemplo: ${prefix+command} naruto`)
try {
ABC = await fetchJson(`${zerosite}/api/gimage?txt=${encodeURI(q)}&apikey=`+API_KEY_ZEROTWO)
luquinhas = ABC.result[Math.floor(Math.random() * ABC.result.length)]
zerotwo.sendMessage(from, {image: {url: luquinhas.url}, caption: `『 ${luquinhas.title} 』`}, {quoted: selolucas}).catch(() => {
return reply("Erro..")
})
} catch (e) {
return reply("Erro..")
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: gpt
└─────────────────────────────────────────────────┘
*/
case 'gpt':
if (!isVip && !isGroup) return reply(enviar.msg.pvnotvip)
reagir(from, "🌐")
if (!q) return reply(`Pergunte algo, e o ${command} irá responder...`)
try {
reply("*Aguarde enquanto eu pesquiso...* 🫡")
const ABC = await fetchJson(`${zerosite}/api/ia/gpt?query=${encodeURIComponent(q)}&apikey=${API_KEY_ZEROTWO}`)
zerotwo.sendMessage(from, {image: {url: `https://telegra.ph/file/150adfa5f55028be88a67.jpg`}, contextInfo: { mentionedJid: [sender], externalAdReply: { showAdAttribution: true, mediaType: 'VIDEO', mediaUrl: null, title: `💞 ${NomeDoBot} 💞\n》🅒🅛🅘🅠🅤🅔 🅐🅠🅤🅘《`, body: null, sourceUrl: links.linkss, mediaUrl: 'https://youtube.com/@Otaku.mp4', thumbnail: await getBuffer(links.logocapa)}, forwardingScore: 1000000, isForwarded: true, forwardedNewsletterMessageInfo: { newsletterJid: channel, newsletterName: `𝙲𝙾𝙽𝙽𝙴𝙲𝚃𝙴𝙳 𝙲𝙾𝙽𝚃𝙴Ú𝙳𝙾𝚂` }}, caption: `> ╭━━━❀ ZERO TWO - OFICIAL ❀━━━╮\n\n> ${ABC.resultado}\n\n> ╰━━━━━━━━━━━━━━━━━━━━━━╯`}, {quoted: selolucas})
} catch (e) {
console.log(e)
reply('Ocorreu um erro ao tentar processar a solicitação.')
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: gpt4
└─────────────────────────────────────────────────┘
*/
case 'gpt4':
if (!isVip && !isGroup) return reply(enviar.msg.pvnotvip)
reagir(from, "🌐")
if (!q) return reply(`Pergunte algo, e o ${command} irá responder...`)
try {
reply("*Aguarde enquanto eu pesquiso...* 🫡")
const ABC = await fetchJson(`${zerosite}/api/ia/gpt4?query=${encodeURIComponent(q)}&apikey=${API_KEY_ZEROTWO}`)
zerotwo.sendMessage(from, {image: {url: `https://telegra.ph/file/150adfa5f55028be88a67.jpg`}, contextInfo: { mentionedJid: [sender], externalAdReply: { showAdAttribution: true, mediaType: 'VIDEO', mediaUrl: null, title: `💞 ${NomeDoBot} 💞\n》🅒🅛🅘🅠🅤🅔 🅐🅠🅤🅘《`, body: null, sourceUrl: links.linkss, mediaUrl: 'https://youtube.com/@Otaku.mp4', thumbnail: await getBuffer(links.logocapa)}, forwardingScore: 1000000, isForwarded: true, forwardedNewsletterMessageInfo: { newsletterJid: channel, newsletterName: `𝙲𝙾𝙽𝙽𝙴𝙲𝚃𝙴𝙳 𝙲𝙾𝙽𝚃𝙴Ú𝙳𝙾𝚂` }}, caption: `> ╭━━━❀ ZERO TWO - OFICIAL ❀━━━╮\n\n> ${ABC.resultado}\n\n> ╰━━━━━━━━━━━━━━━━━━━━━━╯`}, {quoted: selolucas})
} catch (e) {
console.log(e)
reply('Ocorreu um erro ao tentar processar a solicitação.')
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: gptvoz
└─────────────────────────────────────────────────┘
*/
case 'gptvoz':
setTimeout(() => {reagir(from, `${reassao}`)}, 100)
if(!q) return reply("Você esqueceu de perguntar ao lado do comando.")
reply(`Estou processando sua pergunta. Isso pode levar alguns segundos...`)
nznk = await fetchJson(`${zerosite}/api/ia/gpt?query=${q}&apikey=`+API_KEY_ZEROTWO)
const gpts = require('./armor/funcoes/gtts')('pt')
ranm = getRandom('.mp3')
rano = getRandom('.ogg')
gpts.save(ranm, `${nznk.resultado}`, function() {
exec(`ffmpeg -i ${ranm} -ar 48000 -vn -c:a libopus ${rano}`, (err) => {
zerotwo.sendMessage(from, {audio: fs.readFileSync(ranm), ptt:true, mimetype: "audio/mpeg"}, {quoted: selolucas})
DLT_FL(ranm)
DLT_FL(rano)
})
})
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: gtast
└─────────────────────────────────────────────────┘
*/
case 'gtast':
if (!isVip && !isGroup) return reply(enviar.msg.vip)
if (!q) return reply(`Exemplo:\n\n${prefix + command} Seu Texto`)
if (!q.includes("/")) return reply(`Ex: ${prefix + command} zero two/luquinhas`)
var [q1, q2] = q.split("/")
if (q1.length > 25 || q2.length > 25) return reply("Texto muito grande")
try {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄I
const response = await fetch(`${zerosite}/api/gtapassed?txt1=${encodeURI(q1)}&txt2=${encodeURI(q2)}&apikey=${API_KEY_ZEROTWO}`)
if (!response.ok) throw new Error('Erro ao obter o sticker')
const buffer = await response.arrayBuffer()
const stickerBuffer = Buffer.from(buffer)
await zerotwo.sendMessage(from, { sticker: stickerBuffer }, { quoted: selolucas })
} catch (e) {
console.log(e)
reply("Erro ao criar o sticker.")
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: happymod
└─────────────────────────────────────────────────┘
*/
case 'happymod':
if (!q) return reply(`Cadê o nome do app? *Use como exemplo:* ${prefix + command} Pou.`)
try {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
await reagir(from, '⌛')
const response = await axios.get(`${zerosite}/api/happymod?nome=${encodeURIComponent(q)}&apikey=${API_KEY_ZEROTWO}`)
if (response.data.status !== 200 || response.data.resultado.length === 0) {
return reply('Nenhum resultado encontrado.')
}
const app = response.data.resultado[0]
const appIconResponse = await axios.get(app.icon, { responseType: 'arraybuffer' })
const appIcon = Buffer.from(appIconResponse.data, 'binary')
const downloadLinkResponse = await axios.get(`https://tinyurl.com/api-create.php?url=${app.link}`)
const downloadLink = downloadLinkResponse.data
await zerotwo.sendMessage(from, {image: appIcon, caption: `🔍 *Aplicativo Encontrado!*\n\n📱 *Nome*: ${app.nome}\n📥 *Download*: ${downloadLink}`, contextInfo: {mentionedJid: [from], participant: from, quotedMessage: {conversation: `Aqui está o que você pediu, ${from}!`}, externalAdReply: {title: `🔍 Aplicativo: ${app.nome}`, thumbnail: appIcon, mediaType: 1, mediaUrl: downloadLink, sourceUrl: downloadLink}}}, { quoted: selolucas })
await reagir(from, '✅')
} catch (error) {
console.log(error)
return reply('Ocorreu um erro ao buscar o app.')
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: hdvideo
└─────────────────────────────────────────────────┘
*/
case 'hdvideo':
try {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
if ((isMedia && info.message.videoMessage) || isQuotedVideo) {
let post = isQuotedVideo
? JSON.parse(JSON.stringify(selolucas).replace('quotedM', 'm')).message.extendedTextMessage.contextInfo.message.videoMessage : info.message.videoMessage
reply('😈 _Processando seu vídeo! Aguarde..._')
const videoStream = await downloadContentFromMessage(post, 'video')
let videoBuffer = Buffer.from([])
for await (const chunk of videoStream) {
videoBuffer = Buffer.concat([videoBuffer, chunk])
}
const videoLink = await upload(videoBuffer)
const response = await fetch(`${zerosite}/api/ia/tohdvideo?link=${videoLink}&apikey=${API_KEY_ZEROTWO}`)
const arrayBuffer = await response.arrayBuffer()
const buffer = Buffer.from(arrayBuffer)
const tempFilePath = path.join(os.tmpdir(), 'processed-video.mp4')
fs.writeFileSync(tempFilePath, buffer)
await zerotwo.sendMessage(from, { video: { url: tempFilePath } }, { quoted: selolucas })
fs.unlinkSync(tempFilePath)
} else {
reply('😈 _Marque o vídeo para eu poder aplicar o filtro do Remini_')
}
} catch (e) {
console.log(e)
return reply("Erro ao processar o vídeo.")
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: igstalk
└─────────────────────────────────────────────────┘
*/
case 'igstalk':
if (!isVip) return reply(enviar.msg.vip)
if (!q) return reply('❯❯〘 ⚠️ Você precisa fornecer um nome de usuário do Instagram! ⚠️〙❮❮')
try {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
//Canal: https://whatsapp.com/channel/0029Va6riekH5JLwLUFI7P2B
zerotwo.sendMessage(from, { react: { text: `🙇🏻‍♀️`, key: info.key } })
const apiUrl = `${zerosite}/api/instagram/user?username=${q}&apikey=${API_KEY_ZEROTWO}`
const response = await fetchJson(apiUrl)
if (response && response.resultado) {
const data = response.resultado
const message = `
❯❯ ${NomeDoBot} - INSTAGRAM STALK ❮❮

*❒᭄➭ Nome de usuário:* ${data.username}
*❒᭄➭ Nome completo:* ${data.fullname || 'Não informado'}
*❒᭄➭ Posts:* ${data.post_count || 0}
*❒᭄➭ Seguidores:* ${data.followers || 0}
*❒᭄➭ Seguindo:* ${data.following || 0}
*❒᭄➭ Biografia:* ${data.biography || 'Não disponível'}
*❒᭄➭ URL da biografia:* ${data.external_url || 'Não disponível'}
*❒᭄➭ Conta privada:* ${data.is_private ? 'Sim' : 'Não'}
*❒᭄➭ Conta verificada:* ${data.is_verified ? 'Sim' : 'Não'}
*❒᭄➭ Vídeos no IGTV:* ${data.total_igtv_videos || 0}
*❒᭄➭ É conta de negócios:* ${data.is_business ? 'Sim' : 'Não'}
*❒᭄➭ Tem vídeos:* ${data.has_videos ? 'Sim' : 'Não'}
*❒᭄➭ Possui reels destacados:* ${data.has_highlight_reels ? 'Sim' : 'Não'}

*❒᭄➭ Criador da API:* ${response.criador || "Não informado"}
`
await zerotwo.sendMessage(from, { image: { url: data.hd_profile_pic_url_info.url }, caption: message }, { quoted: selolucas })
} else {
await zerotwo.sendMessage(from, { text: '❯❯〘 ⚠️ Não foi possível encontrar informações para este usuário. ⚠️〙❮❮' }, { quoted: selolucas })
}
} catch (error) {
if (error.code === 'ECONNREFUSED') {
await zerotwo.sendMessage(from, { text: '❯❯〘 ⚠️ Não foi possível conectar ao servidor. Por favor, tente novamente mais tarde. ⚠️〙❮❮' }, { quoted: selolucas })
} else {
console.log(error)
await zerotwo.sendMessage(from, { text: '❯❯〘 ⚠️ Ocorreu um erro ao tentar buscar as informações do Instagram! ⚠️〙❮❮' }, { quoted: selolucas })
}
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: imagine
└─────────────────────────────────────────────────┘
*/
case 'imagine':
if (!q) return reply(`O que você deseja criar? Coloque após o comando o que você deseja criar... Por exemplo: ${prefix + command} macaco dirigindo uma BMW`)
try {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
reagir(from, '🎨')
await reply('Olá, estou criando a imagem a partir de seu questionamento. Por favor, aguarde...')
const responseImagine = await fetch(`${zerosite}/api/imagine?nome=${q}&apikey=${API_KEY_ZEROTWO}`)
if (!responseImagine.ok) throw new Error('Erro ao gerar a imagem na API imagine')
const arrayBufferImagine = await responseImagine.arrayBuffer()
const bufferImage = Buffer.from(arrayBufferImagine)
const linkInicial = await uploadToCloudinary(bufferImage)
const responseHD1 = await fetch(`${zerosite}/api/ia/tohd?link=${linkInicial}&apikey=${API_KEY_ZEROTWO}`)
if (!responseHD1.ok) throw new Error('Erro ao melhorar a imagem no primeiro processo HD')
const arrayBufferHD1 = await responseHD1.arrayBuffer()
const bufferHD1 = Buffer.from(arrayBufferHD1)
const linkHD1 = await uploadToCloudinary(bufferHD1)
const responseHD2 = await fetch(`${zerosite}/api/ia/tohd?link=${linkHD1}&apikey=${API_KEY_ZEROTWO}`)
if (!responseHD2.ok) throw new Error('Erro ao melhorar a imagem no segundo processo HD')
const arrayBufferHD2 = await responseHD2.arrayBuffer()
const arrayBufferHD3 = await Buffer.from(arrayBufferHD2)
const linkHD2 = await uploadToCloudinary(arrayBufferHD3)
await zerotwo.sendMessage(from, { image: {url: linkHD2}, caption: `By: ${NomeDoBot}`}, { quoted: selolucas })
} catch (error) {
reagir(from, '❌')
console.error('Erro ao gerar imagem:', error)
await reply('Houve um erro ao tentar criar a imagem. Por favor, tente novamente mais tarde.')
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: info-filme
└─────────────────────────────────────────────────┘
*/
case 'info-filme':
reagir(from, react2)
try {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
if (!q || q.trim() === '') {
return await zerotwo.sendMessage(from, { text: '❌ Por favor, forneça a URL do filme.' }, { quoted: selolucas })
}
let url = q.trim()
const apiUrl = `${zerosite}/api/doramas/info-filme?url=${encodeURIComponent(url)}&apikey=${API_KEY_ZEROTWO}`
const response = await fetch(apiUrl)
const data = await response.json()
if (!data.status) {
console.log('Falha ao obter informações do filme.')
return await zerotwo.sendMessage(from, { text: '❌ Não foi possível obter as informações do filme.' }, { quoted: selolucas })
}
const filme = data.resultado
if (!filme || !filme.title || !filme.releaseDate || !filme.genres || !filme.synopsis || !filme.rating) {
console.log('Informações do filme incompletas:', filme)
return await zerotwo.sendMessage(from, { text: '❌ Informações do filme estão incompletas.' }, { quoted: selolucas })
}
const filmeCaption = `🎬 *Título:* ${filme.title}\n` +
`🗓️ *Ano de Lançamento:* ${filme.releaseDate}\n` +
`🌍 *País:* ${filme.country || 'Desconhecido'}\n` +
`⏳ *Duração:* ${filme.duration || 'Desconhecida'}\n` +
`⭐ *Classificação:* ${filme.rating.value} (${filme.rating.count} avaliações)\n` +
`📽️ *Gêneros:* ${filme.genres.join(', ')}\n\n` +
`📖 *Sinopse:* ${filme.synopsis}`
let episodioImageUrlHD
if (filme.imageUrl) {
console.log('Processando imagem do filme...')
const hdResponseFilme = await fetch(`${zerosite}/api/ia/tohd?link=${filme.imageUrl}&apikey=${API_KEY_ZEROTWO}`)
const arrayBufferFilme = await hdResponseFilme.arrayBuffer()
const bufferFilme = Buffer.from(arrayBufferFilme)
const base64Filme = bufferFilme.toString('base64')
episodioImageUrlHD = await upload(base64Filme)
} else {
console.log('Imagem do filme não disponível')
const googleImageSearch = async (query) => {
const apiKey = 'AIzaSyD1LwGYfWvRGpwOt7ppmXwHkWLm-lYMZUw'
const cx = '8336f5de960b14645'
let imagens = []
let nextPageToken = ''
do {
let url = `https://www.googleapis.com/customsearch/v1?q=${encodeURIComponent(query)}&cx=${cx}&searchType=image&key=${apiKey}&imgSize=large`
if (nextPageToken) {
url += `&pageToken=${nextPageToken}`
}
const response = await fetch(url)
const responseData = await response.json()
console.log('Resposta da busca de imagens:', responseData)
if (responseData.items && responseData.items.length > 0) {
imagens.push(...responseData.items.map(item => item.link))
}
nextPageToken = responseData.nextPageToken
} while (nextPageToken)
return imagens
}
const imagens = await googleImageSearch(filme.title)
if (imagens.length > 0) {
const hdResponseBusca = await fetch(`${zerosite}/api/ia/tohd?link=${imagens[0]}&apikey=${API_KEY_ZEROTWO}`)
const arrayBufferBusca = await hdResponseBusca.arrayBuffer()
const bufferBusca = Buffer.from(arrayBufferBusca)
const base64Busca = bufferBusca.toString('base64')
episodioImageUrlHD = await upload(base64Busca)
} else {
await zerotwo.sendMessage(from, { text: '❌ A imagem do filme não está disponível e nenhuma imagem foi encontrada.' }, { quoted: selolucas })
}
}
if (episodioImageUrlHD) {
await zerotwo.sendMessage(from, { image: { url: episodioImageUrlHD }, caption: filmeCaption }, { quoted: selolucas })
}
if (filme.cast && filme.cast.length > 0) {
for (const membro of filme.cast) {
if (!membro.imageUrl) {
continue
}
const membroCaption = `👤 *Nome:* ${membro.name}\n` +
`🎭 *Personagem:* ${membro.character || 'Desconhecido'}`
const hdResponseMembro = await fetch(`${zerosite}/api/ia/tohd?link=${membro.imageUrl}&apikey=${API_KEY_ZEROTWO}`)
const arrayBufferMembro = await hdResponseMembro.arrayBuffer()
const bufferMembro = Buffer.from(arrayBufferMembro)
const base64Membro = bufferMembro.toString('base64')
const episodioImageUrlMembroHD = await upload(base64Membro)
await zerotwo.sendMessage(from, { image: { url: episodioImageUrlMembroHD }, caption: membroCaption }, { quoted: selolucas })
}
} else {
console.log('Nenhum membro do elenco encontrado.')
await zerotwo.sendMessage(from, { text: '❌ Nenhum membro do elenco disponível.' }, { quoted: selolucas })
}
} catch (error) {
console.error('Erro ao processar o comando info-filme:', error)
await zerotwo.sendMessage(from, { text: '❌ Ocorreu um erro ao processar seu pedido.' }, { quoted: selolucas })
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: info-serie
└─────────────────────────────────────────────────┘
*/
case 'info-serie':
reagir(from, react2)
try {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
if (!q || q.trim() === '') {
return await zerotwo.sendMessage(from, { text: '❌ Por favor, forneça a URL da série.' }, { quoted: selolucas })
}
const args = q.split(' ')
let url = args[0]
const episodeRegex = /\/episodio\/([^\/]+)/
const serieUrlMatch = url.match(episodeRegex)
if (serieUrlMatch) {
url = url.replace(/-.*$/, '')
url = url.replace(episodeRegex, '/series/$1')
}
const apiUrl = `${zerosite}/api/doramas/info-serie?url=${encodeURIComponent(url)}&apikey=${API_KEY_ZEROTWO}`
const response = await fetch(apiUrl)
const data = await response.json()
if (!data.status) {
return await zerotwo.sendMessage(from, { text: '❌ Não foi possível obter as informações da série.' }, { quoted: selolucas })
}
const serie = data.resultado
if (!serie || !serie.imageUrl) {
return await zerotwo.sendMessage(from, { text: '❌ Informações da série estão incompletas.' }, { quoted: selolucas })
}
let imageUrlHD = serie.imageUrl
try {
const hdResponse = await fetch(`${zerosite}/api/ia/tohd?link=${serie.imageUrl}&apikey=${API_KEY_ZEROTWO}`)
const arrayBuffer = await hdResponse.arrayBuffer()
const buffer = Buffer.from(arrayBuffer)
const base64 = buffer.toString('base64')
imageUrlHD = await upload(base64)
} catch (e) {
console.log('Erro ao gerar imagem HD da série:', e)
}
const serieCaption = `📺 *Título:* ${serie.title}\n*Ano de Lançamento:* ${serie.releaseYear}\n*Classificação:* ${serie.rating} (${serie.ratingCount} avaliações)\n*Gêneros:* ${serie.genres.join(', ')}\n\n*Informações sobre a série:* ${serie.title}`
await zerotwo.sendMessage(from, { image: { url: imageUrlHD }, caption: serieCaption }, { quoted: selolucas })
for (const episodio of serie.episodes) {
let episodioImageUrlHD = episodio.imageUrl
try {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
const hdResponseEpisodio = await fetch(`${zerosite}/api/ia/tohd?link=${episodio.imageUrl}&apikey=${API_KEY_ZEROTWO}`)
const arrayBufferEpisodio = await hdResponseEpisodio.arrayBuffer()
const bufferEpisodio = Buffer.from(arrayBufferEpisodio)
const base64Episodio = bufferEpisodio.toString('base64')
episodioImageUrlHD = await upload(base64Episodio)
} catch (e) {
console.log('Erro ao gerar imagem HD do episódio:', e)
}
const episodioCaption = `🎬 *Título do Episódio:* ${episodio.title}\n*Número:* ${episodio.number}\n*Data de Lançamento:* ${episodio.releaseDate}\n*Link:* ${episodio.url}`
await zerotwo.sendMessage(from, { image: { url: episodioImageUrlHD }, caption: episodioCaption }, { quoted: selolucas })
}
} catch (e) {
console.log('Erro encontrado:', e)
await zerotwo.sendMessage(from, { text: '❌ Ocorreu um erro ao buscar as informações da série.' }, { quoted: selolucas })
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: insta_destaques
└─────────────────────────────────────────────────┘
*/
case 'insta_destaques':
zerotwo.sendMessage(from, { react: { text: `🔍`, key: info.key }})
if (!q) return reply('⚠️ *Erro*: Digite o nome de usuário do Instagram para buscar os destaques!')
try {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
//Canal: https://whatsapp.com/channel/0029Va6riekH5JLwLUFI7P2B
reply('⏳ *Aguarde... Estamos recuperando os destaques de @' + q + '...*')
const apiUrl = `${zerosite}/api/instagram/highlights?username=${q}&apikey=${API_KEY_ZEROTWO}`
const response = await fetch(apiUrl)
const data = await response.json()
if (data && data.status && data.resultado) {
const { username, highlights_count, criador, data: highlights } = data.resultado
let message = `✨ *Destaques de @${username || 'Desconhecido'}*:\n\n🔢 *Total de Destaques*: ${highlights_count || 0}\n`
if (highlights && highlights.length > 0 && highlights[0].owner) {
const owner = highlights[0].owner
const ownerImage = owner && owner.profile_pic_url ? owner.profile_pic_url : null
if (ownerImage) {
await sendImage(from, ownerImage, message, selolucas)
} else {
reply('⚠️ *Aviso*: A imagem do dono do destaque não foi encontrada, mas os destaques foram recuperados.')
await sleep(2000)
reply(message)
}
} else {
reply('⚠️ *Aviso*: Nenhum destaque encontrado ou dono não possui imagem.')
}
reply('📬 *Estamos processando os destaques...*')
if (Array.isArray(highlights)) {
for (let index = 0; index < highlights.length; index++) {
const highlight = highlights[index]
const { title, cover, media_count, highlights_id, type, owner, taken_at, url } = highlight
let highlightMessage = `*❒᭄➭ Título: ${title || 'Desconhecido'}*\n*❒᭄➭ Mídias: ${media_count || 0}*\n*❒᭄➭ Link do Destaque: https://www.instagram.com/explore/highlights/${highlights_id || 'Desconhecido'}/*\n*❒᭄➭ Tipo de Mídia: ${type === 'video' ? 'Vídeo' : 'Imagem'}*\n`
if (type === 'video') {
await sendVideo(from, url, `❯❯ ${NomeDoBot} - INSTAGRAM DESTAQUE ${index + 1} ❮❮\n\n${highlightMessage}`, selolucas)
} else {
await sendImage(from, cover, `❯❯ ${NomeDoBot} - INSTAGRAM DESTAQUE ${index + 1} ❮❮\n\n${highlightMessage}`, selolucas)
}
await sleep(2000)
}
await sleep(2000)
reply('✅ *Os destaques foram enviados com sucesso!* 🎉')
} else {
reply('⚠️ *Aviso*: Nenhum destaque foi encontrado para esse usuário.')
}
} else {
reply('❌ *Erro*: Não foi possível recuperar os destaques. Verifique o nome de usuário e tente novamente.')
}
} catch (err) {
console.log(err)
reply('⚠️ *Erro*: Ocorreu um problema ao acessar os destaques do Instagram. Tente novamente mais tarde.')
}
break

// INÍCIO DA ÁREA DE COMANDOS DO FREE FIRE

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: instagram
└─────────────────────────────────────────────────┘
*/
case 'instagram':
reagir(from, "📥")
if (!q) return reply(`Por favor, insira o link do vídeo do Instagram.\n\nExemplo: ${prefix + command} https://www.instagram.com/reel/CZIV8TyBbTA/`)
try {
reply(`❪𝙴𝚗𝚟𝚒𝚊𝚗𝚍𝚘 𝚂𝚎𝚞 𝙼𝚎𝚍𝚒𝚊 𝚍𝚘 𝙸𝚗𝚜𝚝𝚊𝚐𝚛𝚊𝚖ฺ࣭࣪͘ꕸ▸`)
let res = await fetch(`${zerosite}/api/instagram?url=${q}&apikey=${API_KEY_ZEROTWO}`)
let json = await res.json()
if (!json.status) return reply('Falha ao baixar o conteúdo. Verifique o link e tente novamente.')
let resultado = json.resultado
if (resultado.video) {
let videoUrl = resultado.video
let thumbnailUrl = resultado.miniatura
await zerotwo.sendMessage(from, { video: { url: videoUrl }, caption: `❯❯〘 ZERO TWO - DOWNLOADS 〙❮❮\n📥 Vídeo baixado com sucesso!`, mimetype: 'video/mp4', contextInfo: { mentionedJid: [sender], externalAdReply: { showAdAttribution: true, title: `💞 ${NomeDoBot} 💞\nDownload Instagram`, body: 'Baixe vídeos do Instagram com facilidade!', thumbnail: await getBuffer(thumbnailUrl), mediaType: 1, sourceUrl: q }}}, {quoted: selolucas})
}
if (resultado.imagens && resultado.imagens.length > 0) {
for (let i = 0; i < resultado.imagens.length; i++) {
let imagemUrl = resultado.imagens[i]
await zerotwo.sendMessage(from, { image: { url: imagemUrl }, caption: `❯❯〘 ZERO TWO - DOWNLOADS 〙❮❮\n📥 Imagem ${i + 1} baixada com sucesso!`, contextInfo: { mentionedJid: [sender], externalAdReply: { showAdAttribution: true, title: `💞 ${NomeDoBot} 💞\nDownload Instagram`, body: 'Baixe vídeos do Instagram com facilidade!', thumbnail: await getBuffer(imagemUrl), mediaType: 1, sourceUrl: q }}}, {quoted: selolucas})
await sleep(1500)
}
}
reply('📥 Todo o conteúdo foi enviado com sucesso!')
} catch (e) {
console.log(e)
reply('Ocorreu um erro ao tentar baixar o conteúdo.')
}
break

/*

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: instagram3
└─────────────────────────────────────────────────┘
*/
case 'instagram3':
try {
if(q.length < 5) return reply(`Exemplo: ${prefix+command} o link`)
reply(`❪𝙴𝚗𝚟𝚒𝚊𝚗𝚍𝚘 𝚂𝚎𝚞 𝚅í𝚍𝚎𝚘ฺ࣭࣪͘ꕸ▸`)
instavd = await fetchJson(zerosite+`/api/instagram?url=${q}&apikey=`+API_KEY_ZEROTWO)
if(instavd.resultado.length > 0) return sendVideo(from, instavd.resultado[0], ``, selo)
instavd2 = await fetchJson(zerosite+`/api/v2/instagram?url=${q}&apikey=`+API_KEY_ZEROTWO)
if(instavd2.resultado.length > 0 && instavd2.resultado[0].type == `video`) return sendVideo(from, instavd2.resultado[0].url, ``, selo)
instavd3 = await fetchJson(zerosite+`/api/v3/instagram?url=${q}&apikey=`+API_KEY_ZEROTWO)
if(instavd3?.resultado?.link_dl) return sendVideo(from, instavd3.resultado.link_dl, ``, selo)
return reply(`ৎ❥̤֟٭ۣۜnenhum dado retornado🍧.ᩦ୭✧ࣶᭂ`)
} catch (e) {
console.log(e)
return reply("Erro..")
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: instamp3
└─────────────────────────────────────────────────┘
*/
case 'instamp3':
try {
if(!q) return reply(`Exemplo: ${prefix+command} o link`)
instaad = await fetchJson(zerosite+`/api/instagram?url=${q}&apikey=`+API_KEY_ZEROTWO)
if(instaad.resultado.length > 0) return sendAudio(from, instaad.resultado[0], `audio/mp4`, selo)
instaad2 = await fetchJson(zerosite+`/api/v2/instagram?url=${q}&apikey=`+API_KEY_ZEROTWO)
if(instaad2.resultado.length > 0) return sendAudio(from, instaad2.resultado[0].url, `audio/mp4`, selo)
instaad3 = await fetchJson(zerosite+`/api/v3/instagram?url=${q}&apikey=`+API_KEY_ZEROTWO)
if(instaad3?.resultado?.link_dl) return sendAudio(from, instaad3.resultado.link_dl, `audio/mp4`, selo)
return reply(`ৎ❥̤֟٭ۣۜnenhum dado retornado🍧.ᩦ୭✧ࣶᭂ`)
} catch (e) {
console.log(e)
return reply("Erro..")
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: instamp4
└─────────────────────────────────────────────────┘
*/
case 'instamp4':
try {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
// Verificação inicial do link
if (q.length < 5) return reply(`Exemplo: ${prefix + command} o link`)
reply(`❪𝙴𝚗𝚟𝚒𝚊𝚗𝚍𝚘 𝚂𝚎𝚞 𝚅í𝚍𝚎𝚘 𝚘𝚞 𝙸𝚖𝚊𝚐𝚎𝚖ฺ࣭࣪͘ꕸ▸`)
const isPostLink = q.includes('https://www.instagram.com/p/')
const isReelLink = q.includes('https://www.instagram.com/reel/')
if (isPostLink || isReelLink) {
// Tenta a API v3 primeiro
let instavd3 = await fetchJson(`${zerosite}/api/v3/instagram?url=${q}&apikey=${API_KEY_ZEROTWO}`)
console.log('Response from v3:', instavd3)
if (instavd3?.resultado?.media?.length > 0) {
let { account, caption } = instavd3.resultado
let mediaDescription = `❯❯ *Descrição*: ${caption}`
let mediaTitle = `*Usuário*: ${account.username}\n*Nome completo*: ${account.full_name}`
for (let mediaUrl of instavd3.resultado.media) {
if (mediaUrl.endsWith('.mp4') || mediaUrl.endsWith('.mkv') || mediaUrl.endsWith('.webm')) {
await sendVideo(from, mediaUrl, `${mediaTitle}\n\n${mediaDescription}`, selolucas)
} else if (mediaUrl.endsWith('.jpg') || mediaUrl.endsWith('.jpeg') || mediaUrl.endsWith('.png')) {
await sendImage(from, mediaUrl, `${mediaTitle}\n\n${mediaDescription}`, selolucas)
}
}
} else {
// Tenta a API v2 se v3 não funcionar
let instavd2 = await fetchJson(`${zerosite}/api/v2/instagram?url=${q}&apikey=${API_KEY_ZEROTWO}`)
console.log('Response from v2:', instavd2)
if (instavd2?.status && instavd2.resultado?.length > 0) {
for (let mediaUrl of instavd2.resultado) {
if (mediaUrl.endsWith('.mp4') || mediaUrl.endsWith('.mkv') || mediaUrl.endsWith('.webm')) {
await sendVideo(from, mediaUrl, '', selolucas)
} else if (mediaUrl.endsWith('.jpg') || mediaUrl.endsWith('.jpeg') || mediaUrl.endsWith('.png')) {
await sendImage(from, mediaUrl, '', selolucas)
}
}
} else {
// Tenta a API multi se v2 também não funcionar
let instavdMulti = await fetchJson(`${zerosite}/api/dl/multidl?url=${q}&apikey=${API_KEY_ZEROTWO}`)
console.log('Response from multi:', instavdMulti)
if (instavdMulti.status === 200 && instavdMulti.resultado && instavdMulti.resultado.medias?.length > 0) {
let mediaDescription = `❯❯ *Descrição*: ${instavdMulti.resultado.title}`
for (let media of instavdMulti.resultado.medias) {
if (media.extension === 'mp4' || media.extension === 'mkv' || media.extension === 'webm') {
await sendVideo(from, media.url, `${mediaDescription}`, selolucas)
} else if (media.extension === 'jpg' || media.extension === 'jpeg' || media.extension === 'png') {
await sendImage(from, media.url, `${mediaDescription}`, selolucas)
}
}
} else {
return reply(`❥̤֟٭ۣۜnenhum dado retornado pelas APIs🍧.ᩦ୭✧ࣶᭂ`)
}
}
}
} else {
return reply(`❥̤֟٭ۣۜlink não suportado🍧.ᩦ୭✧ࣶᭂ`)
}
} catch (e) {
console.log('Erro:', e)
return reply("Erro ao processar o link.")
}
break
*/

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: instastory
└─────────────────────────────────────────────────┘
*/
case 'instastory':
if (!isVip) return reply(enviar.msg.vip)
if (!q) return reply(`⏤͟͟͞͞⃝Cadê o *Usuário Da Pessoa* Que Você Deseja Stalkear?\nExemplo: ${prefix + command} @alok`)
try {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
//Canal: https://whatsapp.com/channel/0029Va6riekH5JLwLUFI7P2B
zerotwo.sendMessage(from, { react: { text: `⬇️`, key: info.key } })
reply(`*_Fazendo download... Aguarde um momento_* 🚨`)
let apiUrl = `${zerosite}/api/instagram/stories?username=${q.replace("@", "")}&apikey=${API_KEY_ZEROTWO}`
let response = await fetch(apiUrl)
let result = await response.json()
if (!result || !result.status || !result.resultado) {
console.log(chalk.red('[LOG] Retorno da API inválido ou erro no servidor.'))
return reply(`Não foi possível encontrar este perfil no Instagram ou a API está fora do ar.`)
}
let perfil = result.resultado
if (!perfil.stories_count || perfil.stories_count <= 0) {
console.log(chalk.red('[LOG] Nenhum story encontrado ou perfil privado.'))
return reply(`Não há stories disponíveis para este perfil, ou pode ser que a conta seja privada 🔒`)
}
if (perfil && perfil.graphql && perfil.graphql.user && perfil.graphql.user.profile_pic_url) {
const profilePicUrl = perfil.graphql.user.profile_pic_url
const imageResponse = await fetch(profilePicUrl)
if (!imageResponse.ok) throw new Error('Falha ao obter a imagem da URL')
const arrayBuffer = await imageResponse.arrayBuffer()
const imageBuffer = Buffer.from(arrayBuffer)
const uploadedImageUrl = await uploadToCloudinary(imageBuffer)
let captionPerfil = `📝 *Informações do Perfil:*\n\n` +
`👤 *Usuário:* @${q.replace("@", "")}\n` +
`📸 *Nome:* ${perfil.graphql.user.full_name || "Nome não disponível"}\n` +
`🔒 *Conta Privada:* ${perfil.graphql.user.is_private ? "Sim" : "Não"}\n` +
`📊 *Stories Disponíveis:* ${perfil.stories_count || "0"}\n` +
`🔗 *Link do Perfil:* https://instagram.com/${q.replace("@", "")}`
await zerotwo.sendMessage(from, { image: { url: uploadedImageUrl }, caption: captionPerfil }, { quoted: selolucas })
} else {
console.log(chalk.red('[LOG] Imagem de perfil não encontrada.'))
}
const aviso = `⚠️ *Preparando envio de stories do perfil @${q.replace("@", "")}...*\n\n` +
`_Aguarde enquanto processamos os ${perfil.stories_count} stories disponíveis._`
await zerotwo.sendMessage(from, { text: aviso }, {quoted: selolucas})
let stories = perfil.stories || []
for (let index = 0; index < stories.length; index++) {
let story = stories[index]
let caption = `Story ${index + 1} do perfil @${q.replace("@", "")}`
if (!story.url) {
console.log(chalk.red(`[ERRO] URL inválida no story ${index + 1}. Ignorando...`));
continue
}
if (story.type === 'image') {
await sleep(1000)
await zerotwo.sendMessage(from, { image: { url: story.url }, caption }, { quoted: selolucas })
} else if (story.type === 'video') {
await sleep(3000)
await zerotwo.sendMessage(from, { video: { url: story.url }, caption }, { quoted: selolucas })
}
}
} catch (e) {
console.log(chalk.red('[ERRO] Ocorreu um erro durante a execução do comando:'), e)
return reply(`Não foi possível encontrar esse perfil no Instagram, ou pode ser que a API esteja fora do ar...`)
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: kwai2
└─────────────────────────────────────────────────┘
*/
case 'kwai2':
try {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
if (!q.includes("kwai")) {
return reply(`Exemplo: ${prefix + command} o link do Kwai`)
}
const fetchKwaiVideo = async (q) => {
try {
const apiUrl = `${zerosite}/kwai/video?url=${encodeURIComponent(q)}&apikey=${API_KEY_ZEROTWO}`
const response = await fetch(apiUrl)
if (!response.ok) {
throw new Error(`Erro na resposta da API: ${response.statusText}`)
}
const result = await response.json()
return result
} catch (error) {
console.log('Erro ao buscar dados do vídeo:', error.message)
return null
}
}
const apiResult = await fetchKwaiVideo(q)
if (apiResult && apiResult.status === 200) {
const videoData = apiResult.resultado
const videoCaption = `❯❯〘 BAIXADO PELA ZERO TWO 〙❮❮\n\n` +
`❏ Criador do Vídeo: ${videoData.criador || 'Desconhecido'}\n` +
`❏ ID da Foto: ${videoData.fotoId || 'Desconhecido'}\n` +
`❏ Legenda: ${videoData.legenda || 'Nenhuma'}\n` +
`❏ Resolução: ${videoData.largura}x${videoData.altura}\n` +
`❏ Cor Predominante: ${videoData.cor || 'Desconhecida'}\n` +
`❏ Visualizações: ${videoData.contadorDeVisualizacoes || 'Desconhecido'}\n` +
`❏ Curtidas: ${videoData.contadorDeCurtidas || 'Desconhecido'}\n` +
`❏ Comentários: ${videoData.contadorDeComentarios || 'Desconhecido'}\n` +
`❏ ID do Usuário: ${videoData.idDoUsuario || 'Desconhecido'}\n` +
`❏ Sexo do Usuário: ${videoData.sexoDoUsuario || 'Desconhecido'}\n` +
`❏ Publicado em: ${videoData.dataPublicacao || 'Desconhecida'}\n` +
`❏ É Dueto: ${videoData.eDueto ? 'Sim' : 'Não'}\n` +
`❏ URL de Cabeçalho: ${videoData.urlCabecalho || 'Desconhecida'}\n` +
`❏ URL de Cabeçalho (Pequeno): ${videoData.urlCabecalhoPequeno || 'Desconhecida'}\n` +
`❏ URL Original: ${q}`
const thumbnail = await getBuffer(videoData.urlsDeCapa[0])
const mp4Url = videoData.videoUrl
await zerotwo.sendMessage(from, { video: { url: mp4Url }, caption: videoCaption, mimetype: 'video/mp4', contextInfo: { mentionedJid: [sender], externalAdReply: { showAdAttribution: true, title: `💞 ${NomeDoBot} 💞\nDownload Kwai`, body: 'Baixe vídeos do Kwai com facilidade!', thumbnail, mediaType: 1, sourceUrl: q }}}, { quoted: selolucas })
} else {
console.log('Erro: Nenhum vídeo encontrado ou resposta inválida.')
reply("Nenhum vídeo disponível para download.")
}
} catch (e) {
console.log('Erro ao processar a requisição:', e.message)
reply("Erro ao processar a requisição.")
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: legenda
└─────────────────────────────────────────────────┘
*/
case 'legenda':
try {
var [txt1, txt2] = q.split("/")
if(!q.includes("/")) return reply(`Cade a / mano?\nExemplo: ${prefix + command} Black/Bot`)
if ((isMedia && !info.message.videoMessage || isQuotedImage)) {
boij = isQuotedImage ? JSON.parse(JSON.stringify(selolucas).replace('quotedM','m')).message.extendedTextMessage.contextInfo.message.imageMessage : info.message.imageMessage
owgi = await getFileBuffer(boij, 'image')
res = await uploadToCloudinary(owgi)
zerotwo.sendMessage(from, {image: {url: `${zerosite}/api/legenda?url=${res}&texto1=${txt1}&texto2=${txt2}&apikey=`+API_KEY_ZEROTWO}}, {quoted: selolucas}).catch(e => {
return reply("Erro..")
})
} else {
reply('Marque uma imagem...!')
}
} catch (e) {
return reply('ERROR!!')
}
break

//=======(FIM-EFEITOS-MARCAR)=========\\

default:
/*
async function ativarColetaLinks(groupId, categoria) {
console.log(chalk.blue(`[LOG] Ativando coleta para o grupo ${groupId} e categoria "${categoria}"`));
const groupData = dataGp.find(group => group.groupId === groupId);

if (!groupData) {
console.log(chalk.red('[ERRO] Grupo não encontrado.'));
return '_❲❗❳ Grupo não encontrado. Não foi possível ativar a coleta._';
}

if (groupData.autocoleta) {
console.log(chalk.yellow('[AVISO] A coleta já está ativada.'));
return '_❲❗❳ A coleta já está ativada._';
}

groupData.autocoleta = true;
groupData.categoria = categoria;
console.log(chalk.green(`[LOG] Coleta de links ativada para a categoria "${categoria}" no grupo "${groupId}".`));
return `_✅ Coleta de links ativada para a categoria "${categoria}". Envie imagens ou vídeos para salvar os links._`;
}

async function desativarColetaLinks(groupId) {
console.log(chalk.blue(`[LOG] Desativando coleta para o grupo ${groupId}`));
const groupData = dataGp.find(group => group.groupId === groupId);

if (!groupData) {
console.log(chalk.red('[ERRO] Grupo não encontrado.'));
return '_❲❗❳ Grupo não encontrado. Não foi possível desativar a coleta._';
}

if (!groupData.autocoleta) {
console.log(chalk.yellow('[AVISO] A coleta não está ativada.'));
return '_❲❗❳ A coleta não está ativada._';
}

groupData.autocoleta = false;
groupData.categoria = null;
console.log(chalk.green(`[LOG] Coleta de links desativada no grupo "${groupId}".`));
return '_❌ Coleta de links desativada._';
}

if(groupId, isGroup, isImage, isVideo, info) {
console.log(chalk.blue(`[LOG] Iniciando processamento de mídia para o grupo ${groupId}`));
const groupData = dataGp.find(group => group.groupId === groupId);

if (!groupData || !groupData.autocoleta) {
console.log(chalk.yellow('[AVISO] Coleta não está ativada ou grupo não encontrado.'));
return;
}

let mediaType;
try {
mediaType = isImage ? 'imagem' : 'vídeo';
console.log(chalk.green(`[LOG] Mídia detectada: ${mediaType.charAt(0).toUpperCase() + mediaType.slice(1)}.`));
const mediaMessage = isImage ? info.message.imageMessage : info.message.videoMessage;
const sender = info.key.remoteJid;
console.log(chalk.green(`[LOG] Remetente: ${sender}`));

const stream = await baileys.downloadContentFromMessage(mediaMessage, isImage ? 'image' : 'video');
const chunks = [];
for await (const chunk of stream) {
chunks.push(chunk);
}

const buffer = Buffer.concat(chunks);
console.log(chalk.green('[LOG] Mídia baixada com sucesso.'));

salvarLinkNaCategoria(buffer, mediaType, sender, groupData.categoria);
console.log(chalk.green('[LOG] Link salvo na categoria com sucesso.'));
} catch (error) {
console.error(chalk.red(`[ERRO] - Ocorreu um erro ao processar a mídia: ${error.message}`));
}
}
*/
// FIM DO SISTEMA

if(isGroup && isBotGroupAdmins && !isGroupAdmins) {
if(isAntiCtt || Antiloc || isAnticatalogo) {
if(type === 'contactMessage' || type === 'contactsArrayMessage' || type === 'locationMessage' || type === 'productMessage') {
if(isGroupAdmins) return zerotwo.sendMessage(from, {text: `Uma dessas opções estão ativada, mas por você ser ADM, não será removido(a) _(ANTI CONTATO - ANTI CATALOGO - ANTI LOCALIZAÇÃO)`}, {quoted: selolucas})
setTimeout(() => {
zerotwo.sendMessage(from, { delete: { remoteJid: from, fromMe: false, id: info.key.id, participant: sender}})
}, 1500)
if(!JSON.stringify(groupMembers).includes(sender)) return
zerotwo.groupParticipantsUpdate(from, [sender], 'remove')
clear = `🗑${"\n".repeat(255)}🗑️\n❲❒❳ *Lɪᴍᴘᴇᴢᴀ ᴅᴇ Cʜᴀᴛ Cᴏɴᴄʟᴜɪ́ᴅᴀ*🍧.ᩦ୭✧ࣶᭂ`
zerotwo.sendMessage(from, {text: clear, contextInfo : { forwardingScore: 500, isForwarded:true}})
zerotwo.sendMessage(from, {text: 'reporte aos adm o ocorrido ', mentions: groupAdmins})
}}}

if(isGroup && isAntiFlood && !isOwner && !isVip && !isnit && isBotGroupAdmins && !isGroupAdmins && !isBot) { 
if(isLimitec == null){
var limitefl = limitefll.limitefl
} else {
var limitefl = isLimitec
}
if(budy.length >= limitefl){
setTimeout( () => {
return reply('Muitas Caracteres enviadas, isto é contra as normas do grupo, por precaução, eu irei remover.')
console.log(colors.red('Deram Spam de caracteres..'))
}, 100)
setTimeout(async () => {
setTimeout(() => {
zerotwo.sendMessage(from, { delete: { remoteJid: from, fromMe: false, id: info.key.id, participant: sender}})
}, 1500)
if(!JSON.stringify(groupMembers).includes(sender)) return
zerotwo.groupParticipantsUpdate(from, [sender], 'remove')
}, 1000)
}
}

switch(testat){
}

const EnvAudio_SMP = async (direcao, nome1, nome2, nome3, nome4, nome5) => {
bla = [nome1, nome2, nome3, nome4, nome5]
for ( i of bla) {
if(i == undefined) return
if(messagesC.includes(i)) {
zerotwo.sendMessage(from, {audio: {url: direcao}, mimetype: "audio/mp4", ptt:true})
}}}

const EnvAudio2_SMP = async (direcao, nome1, nome2, nome3, nome4, nome5) => {
bla = [nome1, nome2, nome3, nome4, nome5]
for ( i of bla) {
if(i == undefined) return
if(messagesC.includes(i)) {
zerotwo.sendMessage(from, {audio: {url: direcao}, mimetype: "audio/mp4", ptt:true})
}}}

const EnvTXT_SMP = async (texto, nome1, nome2, nome3, nome4, nome5) => {
bla = [nome1, nome2, nome3, nome4, nome5]
for ( i of bla) {
if(i == undefined) return
if(messagesC.includes(i)) {
zerotwo.sendMessage(from, {text: texto})
}}}

const EnvAudio2_GTTS = async (lingua, texto, txt1, txt2, txt3, txt4, txt5) => {
bla = [txt1, txt2, txt3, txt4, txt5]
for ( i of bla) {
if(i == undefined) return
if(budy2.includes(i)) {
var gtt = require('./armor/funcoes/gtts')(lingua)
ranm = getRandom('.mp3')
rano = getRandom('.ogg')
gtt.save(ranm, texto, function() {
exec(`ffmpeg -i ${ranm} -ar 48000 -vn -c:a libopus ${rano}`, (err) => {
DLT_FL(ranm)
buffer = fs.readFileSync(rano)
zerotwo.sendMessage(from, {audio: buffer, ptt:true}, {quoted: selolucas})
DLT_FL(rano)
})
})
}}}

var hora_sla = moment.tz('America/Sao_Paulo').format('HH:mm:ss')

EnvAudio2_GTTS("pt", `São ${realtime()}`, "que horas sao?")

/*EnvTXT_SMP(prefix, "prefixo")*/

if(budy2.includes("lucas mod") && !isOwner){
usu = sender_ou_n
try {
luquinhas = await zerotwo.profilePictureUrl(`${usu.split('@')[0]}@c.us`, 'image')
} catch {
luquinhas = semfoto
}
linkgc = await zerotwo.groupInviteCode(from)
lucastxt = [`Tá falando do meu programador ? 🫵🏽🤨`, `O que você quer com meu dono ? 🔪`, `O que você quer com meu programador ? 😡`, `Vou falar pro meu dono que você anda falando dele por aí 😐👍🏽`]
sendRouletteButton(from, {text: lucastxt[Math.floor(Math.random()*lucastxt.length)], footer: NomeDoBot}, zerotwo, sender, [{type: `copy_url`, text: `👑 𝙈𝙀𝙐 𝘿𝙊𝙉𝙊 👑`, url: `wa.me//559491569380`}], selolucas)
await sleep(500)
zerotwo.sendMessage(nmrdn, {text: `${pushname} tava falando de tu ${isGroup ? `no grupo ${groupName} 😐👍🏽` : `no meu PV...`}`, contextInfo: {
externalAdReply: {
title: groupName,
body: ``,
thumbnail: await getBuffer(luquinhas),
mediaType: 1,
showAdAttribution: true,
sourceUrl: 'https://chat.whatsapp.com/'+linkgc,
forwardingScore: 999, isForwarded: true, forwardedNewsletterMessageInfo: {newsletterJid: channel, newsletterName: `𝙲𝙾𝙽𝙽𝙴𝙲𝚃𝙴𝙳 𝙲𝙾𝙽𝚃𝙴Ú𝙳𝙾𝚂`}
}
}}, {quoted: selolucas})
}

const grupinhoqmemama = await zerotwo.groupMetadata(from)
if (budy2 === `grupo a` && isGroup && isGroupAdmins && isBotGroupAdmins && grupinhoqmemama.announce === true) {
setTimeout(() => { reagir(from, "✅") }, 300)
await zerotwo.groupSettingUpdate(from, 'not_announcement')
reply(`✅ *${tempo} à todos... O grupo foi aberto novamente*`)
}

if (budy2 === `grupo f` && isGroup && isGroupAdmins && isBotGroupAdmins && grupinhoqmemama.announce === false) {
setTimeout(() => { reagir(from, "🚫") }, 300)
await zerotwo.groupSettingUpdate(from, 'announcement')
reply(`🚫 *Grupo fechado... As suas ordens vossa senhoria*`)
}

if (budy2 === 'apaga' && isGroup && isGroupAdmins && isBotGroupAdmins && menc_prt) {
zerotwo.sendMessage(from, {delete: { remoteJid: from, fromMe: false, id: info.message.extendedTextMessage.contextInfo.stanzaId, participant: menc_prt }})
}

if (budy2 === 'prefixo' && !isBanchat) {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
const userId = info.key.participant || from
if (floodControl[userId] && (Date.now() - floodControl[userId]) < 600000) {
console.log("Usuário já enviou o comando 'prefixo' recentemente. Bloqueado pelo antiflood.")
return
}
floodControl[userId] = Date.now()
saveFloodControl()
reagir(from, "🥰")
reply(`*𝐏𝐀𝐑𝐀 𝐔𝐒𝐀𝐑 𝐌𝐄𝐔𝐒 𝐂𝐎𝐌𝐀𝐍𝐃𝐎𝐒 𝐁𝐀𝐒𝐓𝐀 𝐔𝐒𝐀𝐑 ❯❯〘 ${prefix}menu 〙❮❮ 💞*`)
}

if(body != undefined && isPrivateChat && !sender.includes(`559491569380`)) replyJson(selolucas)

//início das funções do namoro/casamento
if(isJsonIncludes(waitFriendZone, sender)) {
mini = rmLetras(budy2)
if(isGroup && isGroupOfPedidoFriendZone(sender, from)) {
if(isWaitUsuFZ_namoro(sender)) {
if(mini == "sim" || mini == "s") {
aceitarPedidoDeNamoro(sender)
return sendRouletteButton(from, {image: {url: links.logocapa3}, caption: `💞 Felicitações @${getDBFZuser(sender).usu2}, parece que o @${sender.split("@")[0]} aceitou seu pedido de namoro... Seus dados podem ser acessados no comando ${prefix}dupla 🥰`, mentions: [identArroba(getDBFZuser(sender).usu2), sender], footer: NomeDoBot}, zerotwo, sender, [{type: `copy_url`, text: `𝙈𝙄𝙉𝙃𝘼 𝘿𝙐𝙋𝙇𝘼 💘`, url: `wa.me//${sender.split("@")[0]}`}], selolucas)
}
if(mini == "nao" || mini == "n") {
A1 = waitFriendZone.map(i => i.id).indexOf(sender)
mention(`😔 Sinto muito @${waitFriendZone[A1].pedido}, parece que o usu ${pushname} recusou seu pedido de namoro...`)
return recusarPedidoDeNamoro(sender)
}
}
if(isWaitUsuFZ_casamento(sender)) {
if(mini == "sim" || mini == "s") {
aceitarPedidoDeCasamento(sender)
return sendRouletteButton(from, {image: {url: links.logocapa3}, caption: `💍 Felicitações @${getDBFZuser(sender).usu2}, parece que o @${sender.split("@")[0]} aceitou seu pedido de casamento... Seus dados foram atualizados no comando ${prefix}dupla 👻`, mentions: [identArroba(getDBFZuser(sender).usu2), sender], footer: NomeDoBot}, zerotwo, sender, [{type: `copy_url`, text: `𝙈𝙄𝙉𝙃𝘼 𝘿𝙐𝙋𝙇𝘼 💘`, url: `wa.me//${sender.split("@")[0]}`}], selolucas)
}
if(mini == "nao" || mini == "n") {
recusarPedidoDeCasamento(sender)
mention(`😪 Sinto muito @${getDBFZuser(sender).usu2}, parece que o usu @${sender.split("@")[0]} recusou seu pedido de casamento... Felizmente, vocês ainda são um casal de namorados 🥰`)
}
}
}
}

//fim das funções do namoro/casamento

// FUNÇÃO DE RESPOSTA DO QUIZ DE ANIME
if (global.animeQuiz) {
const match = body.trim().match(/^Opção (\d+)$/)
if (match) {
const selectedOption = parseInt(match[1]) - 1
if (selectedOption >= 0 && selectedOption < global.animeQuiz.options.length) {
const selectedAnswer = global.animeQuiz.options[selectedOption]
if (selectedAnswer === global.animeQuiz.correctAnswer) {
reply("🎉 Parabéns! Você acertou! Isso mesmo.")
} else {
reply(`❌ Que pena! Você errou. A resposta correta era *${global.animeQuiz.correctAnswer}*.`)
}
zerotwo.sendMessage(from, {text: "Deseja tentar outra pergunta?\n\nResponda com:\nOpção 1. Sim\nOpção 2. Não"}, { quoted: selolucas })
delete global.animeQuiz
} else {
reply("❌ Opção inválida! Escolha uma das opções fornecidas.")
}
} else if (body.trim() === "Opção 1") {
reply("🔄 Reiniciando o jogo... Use o comando novamente para jogar!")
delete global.animeQuiz
} else if (body.trim() === "Opção 2") {
reply("🛑 Obrigado por jogar o Quiz de Anime! Até a próxima.")
delete global.animeQuiz
}
}

// FUNÇÃO DE REPOSTA DO QUIZ FILMES
if (global.quizFilme) {
const match = body.trim().match(/^Opção (\d+)$/)
if (match) {
const selectedOption = parseInt(match[1]) - 1
if (selectedOption >= 0 && selectedOption < global.quizFilme.respostas.length) {
const selectedAnswer = global.quizFilme.respostas[selectedOption]
if (selectedAnswer === global.quizFilme.respostaCorreta) {
reply("🎉 Parabéns! Você acertou a resposta.")
} else {
reply(`❌ Que pena! Você errou a resposta. A resposta correta era *${global.quizFilme.respostaCorreta}*.`)
}
zerotwo.sendMessage(from, { text: "Deseja tentar outra pergunta?\n\nResponda com:\nOpção 1. Sim\nOpção 2. Não" }, { quoted: selolucas })
delete global.quizFilme
} else {
reply("❌ Opção inválida! Escolha uma das opções fornecidas.")
}
} else if (body.trim() === "Opção 1") {
reply("🔄 Reiniciando o jogo... Use o comando novamente para jogar!")
delete global.quizFilme
} else if (body.trim() === "Opção 2") {
reply("🛑 Obrigado por jogar Quiz Filmes! Até a próxima.")
delete global.quizFilme
}
}

// FUNÇÃO DE REPOSTA DO QUIZ GEOGRAFIA
if (global.quizGeografia) {
const match = body.trim().match(/^Opção (\d+)$/)
if (match) {
const selectedOption = parseInt(match[1]) - 1
if (selectedOption >= 0 && selectedOption < global.quizGeografia.respostas.length) {
const selectedAnswer = global.quizGeografia.respostas[selectedOption]
if (selectedAnswer === global.quizGeografia.respostaCorreta) {
reply("🎉 Parabéns! Você acertou a resposta.")
} else {
reply(`❌ Que pena! Você errou a resposta. A resposta correta era *${global.quizGeografia.respostaCorreta}*.`)
}
zerotwo.sendMessage(from, { text: "Deseja tentar outra pergunta?\n\nResponda com:\nOpção 1. Sim\nOpção 2. Não" }, { quoted: selolucas })
delete global.quizGeografia
} else {
reply("❌ Opção inválida! Escolha uma das opções fornecidas.")
}
} else if (body.trim() === "Opção 1") {
reply("🔄 Reiniciando o jogo... Use o comando novamente para jogar!")
delete global.quizGeografia;
} else if (body.trim() === "Opção 2") {
reply("🛑 Obrigado por jogar Quiz Geografia! Até a próxima.")
delete global.quizGeografia
}
}

// FUNÇÃO DE RESPOSTA DO QUIZ CALCULADORA
if (global.calcQuiz) {
const match = body.trim().match(/^Opção (\d+)$/)
if (match) {
const selectedOption = parseInt(match[1]) - 1
if (selectedOption >= 0 && selectedOption < global.calcQuiz.options.length) {
const selectedAnswer = global.calcQuiz.options[selectedOption]
if (selectedAnswer === global.calcQuiz.correctAnswer) {
reply("🎉 Parabéns! Você acertou a resposta.")
} else {
reply(`❌ Que pena! Você errou a resposta. A resposta correta era *${global.calcQuiz.correctAnswer}*.`)
}
zerotwo.sendMessage(from, { text: "Deseja tentar outra pergunta?\n\nResponda com:\nOpção 1. Sim\nOpção 2. Não" },
{ quoted: selolucas })
delete global.calcQuiz
} else {
reply("❌ Opção inválida! Escolha uma das opções fornecidas.")
}
} else if (body.trim() === "Opção 1") {
reply("🔄 Reiniciando o jogo... Use o comando novamente para jogar!")
delete global.calcQuiz
} else if (body.trim() === "Opção 2") {
reply("🛑 Obrigado por jogar Quiz Calculadora! Até a próxima.")
delete global.calcQuiz
}
}

// FUNÇÃO DE RESPOSTA DO QUIZ POKÉMON
if (global.pokemonQuiz) {
const match = body.trim().match(/^Opção (\d+)$/)
if (match) {
const selectedOption = parseInt(match[1]) - 1
if (selectedOption >= 0 && selectedOption < global.pokemonQuiz.options.length) {
const selectedAnswer = global.pokemonQuiz.options[selectedOption]
if (selectedAnswer === global.pokemonQuiz.correctAnswer) {
reply("🎉 Parabéns! Você acertou a resposta.")
} else {
reply(`❌ Que pena! Você errou a resposta. A resposta correta era *${global.pokemonQuiz.correctAnswer}*.`)
}
zerotwo.sendMessage(from, {text: "Deseja tentar outra pergunta?\n\nResponda com:\nOpção 1. Sim\nOpção 2. Não"}, { quoted: selolucas })
delete global.pokemonQuiz
} else {
reply("❌ Opção inválida! Escolha uma das opções fornecidas.")
}
} else if (body.trim() === "Opção 1") {
reply("🔄 Reiniciando o jogo... Use o comando novamente para jogar!")
delete global.pokemonQuiz;
} else if (body.trim() === "Opção 2") {
reply("🛑 Obrigado por jogar Quiz Pokémon! Até a próxima.")
delete global.pokemonQuiz
}
}

// FUNÇÃO DE RESPOSTA DO QUIZ DOULINGO
if (fs.existsSync(tempFilePathDoulingo)) {
const gameData = JSON.parse(fs.readFileSync(tempFilePathDoulingo, 'utf8'))
if (sender !== gameData.playerId) {
return reply("❌ Apenas o jogador que iniciou o jogo pode responder!")
}
const match = body.trim().match(/^Opção (\d+)$/)
if (match) {
const selectedOption = parseInt(match[1]) - 1
if (selectedOption >= 0 && selectedOption < gameData.options.length) {
const selectedAnswer = gameData.options[selectedOption]
if (selectedAnswer === gameData.correctAnswer) {
reply("🎉 Parabéns! Você acertou a resposta.")
} else {
reply(`❌ Que pena! Você errou a resposta. A resposta correta era *${gameData.correctAnswer}*.`)
}
fs.unlinkSync(tempFilePathDoulingo)
} else {
reply("❌ Opção inválida! Escolha uma das opções fornecidas.")
}
} else if (body.trim() === "Opção 1") {
fs.unlinkSync(tempFilePathDoulingo)
reply("🔄 Reiniciando o jogo... Use o comando novamente para jogar!")
} else if (body.trim() === "Opção 2") {
reply("🛑 Obrigado por jogar Doulingo! Até a próxima.")
fs.unlinkSync(tempFilePathDoulingo)
}
}

// FUNÇÃO PARA COPIAR O NICK ESCOLHIDO PELO USUÁRIO 
if (global.nickList && /^[0-9]+$/.test(body)) {
try {
const selectedId = parseInt(body)
if (!selectedId || selectedId < 1 || selectedId > global.nickList.length) {
return reply("⚠️ *Insira um número válido para copiar o nick.*\n\nExemplo: 2")
}
const selectedNick = global.nickList[selectedId - 1]
delete global.nickList
return zerotwo.sendMessage(from, { text: `${selectedNick}` }, { quoted: selolucas })
} catch (e) {
return reply("❌ *Ocorreu um erro ao selecionar o nick. Tente novamente mais tarde.*")
}
}

// FUNÇÃO PARA COPIAR ID DA FIGURINHA 
if (body.toLowerCase() === 'copiar id') {
const tempFilePath = path.join(__dirname, 'temp', `${sender}.json`)
if (fs.existsSync(tempFilePath)) {
const data = JSON.parse(fs.readFileSync(tempFilePath))
reply(`${data.stickerId}`)
fs.unlinkSync(tempFilePath)
} else {
reply('Não foi possível encontrar o ID da figurinha. Por favor, envie um sticker e tente novamente.')
}
}

if(budy2.toLowerCase().startsWith("zerotwo") && !isBanchat && !isBotoff) {
if(args.length <= 0) return reply("Oi 👀")
if(!isGroup && !isVip) return
try {
reagir(from, "🙇🏻‍♂️")
ABC = await fetchJson(`${zerosite}/api/ia/zerotwo?query=${encodeURI(q)}&apikey=`+API_KEY_ZEROTWO)
reply(ABC.resposta)
} catch(e) {
console.log(e)
reply("Nsei")
}
}

if(budy2 === "zerotwo" && !isBanchat && !isBotoff) {
reagir(from, "👀")
sendRouletteButton(from, {text: "Fl ✋🏽😳🤚🏽", footer: `${tempo} ${pushname}`}, zerotwo, sender, [{type: `copy_url`, text: `𝙈𝙀𝙉𝙐 ✨`, url: `wa.me//`}], selolucas)
}

//========== ◤AUTO DOWNLOAD - YOUTUBE ◢ ==========\\
if (budy2.startsWith("tocar")) {
zerotwo.sendMessage(from, { react: { text: `🎶`, key: info.key } })
if (!q) return reply(`- Exemplo: ${prefix}tocar nome da música\nA música será baixada automaticamente.`)
try {
reply(`Obtendo informações para ${q}...`)
const ABC = await fetchJson(`${zerosite}/api/ytsrc/videos?q=${q}&apikey=${API_KEY_ZEROTWO}`)
const data = ABC.resultado[0]
const con = converterMin(Number((contarMin(data.timestamp || "5:32") / 100) * 30).toFixed(0))
const ini = con.includes(`ser um`) ? `0:35` : con.slice(1, con.length)
const thumb = [`anime`, `classic`, `dynamic`, `space`, `space2`]
const img = `${zerosite}/api/canvas/musicardbun/music?nome=${data.title || "indefinido"}&autor=${data?.author?.name || "indefinido"}&tipo=${thumb[alerandom(thumb.length)]}&opacity=75&thumb=${data.thumbnail || logoslink.logo}&progresso=30&start=${ini}&end=${data.timestamp || "5:32"}`
const caption = `✰͡ൣ᭄∆🔉𝐁𝐄𝐌✰𝐕𝐈𝐍𝐃𝐎🔊∆✰͡ൣ᭄ ♬\n\n𖡋ꦿঔৣ͜͡✟ ${pushname} 𓁻🔥 ♪ \n\n🌹⃟⋆͜͡҈➳ Título⧽: ${data.title}\n\n👑⃟⋆͜͡҈➳ Tempo⧽: ${data?.timestamp || "indefinido"} com ${data.views} Visualizações\n\n💖⃟⋆͜͡҈➳ Canal⧽ ${data?.author?.name || "indefinido"}\n0:35 ━❍──────── -5:32 ↻ ⊲ Ⅱ ⊳ ↺ VOLUME: ▁▂▃▄▅▆▇ 100%\n${tempo}\n\n${NomeDoBot} ♬`
const resultButton = [{ type: 'copy_url', text: `🔗 VER MÚSICA NO YOUTUBE`, url: data.url }]
sendRouletteButton(from, { image: { url: img }, caption: caption, footer: `By:𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄` }, zerotwo, sender, resultButton, selolucas)
await sleep(5000)
const videoUrl = `${zerosite}/api/dl/ytvideo?url=${encodeURIComponent(data.url)}&apikey=${API_KEY_ZEROTWO}`
reply(`Enviando vídeo, aguarde.....`)
await sendVideo(from, videoUrl, caption, selolucas)
reply(`O vídeo foi enviado com sucesso! Estarei enviando o áudio agora.`)
await sleep(2000)
await sendAudio(from, zerosite+`/api/dl/ytaudio?url=${data.url}&apikey=`+API_KEY_ZEROTWO, 'audio/mp4', selolucas)
} catch (error) {
console.log("Erro ao processar o link do YouTube:", error)
reply('Ocorreu um erro ao processar o link do YouTube. Verifique o link e tente novamente.')
}
}

if (budy.match(/^\d+\s*\|\s*(audio|video)$/)) {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
const tempJsonPath = path.join(__dirname, 'temp', 'temp_musica.json')
reagir(from, "🔥")
const [numeroMusica, tipoBaixar] = budy.split('|').map(item => item.trim())
const userIdBaixarMusica = sender
let tempData
try {
tempData = JSON.parse(fs.readFileSync(tempJsonPath, 'utf-8'))
} catch (error) {
return reply(`*❌ Erro ao acessar as informações da playlist.*`)
}
const { playlist, musicas, userId } = tempData
if (userId !== userIdBaixarMusica) {
return reply(`*❌ Esta playlist não pertence a você.*`)
}
if (tipoBaixar !== 'audio' && tipoBaixar !== 'video') {
return reply(`*❌ Tipo de mídia inválido. Use "| audio" ou "| video".*`)
}
const indexMusica = parseInt(numeroMusica) - 1
if (isNaN(indexMusica) || indexMusica < 0 || indexMusica >= musicas.length) {
let listaMusicas = ''
musicas.forEach((musica, index) => {
listaMusicas += `*${index + 1}*: ${musica}\n`
})
return reply(`*❌ Número da música inválido. Aqui estão as músicas disponíveis para você escolher:*\n\n${listaMusicas}`)
}
const nomeMusica = musicas[indexMusica]
try {
const ABC = await fetch(`${zerosite}/api/ytsrc/videos?q=${nomeMusica}&apikey=${API_KEY_ZEROTWO}`).then(res => res.json())
const data = ABC.resultado[0]
const con = converterMin(Number((contarMin(data.timestamp || "5:32") / 100) * 30).toFixed(0))
const ini = con.includes(`ser um`) ? `0:35` : con.slice(1, con.length)
const thumb = ['anime', 'classic', 'dynamic', 'space', 'space2']
const img = `${zerosite}/api/canvas/musicardbun/music?nome=${data.title || "indefinido"}&autor=${data?.author?.name || "indefinido"}&tipo=${thumb[alerandom(thumb.length)]}&opacity=75&thumb=${data.thumbnail || logoslink.logo}&progresso=30&start=${ini}&end=${data.timestamp || "5:32"}`
const caption = `
> ❯❯ 𝐙𝐄𝐑𝐎 𝐓𝐖𝐎 - DOWNLOADS ❮❮

> *❒ৣ͜͡Titulo:* ${data.title}
> *❒ৣ͜͡Canal:* ${data?.author?.name || "indefinido"}
> *❒ৣ͜͡Visualizações:* ${data.views}
> *❒ৣ͜͡Postado:* ${data?.ago || "indefinido"}
> *❒ৣ͜͡Duração:* ${data?.timestamp || "indefinido"}
> *❒ৣ͜͡Link:* ${data.url}
> *❒ৣ͜͡Descrição:* ${data?.description || "indefinida"}

> *Baixado por ✦『𝒁𝑬𝑹𝑶 𝑻𝑾𝑶』✦*`
if (tipoBaixar === 'audio') {
await zerotwo.sendMessage(from, { image: { url: img }, caption: caption }, { quoted: selolucas })
await zerotwo.sendMessage(from, { audio: { url: `${zerosite}/api/dl/ytaudio?url=${data.url}&apikey=${API_KEY_ZEROTWO}` }, mimetype: "audio/mpeg" }, { quoted: selolucas })
reply(`*✅ Áudio da música "${nomeMusica}" baixado com sucesso!*`)
} else if (tipoBaixar === 'video') {
await zerotwo.sendMessage(from, { video: { url: `${zerosite}/api/dl/ytvideo?url=${data.url}&apikey=${API_KEY_ZEROTWO}` }, caption: caption, mentions: [sender], mimetype: "video/mp4" }, { quoted: selolucas })
reply(`*✅ Vídeo da música "${nomeMusica}" baixado com sucesso!*`)
}
} catch (error) {
console.log(`Erro ao baixar a música "${nomeMusica}":`, error)
reply(`*❌ Ocorreu um erro ao baixar a música "${nomeMusica}".*`)
}
fs.unlinkSync(tempJsonPath)
}

//========== ◤AUTO DOWNLOAD - TELEGRAM ◢ ==========\\
const tempFilePath = path.join(__dirname, 'temp', 'mediaLinks.json')
function loadMediaLinks() {
if (fs.existsSync(tempFilePath)) {
return JSON.parse(fs.readFileSync(tempFilePath, 'utf8'))
}
return {}
}
function saveMediaLinks(links) {
fs.writeFileSync(tempFilePath, JSON.stringify(links, null, 2))
}
function removeTempFileIfEmpty() {
const links = loadMediaLinks()
if (Object.keys(links).length === 0) {
fs.unlinkSync(tempFilePath)
}
}

if (/https:\/\/telegra\.ph\/file\/\S+\.(jpg|jpeg|png|gif|mp4)$/i.test(budy)) {
reagir(from, "🔎")
const mediaUrl = budy.match(/https:\/\/telegra\.ph\/file\/\S+\.(jpg|jpeg|png|gif|mp4)$/i)[0]
const isVideo = /\.(mp4)$/i.test(mediaUrl)
const userNumber = info.key.participant || info.participant || from
const mediaLinks = loadMediaLinks()
mediaLinks[userNumber] = mediaUrl
saveMediaLinks(mediaLinks)
console.log(`Link de mídia armazenado temporariamente para o usuário ${userNumber}: ${mediaUrl}`)
const caption = isVideo 
? '> Você quer revelar o vídeo? Responda com "revelarvideo"' 
: '> Você quer revelar a imagem? Responda com "revelarimagem"'
await zerotwo.sendMessage(from, { image: { url: links.logocapa3 }, caption: caption, footer: NomeDoBot }, { quoted: selolucas })
}

if (budy2.startsWith('revelarimagem') || budy2.startsWith('revelarvideo')) {
try {
reagir(from, "⬇️")
const userNumber = info.key.participant || info.participant || from
const mediaLinks = loadMediaLinks()
const mediaUrl = mediaLinks[userNumber]
if (!mediaUrl) {
console.log(`Nenhum link encontrado para o usuário ${userNumber}.`)
reply('Nenhuma mídia para revelar.')
return
}
console.log(`Link encontrado para revelação para o usuário ${userNumber}: ${mediaUrl}`)
const buffer = await getBuffer(mediaUrl)
if (budy2.startsWith('revelarimagem')) {
console.log('Enviando imagem revelada...')
await zerotwo.sendMessage(from, { image: buffer, caption: '*❯❯ AQUI ESTÁ A IMAGEM REVELADA*:' }, { quoted: selolucas })
} else if (budy2.startsWith('revelarvideo')) {
console.log('Enviando vídeo revelado...')
await zerotwo.sendMessage(from, { video: buffer, gifPlayback: true, caption: '*❯❯ AQUI ESTÁ O VÍDEO REVELADO*:' }, { quoted: selolucas })
}
delete mediaLinks[userNumber]
saveMediaLinks(mediaLinks)
removeTempFileIfEmpty()
console.log(`Link temporário para o usuário ${userNumber} removido após revelação.`)
} catch (err) {
console.log('Erro ao baixar ou enviar a mídia:', err.message)
reply('Erro ao baixar ou enviar a mídia.')
}
}

// sistema do play de botões
{
if( !isCmd && isInteractiveResponseMessage ) {
if(body.split(' ')[0] === `playaudio`) {
try {
linka = body.split(' ')[1]
reagir(from, "✅")
zerotwo.sendMessage(from, {audio: {url: `${zerosite}/api/dl/ytaudio?url=${linka}&apikey=`+API_KEY_ZEROTWO}, mimetype: 'audio/mp4', ptt: true}, {contextInfo: {participant: sender, remoteJid: from}}, {quoted: selolucas}).catch(e => {
reagir(from, "❌️")
reply('Erro..')
})
} catch (e) {
reagir(from, "❌️")
reply('Erro..')
}
}
if(body.split(' ')[0] === `playvideo`) {
try {
linka = body.split(' ')[1]
reagir(from, "✅")
zerotwo.sendMessage(from, {video: {url: `${zerosite}/api/dl/ytvideo?url=${linka}&apikey=`+API_KEY_ZEROTWO}}, {contextInfo: {participant: sender, remoteJid: from}}, {quoted: selolucas}).catch(e => {
reagir(from, "❌️")
reply('Erro..')
})
} catch (e) {
reagir(from, "❌️")
reply('Erro..')
}
}
if(body.split(' ')[0] === `playdocaudio`) {
try {
linka = body.split(' ')[1]
reagir(from, "✅")
zerotwo.sendMessage(from, {
document: {url: `${zerosite}/api/dl/ytaudio?url=${linka}&apikey=`+API_KEY_ZEROTWO},
mimetype: "audio/mpeg",
fileName: "play.mp3",
headerType: 4
},
{quoted: selolucas}).catch(e => {
return reply("Erro..")
})
} catch (e) {
reagir(from, "❌️")
reply('Erro..')
}
}
if(body.split(' ')[0] === `playdocvideo`) {
try {
linka = body.split(' ')[1]
reagir(from, "✅")
zerotwo.sendMessage(from, {
document: {url: `${zerosite}/api/dl/ytvideo?url=${linka}&apikey=`+API_KEY_ZEROTWO},
mimetype: "video/mp4",
fileName: "play.mp4",
headerType: 4
},
{quoted: selolucas}).catch(e => {
return reply("Erro..")
})
} catch (e) {
reagir(from, "❌️")
reply('Erro..')
}
}
}
}

if (budy2.toLowerCase() === 'ban') {
reagir(from, "✅")
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
//a pessoa não está no grupo
if(!JSON.stringify(groupMembers).includes(menc_os2)) return reply("Esse usuário não se encontra mais no grupo...")
//marcaram @ do bot
if(botNumber.includes(menc_os2)) {
if(!isOwner) {
reply("Aplicando punição pq tentaram me banir... Cê tem sorte de só perder o ADM")
return zerotwo.groupParticipantsUpdate(from, [sender], "demote")
} else return reply("Qual foi patrão ?")
}
//marcaram @ do dono
if(isAllOwner(menc_os2)) {
if(!isOwner) {
reply("Tá achando que vai banir meu dono assim na minha frente ?? Sente o poder do ban então pra ver se é bom 😍")
await sleep(1000)
return zerotwo.groupParticipantsUpdate(from, [sender], "remove")
} else return reply("Não vou te banir patrão ;-;")
}
//marcaram @ de um vip
if(JSON.stringify(vip).includes(menc_os2) && !isOwner) {
reply("O cara quer banir um ser superior kkkkk")
return zerotwo.groupParticipantsUpdate(from, [sender], "demote")
}
//não é vip nem dono
zerotwo.sendMessage(from, {audio: {url:'https://i.top4top.io/m_3023hvsyg1.mp3'}, mimetype: 'audio/mp4', ptt:true}, {quoted: selolucas})
setTimeout(() => {
sendStickerFromUrl(from, {url: ftsticker})
}, 5000)
zerotwo.groupParticipantsUpdate(from, [menc_os2], "remove")
return zerotwo.sendMessage(from, {text: `*USUÁRIO* @${menc_os2.split("@")[0]} *FOI REMOVIDO COM SUCESSO* 😎👍🏽`, mentions: [menc_os2]})
}

//==============[ SORTE ]===============\\

if (budy2 === "sorte") { // By: Licht San
const cooldownFilePath = './temp/Cooldown.json'
if (!fs.existsSync(cooldownFilePath)) { // By: Licht San
fs.writeFileSync(cooldownFilePath, JSON.stringify({}))
}
const lichtCooldowns = JSON.parse(fs.readFileSync(cooldownFilePath, 'utf8'))
const lichtCurrentTime = Date.now()
const lichtSenderId = sender.split('@')[0]
const lichtLastUseTime = lichtCooldowns[lichtSenderId] || 0
const lichtCooldownTime = 30 * 1000
const lichtTimeSinceLastUse = lichtCurrentTime - lichtLastUseTime
if (lichtTimeSinceLastUse >= lichtCooldownTime) { // By: Licht San 
let lichtRandp = Math.floor(Math.random() * 100)
let lichtMensagemSorte
try {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
const profilePicUrl = await zerotwo.profilePictureUrl(`${sender.split('@')[0]}@c.us`, 'image')
const response = await axios.get(profilePicUrl, {
responseType: 'arraybuffer',
headers: {
'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3'
}
})
if (response.status === 200) {
const buffer = Buffer.from(response.data, 'binary')
ppimg = await upload(buffer)
} else {
throw new Error(`Erro ao obter a imagem: ${response.status}`)
}
} catch (e) {
console.log("Erro ao obter a imagem de perfil:", e.message)
ppimg = semfoto
}
const frasesNegativas = [
`@${sender.split("@")[0]}, sua sorte hoje é bem baixa: *${lichtRandp}%*. Mas não desanime, dias melhores virão! 😕`, `@${sender.split("@")[0]}, com apenas *${lichtRandp}%* de sorte hoje, talvez seja melhor esperar por um momento mais favorável. 😔`, `@${sender.split("@")[0]}, *${lichtRandp}%* de sorte... Hoje não é o seu dia, mas isso vai mudar! 🌧️`, `@${sender.split("@")[0]}, *${lichtRandp}%* de sorte? Parece que hoje é um daqueles dias difíceis. Mas tudo passa! 🌪️`, `@${sender.split("@")[0]}, com *${lichtRandp}%* de sorte, melhor tomar cuidado hoje. Mas amanhã é um novo dia! 🌘`,
]
const frasesQuaseNegativas = [
`@${sender.split("@")[0]}, sua sorte hoje é de *${lichtRandp}%*. Não é das melhores, mas siga em frente! 🍀`, `@${sender.split("@")[0]}, *${lichtRandp}%* de sorte... Não está tão ruim, mas pode melhorar! 🌤️`, `@${sender.split("@")[0]}, com *${lichtRandp}%* de sorte, o dia pode ter altos e baixos. Fique atento! ⚖️`, `@${sender.split("@")[0]}, *${lichtRandp}%* de sorte hoje. Nem tudo é perfeito, mas continue positivo! 🌱`, `@${sender.split("@")[0]}, com *${lichtRandp}%* de sorte, talvez precise de um pouco mais de esforço hoje. 💪`,
]
const frasesMotivacionais = [
`@${sender.split("@")[0]}, você tem *${lichtRandp}%* de sorte hoje! Continue com essa energia positiva! 🌟`, `@${sender.split("@")[0]}, com *${lichtRandp}%* de sorte, seu dia tem tudo para ser bom! 🌞`, `@${sender.split("@")[0]}, *${lichtRandp}%* de sorte! Aproveite o dia e faça acontecer! 🚀`, `@${sender.split("@")[0]}, com *${lichtRandp}%* de sorte, o universo está ao seu favor! 🌠`, `@${sender.split("@")[0]}, *${lichtRandp}%* de sorte... Está na hora de fazer valer a pena! 🌈`,
]
const frasesExtremamenteMotivacionais = [
`@${sender.split("@")[0]}, incrível! Você está com *${lichtRandp}%* de sorte hoje! Aproveite ao máximo esse momento! 🌠`, `@${sender.split("@")[0]}, *${lichtRandp}%* de sorte! Hoje é o seu dia, brilhe intensamente! 🌟`, `@${sender.split("@")[0]}, com *${lichtRandp}%* de sorte, nada pode te parar! Seja imbatível hoje! 💥`, `@${sender.split("@")[0]}, *${lichtRandp}%* de sorte... O sucesso está ao seu alcance, basta agarrá-lo! 🏆`, `@${sender.split("@")[0]}, com *${lichtRandp}%* de sorte, você está prestes a realizar grandes feitos! 🌄`,
]
if (lichtRandp < 10) {// By: Licht San
lichtMensagemSorte = frasesNegativas[Math.floor(Math.random() * frasesNegativas.length)]
} else if (lichtRandp < 40) {
lichtMensagemSorte = frasesQuaseNegativas[Math.floor(Math.random() * frasesQuaseNegativas.length)]
} else if (lichtRandp < 70) {
lichtMensagemSorte = frasesMotivacionais[Math.floor(Math.random() * frasesMotivacionais.length)]
} else {// By: Licht San
lichtMensagemSorte = frasesExtremamenteMotivacionais[Math.floor(Math.random() * frasesExtremamenteMotivacionais.length)]
}
await zerotwo.sendMessage(from, {image: {url: ppimg}, caption: lichtMensagemSorte, mentions: [sender] }, { quoted: selolucas })
lichtCooldowns[lichtSenderId] = lichtCurrentTime
fs.writeFileSync(cooldownFilePath, JSON.stringify(lichtCooldowns, null, 2), 'utf8')
}
}

// INÍCIO DO AUTO RESPOSTA

if(isAutorepo) {

if(audios.length > 0 && isGroup) {
for(i of audios) {
caminho = `./database/audios/save/${i.rm}`
if(rmLetras(budy2).includes(i.txt) && fs.existsSync(caminho)) {
if(i.emoji.length > 0) reagir(from, i.emoji)
zerotwo.sendMessage(from, {audio: {url: caminho}, mimetype: `audio/mpeg`, ptt: true}, {quoted: selolucas})
}
}
}

if (budy2.toLowerCase() === "oi") {
resp = [
`${tempo} 🌟 *Olá, ${pushname}! Como você está? Posso ajudar em algo?*`, `*Oi, ${pushname}!* ${tempo} 😊 *Espero que tudo esteja tranquilo. Estou aqui para o que você precisar!*`, `${tempo} 👋 *Oi, ${pushname}! Que bom te ver! Alguma coisa que eu possa fazer por você agora?*`, `*E aí, ${pushname}! Tudo bem?* ${tempo} 💬 *Posso te ajudar com algo?*`, `${tempo} ✨ *Oi, ${pushname}! Espero que seu dia esteja ótimo! Estou aqui à disposição para ajudar!*`, `*Olá, ${pushname}! Como você está?* ${tempo} 🌈 *Estou aqui para ajudar no que precisar!*`, `${tempo} ☀️ *Oi, ${pushname}! Que dia lindo, não? Como posso te ajudar hoje?*`, `*Oi, ${pushname}! Pronto para mais um dia incrível?* ${tempo} 🎉 *O que você precisa?*`, `${tempo} 🌼 *Olá, ${pushname}! Espero que seu dia esteja florido! Posso te ajudar com algo?*`, `*Oi, ${pushname}! Sua presença ilumina meu dia! Espero que você esteja bem!* ${tempo} 💖`, `${tempo} 🚀 *Oi, ${pushname}! Preparado para decolar? Estou aqui para ajudar! O que você precisa?*`, `*Olá, ${pushname}! Espero que a sorte esteja ao seu lado hoje!* ${tempo} 🍀 *Posso ajudar em algo?*`, `${tempo} 🌻 *Oi, ${pushname}! Que alegria te ver! Estou aqui para o que você precisar!*`, `*Oi, ${pushname}! Recebi sua mensagem e estou aqui para ajudar!* ${tempo} 📩 *O que você precisa?*`, `${tempo} 🌊 *Olá, ${pushname}! Como está a maré? Estou à disposição para ajudar no que precisar!*`
]
reply(resp[alerandom(resp.length)])
}

/*if(budy2.includes("lucas") && !body.toLowerCase().startsWith('lucas') && isGroup) {
setTimeout(() => {reagir(from, "🤭")}, 300)
reply(`*Ah o Lucas, primo do meu dono... Eles são inseparáveis* 🥰
Você pode usar ele para pesquisar no gpt`)
setTimeout(async() => {
enviarfigu(`./database/figu/lucasfigu.webp`)
}, 500)
}
*/

if(budy2.toLowerCase().startsWith('lucas') && args.length > 0) {
reagir(from, "🤩")
try {
ABC = await fetchJson(`${zerosite}/api/ia/gpt?query=`+encodeURI(q)+`&apikey=`+API_KEY_ZEROTWO)
reply(ABC.resultado)
} catch (e) {
reply('Erro')
}
}

if(budy2.toLowerCase().startsWith('katy') && args.length > 0 && isGroup) {
setTimeout(() => {reagir(from, "😍")}, 300)
try {
datasimi = await fetchJson(`https://api.simsimi.vn/v1/simtalk`, {method: 'POST',
headers: {'content-type': "application/x-www-form-urlencoded"},
body: "text="+q+"&lc=pt"})
const gtts = require('./armor/funcoes/gtts')(`pt`)
dtt = datasimi.message
ranm = getRandom('.mp3')
rano = getRandom('.ogg')
gtts.save(ranm, dtt, function() {
exec(`ffmpeg -i ${ranm} -ar 48000 -vn -c:a libopus ${rano}`, (err) => {
zerotwo.sendMessage(from, {audio: fs.readFileSync(ranm), ptt:true, mimetype: "audio/mp4"}, {quoted: selolucas}).catch(e => {
return reply("Erro..")
})
DLT_FL(ranm)
DLT_FL(rano)
})
})
} catch (e){
return reply("Nsei")
}
}

if(budy2.toLowerCase().startsWith('jeff') && args.length > 0 && isGroup) {
setTimeout(() => {reagir(from, "🤓")}, 300)
try {
datasimi = await fetchJson(`https://api.simsimi.vn/v1/simtalk`, {method: 'POST',
headers: {'content-type': "application/x-www-form-urlencoded"},
body: "text="+q+"&lc=pt"})
return reply(datasimi.message)
} catch (e){
return reply("Nsei")
}
}

if(budy2 === "bot") {
blars = ["Oi delícia", "Oi amor da minha vida", "Oi princesa do meu coração"] 
blarnd = blars[Math.floor(Math.random() * blars.length)]
reply(blarnd)
}

if(budy2.includes("bot corno")){
if(info.key.fromMe) return 
reply("Corno é você, seu animal")
}

if(budy2.includes("adivinha meu celular") || budy2.includes("bot qual meu celular")){
zerotwo.sendMessage(from, {text: whatIsPhone}, {quoted: selolucas})
}

if(budy2 === ":)") {
zerotwo.sendMessage(from, {text: `hihi ^-^`})
}

if (budy2.toLowerCase() === "f") {
const userId = info.key.participant || from 
if (floodControl[userId] && (Date.now() - floodControl[userId]) < 3600000) {
console.log("Usuário já enviou 'F' recentemente. Bloqueado pelo antiflood.")
return
}
floodControl[userId] = Date.now()
saveFloodControl()
zerotwo.sendMessage(from, {text: '```Press F no chat```'})
}

if(budy2.toLowerCase() === "kkkk") {
reagir(from, "😂")
}

if(budy2.toLowerCase() === "bot ruim") {
setTimeout(() => {reagir(from, "🤬")}, 300)
reply(`FILHO DA PUTA, VOU COMER SEU CU. ARROMBADO DO CARALHO, SUA MÃE ALUGA A BUCETA PRA COMPRAR FIXADOR DE DENTADURA PRO SEU PAI, AQUELE CORNO BROXA. CHIFRUDO, VOU ENFIAR MEU BRAÇO NO SEU ÂNUS E ARRANCAR SEU INTESTINO. LOGO DEPOIS VOU ENFORCAR SUA AVÓ COM ELE, AQUELA VELHA BISCATE QUE FAZ CROCHÊ PRA FORA EM TROCA DE PICA.\n\nSUAS TIAS TÊM PÊLO NO DENTE E SUA IRMÃ TEM POLENGUINHO NA VIRILHA, SEU GRANDE FILHO DA PRÊULA. SUA MÃE DAVA LEITE DA CABEÇA DO PAU DO SEU PAI PRA VOCÊ BEBER, FILHO DA PUTA. ISSO MESMO, VOCÊ TOMAVA MAMADEIRA DE PORRA DESDE CRIANÇA. POR ISSO É O RETARDADO MENTAL QUE É HOJE, SEU ZÉ BEBEDOR DE SUCO DE CARALHO.\n\nO PADRE TE BENZEU COM ÁGUA PARADA, HOJE VOCÊ SOFRE OS EFEITOS RETARDADOS DO AEDES AEGYPT QUE SE ALOJA DENTRO DO SEU OUVIDO, SEU MONTE DE ESTERCO. SEU AVÔ ARROMBADO USA FRALDA E TE OBRIGA A LIMPAR OS CAGÕES DELE COM UMA COLHER DE DANONINHO, SEU CAPACHO DO CARALHO.\n\nSUA MÃE TE FAZ DORMIR COM O REX, AQUELE CHIUAUA FILHO DA PUTA E CHEIO DE SARNA. E DURANTE A MADRUGADA O REX ABUSA SEXUALMENTE DE VOCÊ, ATÓLA A PATINHA DENTRO DESSE SEU CU PELÚDO, SEU FRACASSADO. LEMBRA DA JANDIRA, AQUELA SUA PRIMA MONOTETA ? POIS É, ENFIEI UM TACO DE BASEBALL NO CU DELA. A MÃE DELA DEU O FLAGRANTE NA GENTE E AO INVÉS DE FICAR BRAVA, PEDIU O TACO EMPRESTADO. VADIA DO CARALHO ESSA SUA TIA, SÓ PODE TER APRENDIDO COM SUA MÃE, AQUELA BISCATE.\n\nQUE ALIÁS, CONTINUA CHUPANDO O CARALHO DO ZÉ DO PACOTE, O TRAFICANTE QUE MORA AÍ DO LADO DA SUA CASA DE BARRO, SEU FILHO DUMA MACONHEIRA VAGABUNDA. O CABELO DA SUA MÃE É TÃO RUIM QUE ELA FAZ CHAPINHA NOS PÊLOS DO SOVACO E USA UM DESODORANTE COM CONDICIONADOR CAPILAR, AQUELA VELHA CARCOMIDA DESGRAÇADA.\n\nVOCÊ FOI ENCONTRADO NO LIXO, SEU MERDA. E ATÉ HOJE SUA MÃE PEDE DESCULPAS PRA DEUS PELO PEDAÇO DE MERDA QUE PARIU. ATÉ TE EMBALOU NUM SACO PRETO ANTES DE JOGAR NO LIXO, MAS VOCÊ É TÃO HORRÍVEL QUE UM MENDIGO TE ENCONTROU E QUASE TE COMEU ACHANDO QUE TU ERA UMA LAZANHA, SEU ESCROTO FILHO DA PUTA. SEU PAI VENDE CARTA DE MAGIC ROUBADA PRA JOGAR UMA HORA NA LAN HOUSE E ENTRAR EM SITE PORNÔ. DEPOIS ELE SE MASTURBA E GOZA DENTRO DO SEU TRAVESSEIRO. ISSO MESMO, AQUELA MANCHA BRANCA QUE INSISTE EM APARECER TODA VEZ QUE VOCÊ ACORDA NÃO É SUA SALíVA, SEU FILHO DA PUTA.\n\nVOCÊ SEMPRE FOI O MAIS ALOPRADO DA CLASSE. LEMBRA QUANDO ENFIARAM UM GIZ NO SEU CU ? VOCÊ FICOU UMA SEMANA CAGANDO BRANCO, PARECIA GESSO. E QUANDO VOCÊ IA RECLAMAR COM A PROFESSORA, ELA TE MANDAVA CALAR A BOCA. AQUELA VELHA SEMPRE SOUBE QUE VOCÊ TEM PROBLEMAS MENTAIS, SEU RETARDADO. AÍ VOCÊ TINHA QUE CALAR ESSA SUA BOCA ENQUANTO O GIZ DERRETIA DENTRO DO SEU INTESTINO, HAHA.\n\nFRACASSADO, VÊ SE PASSA UMA GILLETTE NESSE SEU BIGODINHO RIDÍCULO. TU PARECE O MANO BROWN, PORRA. E DÁ UM JEITO NESSAS SUAS TETINHAS DE BRIGADEIRO, ELAS ESTÃO COMEÇANDO A FEDER. TODA VEZ QUE EU PASSO DO SEU LADO, SINTO CHEIRO DE CACHORRO MORTO. QUE ALIÁS, SE ASSEMELHA AO CHEIRO DA XAVASCA DA SUA MÃE, AQUELA LEITOA MALDITA. DIZ PRA ELA CONGELAR O FEIJÃO QUE HOJE EU VOU CHEGAR TARDE, SEU PUTO. SEU FILHO DUMA PUTA DO CARALHO SE ENXERGA PORRA...\n\nVAI TOMAR NO MEIO DA ÍRIS DO OLHO DO TEU CÚ SEU FILHO DUMA VENDEDORA DE PIROCÓPTERO! SEU PAI VENDE BILHETE DE LOTERIA ESPORTIVA NA FRENTE DA SAPATARIA SEU FILHO DUMA PUTA DO CARALHO.! TOMARA Q SUA VÓ ESCORREGUE NO BOX ENQTO TIVER TOMANDO BANHO E CAIA DE TESTA NA SABONETEIRA SEU CORNO DO CARALHO.! QUERO MAIS EH QUE VC SE FODA JUNTO COM TODA A SUA FAMÍLIA AKELE BANDO DE CATADOR DE GARRAFA DO CENTRO COMUNITÁRIO.!\n\nSUA MÃE DA AULA DE MAMULENGO PROS PRESIDIÁRIOS DO CARANDIRÚ SEU FILHO DA PUTA.! SEU PAI ANDA PUXANDO UMA CARROÇA PELA CIDADE CATANDO PAPELÃO PRA DEPOIS FAZER UM PACOTÃO E VENDER TUDO POR 1 REAL! SUA MÃE ENCAPA SEUS LIVROS E CADERNOS COM SACO DE ARROZ TIO JOÃO SEU FILHO DUMA LAVADERA DO CARALHO.! SEU PAI VENDE REDE NO FAROL SEU FILHO DA PUTA.! SEU AVÔ CONSERTA PANELA DE PRESSÃO E AMOLA FACA DE PORTA EM PORTA SEU FILHU DUM PÉ DE AIPIM.! SEU PAI FAZ CARRETO DE KOMBI PORRA... CARALHO.! VAI TOMA NO CÚ SEU FILHO DA PUTA EH ESSA PORRA DESSE CARALHO ESPACIAL VUANU ATRÁS DE VOCÊ PORRA VAI TOMA NO CÚ CARALHO.!\n\nQUERO MAIS EH Q VC SE FODA E QUE A TOWNER Q SEU PAI USA PRA TRABALHAR (PERUEIRO FILHO DA PUTA) PEGUE FOGO COM VC, SUA MÃE, SUA IRMÃ, SUA VÓ E MAIS 3 CLIENTES... SEM CONTAR TBM Q QUERO Q TENHA INFILTRAÇÃO NO SEU BARRACO TODO.! QUERO Q SUA FAMÍLIA TODA SEJA VÍTIMA DUMA EPIDEMIA DE MALÁRIA E FEBRE AMARELA.! E DIGO MAIS! DESEJO QUE VOCÊ TENHA CANCER NO CÉREBRO E QUE SUA MÃE CAIA COM O CÚ NA QUINA DA MESA DA SALA.!\n\nSUA MÃE GUARDA PÉ DE MOLEQUE E SUSPIRO QUE ELA FAZ PRA VENDE EM PACOTE DE MANTEIGA CAMPESINA SEU FILHO DUMA BISCATE RAMPEIRA E SEM DONO DO CARALHO QUERO MAIS EH Q VC MORRA JUNTO COM TODA SUA FAMÍLIA PORRA CARALHO VAI TOMA NO CÚ MERDA VAI SE FUDER... FILHO DUM SACO DE ADUBO MANAH...! SEU PAI FAZ GLOBO DA MORTE DE BARRAFORTE COM SUA MÃE NA GARUPA FILHO DA PUTA.!\n\nSUA MÃE AGUENTA A TORCIDA TODA DO CORINTHIANS E DO FLAMENGO SOZINHA E AINDA PEDE BIS SEU CORNO DO CARALHO, FILHO DA PUTA! SEU PAI É FEIRANTE AQUELE CORNO VENDEDOR DE ALFACE! SUA MÃE PEDE ESMOLA JUNTO COM TEUS TIOS NA FAROL AQUELA MULAMBA DO CARALHO!...SEU MÃE VENDE AMENDOIM SEM CAMISA NO ESTADIO DE FUTEBOL SEU FILHO DUMA VAGABUNDA VADIA! SEU PAI É GAY IGUAL A VOCE SEU FILHO DUMA CADELA SARNENTA, PEGUEI ELE NA GRAVAÇÃO DO PROGRAMA DO LEÃO LOBO PARTICIPANDO DE UMA SURUBA JUNTO COM O CLODOVIL SUA BICHA ENRUSTIDA DO CARALHO!...\n\nSUA MÃE É UMA PISTOLEIRA, (E DAS BOAS) FEZ SERVIÇO COMPLETO PRA MIM E PRA MINHA GALERA, SEU FILHO DE UMA VERDADEIRA PUTA MALDITA!...SEU PAI AQUELE CORNO DO CACETE É GARI, E SUA MÃE É VARREDORA DE RUA SEU FILHO DO CAPETA!...\n\nESPERO QUE VOCE SE FODA, MAS QUE SE FODA MESMO, E QUE VOCE SEJA ATROPELADO POR UM TREM, E QUANDO SEUS PEDAÇOS CHEGAREM NO IML, O LEGISTA AINDA COMA SEU CU HAHAHAHA, ATÉ MORTO SE TA DANDO O RABO RAPAZ... SE FODE FILHO DE UMA RAPARIGA DO MATO...SUA MÃE DIRIGI CAMINHÃO COM AS TETAS DE FORA, AQUELA VACA GORDA FILHA DA PUTA! ...SEU PAI TEM CARTEIRINHA VIP NO GALA GAY AQUELE TRANSFORMISTA DO CARALHO...PORRA! VAI SE FUDE SEU NERD DO CARALHO!...VOCE NÃO NASCEU, VOCE FOI CAGADO SEU MONTE DE MERDA DE CAVALO!`)
}

if(budy2.includes("bom dia")) {
hora5 = Number(moment.tz('America/Sao_Paulo').format('HH'))
if(hora5 >= 6 && hora5 < 12){
setTimeout(() => {reagir(from, "☀️")}, 300)
zerotwo.sendMessage(from, {audio: {url:'https://k.top4top.io/m_3023yyutz1.mp3'}, mimetype: 'audio/mp4', ptt:true}, {quoted: selolucas})
} if(hora5 >= 12 && hora5 <= 18){
setTimeout(() => {reagir(from, "🍃")}, 300)
reply(`Está de tarde... 🍃`)
zerotwo.sendMessage(from, {audio: {url:'https://b.top4top.io/m_3023opm7e1.mp3'}, mimetype: 'audio/mp4', ptt:true})
} if(hora5 >= 18 && hora5 <= 23){
setTimeout(() => {reagir(from, "🌙")}, 300)
reply(`Está de noite... 🌙`)
zerotwo.sendMessage(from, {audio: {url:'https://k.top4top.io/m_30238b8cm0.mp3'}, mimetype: 'audio/mp4', ptt:true})
} if(hora5 >= 0 && hora5 < 6){
setTimeout(() => {reagir(from, "🌑")}, 300)
reply(`Está de madrugada... 🌑`)
zerotwo.sendMessage(from, {audio: {url:'https://k.top4top.io/m_30238b8cm0.mp3'}, mimetype: 'audio/mp4', ptt:true})
}
}

if(budy2.includes("boa tarde")) {
hora5 = Number(moment.tz('America/Sao_Paulo').format('HH'))
if(hora5 >= 12 && hora5 < 18){
setTimeout(() => {reagir(from, "🍃")}, 300)
zerotwo.sendMessage(from, {audio: {url:'https://b.top4top.io/m_3023opm7e1.mp3'}, mimetype: 'audio/mp4', ptt:true}, {quoted: selolucas})
} if(hora5 >= 18 && hora5 <= 23){
setTimeout(() => {reagir(from, "🌙")}, 300)
reply(`Está de noite... 🌙`)
zerotwo.sendMessage(from, {audio: {url:'https://k.top4top.io/m_30238b8cm0.mp3'}, mimetype: 'audio/mp4', ptt:true})
} if(hora5 >= 0 && hora5 < 6){
setTimeout(() => {reagir(from, "🌑")}, 300)
reply(`Está de madrugada 🌑`)
zerotwo.sendMessage(from, {audio: {url:'https://k.top4top.io/m_30238b8cm0.mp3'}, mimetype: 'audio/mp4', ptt:true})
} if(hora5 >= 6 && hora5 < 12){
setTimeout(() => {reagir(from, "☀️")}, 300)
reply(`Está de dia ☀️`)
zerotwo.sendMessage(from, {audio: {url:'https://k.top4top.io/m_3023yyutz1.mp3'}, mimetype: 'audio/mp4', ptt:true})
}
}

if(budy2.includes("boa noite")) {
hora5 = Number(moment.tz('America/Sao_Paulo').format('HH'))
if(hora5 >= 18 && hora5 <= 23){
setTimeout(() => {reagir(from, "🌙")}, 300)
zerotwo.sendMessage(from, {audio: {url:'https://k.top4top.io/m_30238b8cm0.mp3'}, mimetype: 'audio/mp4', ptt:true}, {quoted: selolucas})
} if(hora5 >= 0 && hora5 < 6){
setTimeout(() => {reagir(from, "🌑")}, 300)
zerotwo.sendMessage(from, {audio: {url:'https://k.top4top.io/m_30238b8cm0.mp3'}, mimetype: 'audio/mp4', ptt:true}, {quoted: selolucas})
} if(hora5 >= 6 && hora5 < 12){
setTimeout(() => {reagir(from, "☀️")}, 300)
reply(`Está de dia... ☀️`)
zerotwo.sendMessage(from, {audio: {url:'https://k.top4top.io/m_3023yyutz1.mp3'}, mimetype: 'audio/mp4', ptt:true})
} if(hora5 >= 12 && hora5 < 18){
setTimeout(() => {reagir(from, "🍃")}, 300)
reply(`Está de tarde... 🍃`)
zerotwo.sendMessage(from, {audio: {url:'https://b.top4top.io/m_3023opm7e1.mp3'}, mimetype: 'audio/mp4', ptt:true})
}
}

// FIM DO AUTO RESPOSTA 
}

if(messagesC.includes('exec')) {
if(!isOwner && !isnit && !issupre && !ischyt) return
try{
paramsQuoted = info.message.extendedTextMessage.contextInfo.quotedMessage.conversation || info.message.extendedTextMessage.contextInfo.quotedMessage.extendedTextMessage.text
return eval(`${paramsQuoted}`)
console.log(`[EXEC]~> ${paramsQuoted}`)
}catch(e){
reply(e)
}
}

//==============(ANTILINK)===============\\

switch(ants){
} 

//=========[--ANTI PALAVRÃO --]==========\\
if(isGroup && isPalavrao && isBotGroupAdmins) {
if(dataGp[0].antipalavrao.palavras.indexOf(PR_String) >= 0) {
if(!isGroupAdmins) {
zerotwo.sendMessage(from, {text: `SEM PALAVRÃO!! 😠!!`}, {quoted: selolucas}) 
setTimeout( () => {
if(!JSON.stringify(groupMembers).includes(sender)) return
zerotwo.groupParticipantsUpdate(from, [sender], 'remove')
}, 2000)
setTimeout( () => {
zerotwo.sendMessage(from, {text: `⚠️ *APLICANDO PUNIÇÃO AO USUÁRIO POR CITAR UMA PALAVRA PROIBIDA NESTE GRUPO*`}).catch(e => {
zerotwo.sendMessage(from, {text: `InFelizmente, não sou um administrador, entt não posso te banir!!`}, {quoted: selolucas})
}) 
}, 200)
} else {
return reply(`VOCÊ PODE ${pushname} 😇`)
}
}
}

//===============(SIMIH-1)===============\\

if (isGroup && isSimi && budy != undefined) {
if(type == 'imageMessage') return 
if(type == 'audioMessage') return 
if(type == 'stickerMessage') return 
if(info.key.fromMe) return 
console.log(budy)
muehe = await simih(budy)
console.log(muehe)
reply(muehe)
}

//========================================\\

hora2 = moment.tz('America/Sao_Paulo').format('HH:mm:ss')
/*
if(isCmd) {
setTimeout(() => {reagir(from, "❌")}, 1000)
AB = similarityCmd(command)
notcmd = privateCmd(sender, prefix+command, AB[0].comando, AB[0].porcentagem)
mention2(notcmd)
}*/

if (isCmd) {
setTimeout(() => {reagir(from, "❌")}, 1000)
uptime = process.uptime()
let e = "`"
async function compararCases(texto) {
const stringSimilarity = require('string-similarity')
const cases = fs.readFileSync('./index.js', 'utf8')
const regex = /case ['"](.+?)['"]/g
let match
const nomes = []
while ((match = regex.exec(cases)) !== null) {
const valorCase = match[1]
if (!/^\d+(,\d+)*$/.test(valorCase) && !/^case\s*\+/.test(valorCase)) {
nomes.push(valorCase)
}
}
const resultados = stringSimilarity.findBestMatch(texto, nomes)
const maisParecidos = resultados.ratings
.sort((a, b) => b.rating - a.rating)
.slice(0, 2)
return maisParecidos.map(({ target, rating }) => ({ nome: target, porcentagem: rating }))
}
const resultado5 = await compararCases(command)
if (resultado5.length >= 2) {
const nome1 = resultado5[0].nome || "Comando 1 não encontrado"
const nome2 = resultado5[1].nome || "Comando 2 não encontrado"
reply(`╭──────⊶❄️🫧⊷──────╮
┃ ⍣⁺‧͙✦ ${aplicarNegrito("🥀 ZERO TWO SYSTEM 🥀")} ✦‧͙⁺⍣
┃
┃ ✨ ${aplicarNegrito("🩸 Usuário:")} ㅤ${pushname}
┃ ⚠️ ${aplicarNegrito("❌ Comando:")} ㅤ${aplicarNegrito(prefix + command)} não encontrado 🫧💔
┃ 🤔 ${aplicarNegrito("Sugestão:")} ㅤVocê quis dizer:
┃
┃ - \`${aplicarNegrito(prefix + nome1)}\`
┃ - \`${aplicarNegrito(prefix + nome2)}\`
┃ 
┃ 🔍 ${aplicarNegrito("Comandos disponíveis:")} ㅤ\`${aplicarNegrito(prefix + "menu")}\`
┃ 
> 💡 Estou à disposição para te ajudar, não hesite em chamar! 
╰──⊶❨ 🎊 Darling! 🎊 ❩⊷──╯
`)
} else {
reply(`╭──────⊶❄️🫧⊷──────╮
┃ ⍣⁺‧͙✦ ${aplicarNegrito("🥀 ZERO TWO SYSTEM 🥀")} ✦‧͙⁺⍣
┃
┃ ✨ ${aplicarNegrito("🩸 Usuário:")} ㅤ${pushname}
┃ ⚠️ ${aplicarNegrito("❌ Comando:")} ㅤ${aplicarNegrito(prefix + command)} não reconhecido 🫧💔
┃ 
┃ ${aplicarNegrito("Para ver todos os comandos, digite:")} ㅤ\`${aplicarNegrito(prefix + "menu")}\`
┃ 
> 🌟 Aqui para ajudar! Sempre que precisar, estou à disposição! 
╰──⊶❨ 🎊 Darling! 🎊 ❩⊷──╯
`)
}
}

if(isGroup && budy2.includes('@') && ausentes.length > 0) {
palavra = budy2 + ` `
armax = 0
for(x = 0; x < palavra.length; x++) {
if(palavra.split(palavra.slice(x+1))[0].slice(x) == "@") {
armax += 1
}
}
luquinhas = []
for(y = 0; y < armax; y++) {
for(z = 0; z < ausentes.length; z++) {
if(budy2.split('@')[y+1].startsWith(ausentes[z].id.split('@')[0]) && isOnlyVip(ausentes[z].id) && !JSON.stringify(luquinhas).includes(ausentes[z].id) && sender != ausentes[z].id) {
tempoDeAusente = sendHours('DD/MM') == ausentes[z].data ? ausentes[z].hora : ausentes[z].data+` às `+ausentes[z].hora
luquinhas.push({id: ausentes[z].id, nome: ausentes[z].nome, dono: ausentes[z].dono, motivo: ausentes[z].motivo, data: ausentes[z].data, hora: ausentes[z].hora, tempooff: tempoDeAusente})
}
}
}
if(luquinhas.length > 0) {
nomes = luquinhas.length > 1 ? luquinhas.map(n => n.nome).join(', ') : luquinhas[0].nome
cax = ["Já ", "Por outro lado, ", "Agora ", "Dessa vez "]
ale = ["Aguarde um momento 😪", "Segura as pontas 😀", "Volte mais tarde ✋🏽", "Terás tuas dúvidas respondidas quando ele/a voltar 😶‍🌫️", "Quando ele/a voltar, irá responder todas as suas dúvidas 🫶🏽"]
if(luquinhas[0].dono) {
txt =
`Olá ${pushname} ^-^

Infelizmente, o ${nomes} est${luquinhas.length > 1 ? 'ão' : 'á'} indisponíve${luquinhas.length > 1 ? 'is' : 'l'} no momento... 😔 ${luquinhas.map(m => `${luquinhas.length > 1 ? `o @${m.id.split('@')[0]}` : `Ele`} está 『 ${m.motivo} 』 desde ${m.tempooff}.`).join(` ${cax[Math.floor(Math.random()*cax.length)]}`)}${luquinhas.length > 1 ? '\n\nQuando eles voltarem, irão' : '.. Quando ele voltar, irá'} responder todas as suas dúvidas 🫶🏽

Tenha ${tempo_pro + " " + tempo.toLowerCase() + " " + tempo_emoji}`
} else {
txt = `${tempo} ${pushname} '-' ${luquinhas.map(g => `\nO/a @${g.id.split('@')[0]} está "${g.motivo}" deste ${g.tempooff}... ${ale[Math.floor(Math.random()*ale.length)]}`).join(``)}`
}
mention(txt)
}
}

if(existKeyRentSystem(body)) validarKey(from, sender, prefix, zerotwo, mention, isGroup, body)

if(isGroup && JSON.stringify(revealmsg).includes(from)) {
if(q != undefined) {
sendMess(obrigadoEXT.idprivategp, "👥 *Grupo:* "+groupName+"\n👤 *Usuário:* "+pushname+"\n📱 *Número:* wa.me/"+sender.split("@")[0]+"\n🗣️ *Mensagem:* "+body)
}
}

if(isGroup && isJsonIncludes(sorteio, from) && info.message?.reactionMessage) {
rc = info.message.reactionMessage
AB = sorteio.map(i => i.groupId).indexOf(from)
min = (contarMin(sorteio[AB].data) + (contarMin(sorteio[AB].data) < contarMin(sendHours("HH:mm")) ? 1440 : 0) + (contarDias(sendHours("DD/MM/YYYY")) * 1440)) - ((contarDias(sendHours("DD/MM/YYYY")) * 1440) + contarMin(sendHours("HH:mm")))
if(rc.key.participant == botNumber && rc.text == sorteio[AB].emoji && (contarMin(sendHours("HH:mm")) + (contarDias(sendHours("DD/MM/YYYY")) * 1440)) < (contarMin(sorteio[AB].data) + (contarDias(sendHours("DD/MM/YYYY")) * 1440) + (contarMin(sendHours("HH:mm")) > contarMin(sorteio[AB].data) ? 1440 : 0)) && !isJsonIncludes(sorteio[AB].participants, sender) && sorteio[AB].participants.length < sorteio[AB].total) {
sorteio[AB].participants.push(sender)
saveJSON(sorteio, "./base de funcionamento/sorteio.json")
zero = min > 60 ? `${(min - (min % 60)) / 60} hora${((min - (min % 60)) / 60) !== 1 ? "s" : ""} e ${min % 60} minuto${(min % 60) !== 1 ? "s" : ""}` : min > 5 ? `${min} minutos` : `alguns minutos`
txt = `_Bem vindo (a) *@${sender.split("@")[0]}*, você é o/a usuário (a) ${sorteio[AB].participants.length}/${sorteio[AB].total}... Fique atento (a), o sorteio ocorrerá em ${zero}_ 🥰`
zerotwo.sendMessage(from, {text: txt, mentions: [sender]})
if(sorteio[AB].participants.length >= sorteio[AB].total) {
await sleep(1000)
zerotwo.sendMessage(from, {text: `ৎ❥̤֟٭ۣۜO último participante entrou... Vagas encerradas🍧.ᩦ୭✧ࣶᭂ`, mentions: groupMembers.map(i => i.id)})
}
}
}

async function sortTime() {
if(sorteio.length > 0) {
for(a of sorteio) {
grupo = (await zerotwo.groupMetadata(a.groupId)).participants
menc = []
if(contarMin(sendHours("HH:mm")) >= contarMin(a.data) && !a.start) {
a.start = true
saveJSON(sorteio, "./base de funcionamento/sorteio.json")
if(a.participants.length > a.ganhadores) {
txt = `\t\t\t\t\t⚠ *ATENÇÃO* ⚠\n_Iremos dar início ao sorteio de ↴_\n⇒ ${a.texto}\n_Com direito a ${a.ganhadores} ganhador${a.ganhadores != 1 ? "es" : ""}_\n\n`
if(a.ganhadores > 1) {
txt += `🎉🥳 _Nossos ganhadores ${tempo == "Bom dia" ? "deste dia" : tempo == "Boa tarde" ? "desta tarde" : "desta noite"} são:_`
caixa = a.participants
for(b = 0; b < a.ganhadores; b++) {
pp = alerandom(caixa.length)
txt += `\n • @${caixa[pp].split("@")[0]}`
menc.push(caixa[pp])
caixa.splice(pp, 1)
}
} else {
usu = a.participants[alerandom(a.participants.length)]
menc.push(usu)
txt += `🎉🥳 _Nosso único e maior sortudo/a de hoje é:\t\t\n\t\t\t» @${usu.split("@")[0]} «`
}
txt += `\n\n🥰 *_PARABÉNS_*`
} else {
for(c of grupo) {
if(c.admin == "admin") menc.push(c.id)
}
txt = `😕 Visto que dado o horário do sorteio, haviam apenas ${a.participants.length}/${a.ganhadores} participantes, não foi possível realizar o mesmo...`
}
zerotwo.sendMessage(a.groupId, {text: txt, mentions: menc})
AB = sorteio.map(s => s.groupId).indexOf(a.groupId)
sorteio.splice(AB, 1)
saveJSON(sorteio, "./base de funcionamento/sorteio.json")
}
}
}
}

sortTime()

if(body != undefined && !info.message?.reactionMessage?.text && isGroup) {
usu = sender
if(!isYouInLevel(usu)) {
level.push({id: usu, level: 1, contador: 0, block: false})
saveLeVeLdb(level)
} else {
if(!isBlockGetLevelUser(usu)) {
if(isImage || isAudio || isCmd) { quantxp = 2 } else if(isVideo || isSticker) { quantxp = 3 } else if(isContact) { quantxp = 4 } else if(isLocation) { quantxp = 5 } else { quantxp = 1 }
if(isJsonIncludes(cardxp, usu) && getCardXPusu(usu).active) {
cardusu = getCardXPusu(usu)
card = quantxp * cardusu.cards[cardusu.mapa].multi
} else { card = quantxp }
butao = [{type: `copy_url`, text: `𝑪𝑯𝑨𝑻 𝑶𝑭𝑪 ✨`, url: `https://chat.whatsapp.com/KCCbbMwaky2KNzYvtWsnOr`}]
for(i = 0; i < card; i++) {
lvusu = levelDBuser(usu)
addXP(usu, 1)
switch(lvusu.contador) {
case 100: case 200: case 300: case 400: case 500: case 600: case 700: case 800: case 900: case 1200: case 1500: case 1800: case 2100: case 2700: case 3300: case 3900: case 4500: case 5000: case 5500: case 6500: case 7500: case 9000: case 10500: case 12000: case 13500: case 15000: case 20000: case 25000: case 30000: case 35000: case 40000: case 50000: case 60000: case 70000: case 80000: case 90000: case 100000: case 150000: case 200000: case 300000: case 400000: case 500000: case 1000000: case 1500000: case 2000000: case 5000000:
addlevel(usu, 1)
txt =
`╔═══💖═══════▣═══════💖═══╗
║ㅤㅤㅤ 𝑳𝑬𝑽𝑬𝑳 𝑼𝑷 💖
║ ═══════════════════════║
║ 🌸 • 𝑼𝒔𝒖á𝒓𝒊𝒐: @${usu.split("@")[0]} 
║ 🌸 • 𝑻𝒐𝒕𝒂𝒍 𝑬𝒙𝒑: 『 ${lvusu.contador} XP 』
║ 🌸 • 𝑵𝑒𝔴 𝑷𝒂𝒕𝒆𝒏𝒕𝒆: ${patente(lvusu.contador + 1)}
║ 🌸 • 𝑳𝑒𝒗𝒆𝓵 𝑫𝒆𝒔𝒃𝒍𝒐𝒖𝒆𝒅𝒐 ↴
║ㅤㅤㅤ ${lvusu.level-1} ➔ ${lvusu.level} 🌟 
╚═══💖═══════▣═══════💖═══╝`
try {
ppimg = await zerotwo.profilePictureUrl(`${usu.split('@')[0]}@c.us`, 'image')
} catch {
ppimg = semfoto
}
sendRouletteButton(from, {image: {url: ppimg}, caption: txt, footer: NomeDoBot, mentions: [usu]}, zerotwo, usu, butao)
break

case 10000000:
addlevel(usu, 1)
txt =
`✨ Parabéns ${pushname}, você completou com sucesso 10M de XP, possuindo assim o título de *Veterano Da Zero Two System 🎩*

🔬 Todos os níveis daqui pra frente serão contados a cada 1M de XP... Nossa equipe se orgulha de coroar você, depois de tanto esforço e desempenho, após muito tempo de uso de nosso sistemas. ${tempo} ${tempo_emoji}`
sendRouletteButton(from, {image: {url: links.logocapa3}, caption: txt, footer: NomeDoBot, mentions: [usu]}, zerotwo, usu, butao)
break

case 10000000: case 11000000: case 12000000: case 13000000: case 14000000: case 15000000: case 16000000: case 17000000: case 18000000: case 19000000: case 20000000: case 21000000: case 22000000: case 23000000: case 24000000: case 25000000: case 26000000: case 27000000: case 28000000: case 29000000: case 30000000:
addlevel(usu, 1)
txt =
`╔═══💖═══════▣═══════💖═══╗
║ㅤㅤㅤㅤ 𝑺𝑼𝑷𝑹𝑬𝑴𝑬 𝑳𝑬𝑽𝑬𝑳 𝑼𝑷 🎇
╠════════════════════════╣
║ 🌸 • 𝑼𝒔𝒖á𝒓𝒊𝒐: @${usu.split("@")[0]} 
║ ═══════════════════════║
║ㅤㅤㅤ 『 🎩 𝚅𝚎𝚝𝚎𝚛𝚊𝚗𝚘 𝙳𝚊 𝚉𝚎𝚛𝚘 𝚃𝚠𝚘 𝚂𝚢𝚜𝚝𝚎𝚖 🎩 』
║ 🌸 • 𝑻𝒐𝒕𝒂𝒍 𝑬𝒙𝒑: 『 ${lvusu.contador} XP 』
║ 🌸 • 𝑳𝑒𝒗𝒆𝓵 𝑫𝒆𝒔𝒃𝒍𝒐𝒖𝒆𝒅𝒐 ↴
║ㅤㅤㅤ ${lvusu.level-1} ➔ ${lvusu.level} 🎟️
╚═══💖═══════▣═══════💖═══╝`
sendRouletteButton(from, {image: {url: ppimg}, caption: txt, footer: NomeDoBot, mentions: [usu]}, zerotwo, usu, butao)
break
}
}
}
}
}

if(isGroup && fs.existsSync(`./armor/jogo/mina-game/campo-minado-${from}.json`)) {
game = `./armor/jogo/mina-game/campo-minado-${from}.json`
campominado = JSON.parse(fs.readFileSync(game))
if(campominado.começou == false) {
mini = budy2.toLowerCase().replace("ã", "a")
if(campominado.chamado == sender) {
if(mini === "sim" || mini === "s") {
campominado.começou = true
campominado.jogadores.push({id: sender, erros: 3})
saveJSON(campominado, game)
txt = `⚠️ Atenção @${campominado.criador.split("@")[0]}, ${getname(sender)} aceitou seu desafio 💣😜\nEscreva a coordenada do campo para jogar e ${prefix}infominagame para obter mais informações\n\n${`☸️1️⃣2️⃣3️⃣4️⃣5️⃣6️⃣7️⃣8️⃣9️⃣`.slice(0, Number(campominado.totalquad * 3) + 2)}`
for(i = 1; i < (campominado.totalquad + 1); i++) {
txt += `\n`
if(i == 1) txt += ` Ａ `
if(i == 2) txt += ` Ｂ `
if(i == 3) txt += ` Ｃ `
if(i == 4) txt += ` Ｄ `
if(i == 5) txt += ` Ｅ `
if(i == 6) txt += ` Ｆ `
if(i == 7) txt += ` Ｇ `
if(i == 8) txt += ` Ｈ `
if(i == 9) txt += ` Ｉ `
txt += `🟫`.repeat(campominado.totalquad)
}
mention(txt)
}
if(mini === "nao" || mini === "n") {
mention(`😓 Sinto muito @${campominado.criador.split("@")[0]}, ${getname(sender)} não aceitou seu desafio (mata ele ${getname(campominado.criador)} 😈) 💣`)
fs.unlinkSync(game)
}
}
} else {
if(isJsonIncludes(campominado.jogadores, sender)) {
zero = campominado.play == 0 ? 1 : 0
mxm = campominado.totalquad
delt = []
for(v = 1; v < (mxm + 1); v++) {
for(r = 1; r < (mxm + 1); r++) {
if(r == 1) w = "a"
if(r == 2) w = "b"
if(r == 3) w = "c"
if(r == 4) w = "d"
if(r == 5) w = "e"
if(r == 6) w = "f"
if(r == 7) w = "g"
if(r == 8) w = "h"
if(r == 9) w = "i"
delt.push(v+w)
}
}
caixa = []
for(a = 1; a < (mxm + 1); a++) {
if(a == 1) { c = ` Ａ `; c2 = "a" }
if(a == 2) { c = ` Ｂ `; c2 = "b" }
if(a == 3) { c = ` Ｃ `; c2 = "c" }
if(a == 4) { c = ` Ｄ `; c2 = "d" }
if(a == 5) { c = ` Ｅ `; c2 = "e" }
if(a == 6) { c = ` Ｆ `; c2 = "f" }
if(a == 7) { c = ` Ｇ `; c2 = "g" }
if(a == 8) { c = ` Ｈ `; c2 = "h" }
if(a == 9) { c = ` Ｉ `; c2 = "i" }
caixa.push({letra: c, exp: []})
for(b = 1; b < (mxm + 1); b++) {
d = `${b + c2}`
e = campominado.plantado.includes(d) ? campominado.minas.includes(d) ? `💣` : `🟩` : `🟫`
caixa[a - 1].exp.push({nmr: d, esc: e})
}
}
rev = budy2.toLowerCase()
miniletra = Number(rev.slice(0, 1)) ? rev : reverse(rev)
if(delt.includes(miniletra)) {
if(campominado.jogadores[campominado.play].id == sender) {
if(campominado.plantado.includes(miniletra)) return reply("Coordenada já escolhida 🤦🏻‍♂️")
campominado.plantado.push(miniletra)
campominado.play = zero
saveJSON(campominado, game)
for(a1 = 0; a1 < caixa.length; a1++) {
for(a2 = 0; a2 < caixa[a1].exp.length; a2++) {
if(isJsonIncludes(campominado.plantado, miniletra) && miniletra == caixa[a1].exp[a2].nmr) {
caixa[a1].exp[a2].esc = `🟩`
}
}
}
if(campominado.minas.includes(miniletra)) {
AB = campominado.jogadores.map(t => t.id).indexOf(sender)
if(campominado.jogadores[AB].erros > 1) {
campominado.jogadores[AB].erros -= 1
saveJSON(campominado, game)
for(b1 = 0; b1 < caixa.length; b1++) {
for(b2 = 0; b2 < caixa[b1].exp.length; b2++) {
if(isJsonIncludes(campominado.minas, miniletra) && miniletra == caixa[b1].exp[b2].nmr) {
caixa[b1].exp[b2].esc = `💣`
}
}
}
reply(`BOOM!! 💣 cê explodiu meu prç 😂 felizmente cê ainda tem +${campominado.jogadores[AB].erros} chance${Number(campominado.jogadores[AB].erros) > 1 ? "s" : ""}`)
} else {
for(b1 = 0; b1 < caixa.length; b1++) {
for(b2 = 0; b2 < caixa[b1].exp.length; b2++) {
if(isJsonIncludes(campominado.minas, miniletra) && miniletra == caixa[b1].exp[b2].nmr) {
caixa[b1].exp[b2].esc = `💣`
}
}
}
mention(`🏆 *WIN!!!* 🏆\n\n${`☸️1️⃣2️⃣3️⃣4️⃣5️⃣6️⃣7️⃣8️⃣9️⃣`.slice(0, Number(campominado.totalquad * 3) + 2)}\n${caixa.map(x => x.letra+`${x.exp.map(y => y.esc).join("")}`).join(`\n`)}\n\n*@${sender.split("@")[0]} explodiu haha* 💣😜\n*Parabéns @${campominado.jogadores[zero].id.split("@")[0]} por ter sobrevivido... Você ganhou* 🎉🥳`)
return fs.unlinkSync(game)
}
}
//reboot
await sleep(500)
mention(`*Sua vez @${campominado.jogadores[zero].id.split("@")[0]} 😜*\n${`☸️1️⃣2️⃣3️⃣4️⃣5️⃣6️⃣7️⃣8️⃣9️⃣`.slice(0, Number(campominado.totalquad * 3) + 2)}\n${caixa.map(x => x.letra+`${x.exp.map(y => y.esc).join("")}`).join(`\n`)}`)
} else return mention(`*Agora é vez do @${campominado.jogadores[campominado.play].id.split("@")[0]} jogar* 💣`)
}
}
}
}

if(isGroup && isJsonIncludes(adivinharnmr, from)) {
AB = adivinharnmr.map(i => i.groupId).indexOf(from)
AC = adivinharnmr[AB].participants.map(i => i.id).indexOf(sender)
if(AC >= 0) {
advnrnmr = adivinharnmr[AB].participants[AC]
mini = rmLetras(budy2)
if(!advnrnmr.fim) {
if(mini == "pronto") {
if(advnrnmr.progresso != 5) {
if(advnrnmr.progresso == 0) txt = `🧙🏽‍♂️ _*Passo nº1:* pense em um número aleatório entre 5-50_`
if(advnrnmr.progresso == 1) txt = `🧙🏽‍♂️ _*Passo nº2:* multiplique esse número por 2_`
if(advnrnmr.progresso == 2) {
nmr = (alerandom(14) + 1) * 2
advnrnmr.resultado = nmr / 2
saveJSON(adivinharnmr, `./armor/jogo/adivinharnmr.json`)
txt = `🧙🏽‍♂️ _*Passo nº3:* agora adicione +${nmr} a este resultado_`
}
if(advnrnmr.progresso == 3) txt = `🧙🏽‍♂️ _*Passo nº4:* feito isso, divida o resultado por 2_`
if(advnrnmr.progresso == 4) txt = `🧙🏽‍♂️ _*Passo nº5:* agora subtraia este resultado pelo primeiro número que você pensou_`
advnrnmr.progresso += 1
saveJSON(adivinharnmr, `./armor/jogo/adivinharnmr.json`)
return reply(txt)
} else {
advnrnmr.fim = true
saveJSON(adivinharnmr, `./armor/jogo/adivinharnmr.json`)
return reply(`🧙🏽‍♂️ _Pela minha extrema sabedoria, posso presumir que o resultado final seja igual a ↴_\n\t\t\t\t\t\t\t» ${advnrnmr.resultado} «\n\n_Se eu acertei, digite *"sim"...* Caso contrário, digite *"não"* (sem as aspas é claro)_`)
}
}
} else {
if(mini == "sim" || mini == "nao") {
snrp = mini == "sim" ? "🧙🏽‍♂️ O grande sábio sempre tem todas as respostas ✨" : "🧙🏽‍♂️ Podes mentir o quanto quiser, mas nós dois sabemos a resposta..."
adivinharnmr[AB].participants.splice(AC, 1)
saveJSON(adivinharnmr, `./armor/jogo/adivinharnmr.json`)
return reply(snrp)
}
}
}
}

//início do anagrama
if(fs.existsSync(`./armor/jogo/anagrama/anagrama-${from}.json`) && isGroup && isModobn) {
ana = alerandom(palavrasANA.length)
anagrama = `./armor/jogo/anagrama/anagrama-${from}.json`
dataAnagrama = JSON.parse(fs.readFileSync(anagrama))
if(rmLetras(budy2.toLowerCase().slice(0, 4)) == rmLetras(dataAnagrama.original.toLowerCase().slice(0, 4)) && rmLetras(budy2.toLowerCase()) != rmLetras(dataAnagrama.original.toLowerCase())) return reply(`Quase lá ${pushname}`)
if(rmLetras(budy2.toLowerCase()) == rmLetras(dataAnagrama.original.toLowerCase())) {
var bglh = [
`ৎ❥̤֟٭ۣۜIrei reiniciar o jogo em 3️⃣`,
`ৎ❥̤֟٭ۣۜIrei reiniciar o jogo em 2️⃣`,
`ৎ❥̤֟٭ۣۜIrei reiniciar o jogo em 1️⃣`,
`✅ START THE GAME🍧.ᩦ୭✧ࣶᭂ`
]
let { key } = await zerotwo.sendMessage(from, {text: `Parabéns ${pushname}, você acertou a palavra do anagrama... 🎉🥳`}, {quoted: selolucas})//primeira mensagem
await sleep(1000)
for(let i = 0; i < bglh.length; i++) {
await sleep(1000)
await zerotwo.sendMessage(from, {text: bglh[i], edit: key }, {quoted: selolucas})
}
saveJSON(palavrasANA[ana], anagrama)
zerotwo.sendMessage(from, {text: `
╭─────≽「 👾 ANAGRAMA 👾 」
│➽ *DESCUBRA A PALAVRA*
│➽ *ANAGRAMA:* ${shuffle(palavrasANA[ana].embaralhada)}
│➽ *DICA:* ${palavrasANA[ana].dica}
╰────────────────────────
`}, {quoted: selolucas})
}
}
//fim do anagrama

if(fs.existsSync(`./armor/jogo/quizanimais/quizanimais-${from}.json`) && budy2.includes(`${JSON.parse(fs.readFileSync(`./armor/jogo/quizanimais/quizanimais-${from}.json`)).original.toLowerCase().replace("ã", "a").replace("á", "a").replace("ê", "e").replace("é", "e").replace("í", "i").replace("ó", "o").replace("ô", "o").replace("ú", "u")}`) && isGroup && args.length <= 2) {
fs.unlinkSync(`./armor/jogo/quizanimais/quizanimais-${from}.json`)
var bglh = [
`ৎ❥̤֟٭ۣۜIrei reiniciar o jogo em 3️⃣`,
`ৎ❥̤֟٭ۣۜIrei reiniciar o jogo em 2️⃣`,
`ৎ❥̤֟٭ۣۜIrei reiniciar o jogo em 1️⃣`,
`✅ START THE GAME🍧.ᩦ୭✧ࣶᭂ`
]
let { key } = await zerotwo.sendMessage(from, {text: `Parabéns, você acertou o animal 🎉`}, {quoted: selolucas})//primeira mensagem
await sleep(1000)
for(let i = 0; i < bglh.length; i++) {
await sleep(1000)
await zerotwo.sendMessage(from, {text: bglh[i], edit: key }, {quoted: selolucas})
}
luquinhas = Math.floor(Math.random() * quizanimais.length)
fs.writeFileSync(`./armor/jogo/quizanimais/quizanimais-${from}.json`, `${JSON.stringify(quizanimais[luquinhas])}`)
zerotwo.sendMessage(from, {image: {url: quizanimais[luquinhas].foto}, caption: `\n✔️ 𝙌𝙐𝙄𝙕 𝘼𝙉𝙄𝙈𝘼𝙄𝙎 ✔️\n\n🌚❒ 𝘿𝙚𝙨𝙘𝙪𝙗𝙧𝙖 𝙊 𝘼𝙣𝙞𝙢𝙖𝙡 ↑↑↑\n`})
}

if(body != undefined) {
if(!isJsonIncludes(pushnames, botNumber)) {
pushnames.push({id: botNumber, nick: NomeDoBot})
saveJSON(pushnames, "./base de dados/pushnames.json")
} else {
AC = pushnames.map(i => i.id).indexOf(botNumber)
pushnames[AC].nick = NomeDoBot
saveJSON(pushnames, "./base de dados/pushnames.json")
}
if(!isJsonIncludes(pushnames, sender)) {
pushnames.push({id: sender, nick: pushTestName})
saveJSON(pushnames, "./base de dados/pushnames.json")
} else {
AB = pushnames.map(i => i.id).indexOf(sender)
pushnames[AB].nick = pushTestName
saveJSON(pushnames, "./base de dados/pushnames.json")
}
}

//função do mute
if(body != undefined && !info.message?.reactionMessage?.text && isJsonIncludes(mute, from) && isBotGroupAdmins) {
A1 = mute.map(i => i.gpid).indexOf(from)
if(isJsonIncludes(mute[A1].mutados, sender)) {
A2 = mute[A1].mutados.map(a => a.id).indexOf(sender)
if(mute[A1].mutados[A2].sn == false) {
mute[A1].mutados[A2].sn = true
saveJSON(mute, "./base de dados/mute.json")
reply(`Você foi avisado ${pushname}... Você tem 30 segundos para declarar suas últimas palavras 😥`)
await sleep(30000)
B1 = mute.map(i => i.gpid).indexOf(from)
if(isJsonIncludes(mute[B1].mutados, sender)) {
B2 = mute[B1].mutados.map(a => a.id).indexOf(sender)
mute[B1].mutados.splice(B2, 1)
saveJSON(mute, "./base de dados/mute.json")
remover(from, sender)
await sleep(2000)
sendMess(from, `Falta de aviso não foi...`)
}
}
}
}

if(JSON.stringify(music).includes(from) && isGroup) {
AB = music.map(i => i.groupId).indexOf(from)
if(JSON.stringify(music[AB].usus).includes(sender)) {
BC = music[AB].usus.map(i => i.id).indexOf(sender)
if(budy2.toLowerCase().replace("á", "a") === `audio` && isGroup) {
link = music[AB].usus[BC].urlAudio.replace(`#API_KEY_ALEATORY#`, API_KEY_ALEATORY).replace(`#API_KEY_SABRINA#`, API_KEY_SABRINA).replace(`#API_KEY_ZEROTWO#`, API_KEY_ZEROTWO)
music[AB].usus.splice(BC, 1)
fs.writeFileSync("./base de dados/music.json", JSON.stringify(music, null, 2))
try {
reply(`ৎ❥̤֟٭ۣۜ𝙴𝚗𝚟𝚒𝚊𝚗𝚍𝚘 𝚂𝚞𝚊 𝙼ú𝚜𝚒𝚌𝚊🍧.ᩦ୭✧ࣶᭂ`)
zerotwo.sendMessage(from, {audio: {url: link}, mimetype: 'audio/mp4', ptt: true}, {quoted: selolucas}).catch(e => {
return reply(downon)
})
} catch (e) {
return reply(downoff)
}
}
if(budy2.toLowerCase().replace("í", "i") === `video` && isGroup) {
link = music[AB].usus[BC].urlVideo.replace(`#API_KEY_ALEATORY#`, API_KEY_ALEATORY).replace(`#API_KEY_SABRINA#`, API_KEY_SABRINA).replace(`#API_KEY_ZEROTWO#`, API_KEY_ZEROTWO)
music[AB].usus.splice(BC, 1)
fs.writeFileSync("./base de dados/music.json", JSON.stringify(music, null, 2))
try {
reply(`ৎ❥̤֟٭ۣۜ𝙴𝚗𝚟𝚒𝚊𝚗𝚍𝚘 𝚅í𝚍𝚎𝚘🍧.ᩦ୭✧ࣶᭂ`)
zerotwo.sendMessage(from, {video: {url: link}, mimetype: "video/mp4"}, {quoted: selolucas}).catch(e => {
return reply(downon)
})
} catch (e) {
return reply(downoff)
}
}
if(budy2.toLowerCase() === `doc` && isGroup) {
link = music[AB].usus[BC].urlAudio.replace(`#API_KEY_ALEATORY#`, API_KEY_ALEATORY).replace(`#API_KEY_SABRINA#`, API_KEY_SABRINA).replace(`#API_KEY_ZEROTWO#`, API_KEY_ZEROTWO)
nome = music[AB].usus[BC].title
music[AB].usus.splice(BC, 1)
fs.writeFileSync("./base de dados/music.json", JSON.stringify(music, null, 2))
try {
reply(`ৎ❥̤֟٭ۣۜ𝙴𝚗𝚟𝚒𝚊𝚗𝚍𝚘 𝙳𝚘𝚌𝚞𝚖𝚎𝚗𝚝𝚘🍧.ᩦ୭✧ࣶᭂ`)
zerotwo.sendMessage(from, {document: {url: link}, fileName: nome+'.mp3', mimetype: "audio/mpeg"}, {quoted: selolucas}).catch(e => {
return reply(downon)
})
} catch (e) {
return reply(downoff)
}
}
}
}

if(JSON.stringify(vdddsf).includes(from) && isGroup) {
AB = vdddsf.map(b => b.idgp).indexOf(from)
if(JSON.stringify(vdddsf[AB].jogadores).includes(sender)) {
BC = vdddsf.map(a => a.idvd).indexOf("luquinhas")
CD = vdddsf[AB].jogadores.map(i => i.id).indexOf(sender)
if(budy2.toLowerCase() === "verdade") {
if(vdddsf[AB].jogadores[CD].tipo == 1) {
vdddsf[AB].jogadores.splice(CD, 1)
fs.writeFileSync("./armor/jogo/vdddsf.json", JSON.stringify(vdddsf, null, 2))
sendStickerFromUrl(from, `https://telegra.ph/file/4b43ac115d66362540612.jpg`)
} else if(vdddsf[AB].jogadores[CD].tipo <= 0) {
alevdd = Math.floor(Math.random() * vdddsf[BC].verdades.length)
vdddsf[AB].jogadores[CD].vdouds = vdddsf[BC].verdades[alevdd].vdd
vdddsf[AB].jogadores[CD].tipo = 1
fs.writeFileSync("./armor/jogo/vdddsf.json", JSON.stringify(vdddsf, null, 2))
reply(`\`\`\`😇 Verdade Ou Desafio 😈\`\`\`
『 VERDADE 』
✓ -> ${vdddsf[BC].verdades[alevdd].vdd}

_(responda com verdade ou mentira)_`)
}
}
if(budy2.toLowerCase() === "mentira") {
vdddsf[AB].jogadores.splice(CD, 1)
fs.writeFileSync("./armor/jogo/vdddsf.json", JSON.stringify(vdddsf, null, 2))
sendStickerFromUrl(from, `https://telegra.ph/file/22e467ada05df439e3401.jpg`)
}
if(budy2.toLowerCase() === "desafio") {
aledsf = Math.floor(Math.random() * vdddsf[BC].desafios.length)
vdddsf[AB].jogadores[CD].vdouds = vdddsf[BC].desafios[aledsf].dsf
vdddsf[AB].jogadores[CD].tipo = 2
fs.writeFileSync("./armor/jogo/vdddsf.json", JSON.stringify(vdddsf, null, 2))
reply(`\`\`\`😇 Verdade Ou Desafio 😈\`\`\`
『 DESAFIO 』
✓ -> ${vdddsf[BC].desafios[aledsf].dsf}

_(quando concluir o desafio, use ${prefix}pronto)_`)
}
}
}

if(body != undefined && isGroup && bcgp.length > 0) {
AB = bcgp.map(i => i.tipo).indexOf("mensagem")
AC = bcgp.map(i => i.tipo).indexOf("grupos")
if(bcgp[AB].msg.length <= 0) return
if(bcgp[AC].gps.length <= 0) return
if(!JSON.stringify(bcgp[AC].gps).includes(from)) {
grupo = from
m = bcgp[AB].msg[0]
if(m.cobrado == false) {
msgEmMassa = m.txt
m.cobrado = true
fs.writeFileSync("./base de funcionamento/bcgp.json", JSON.stringify(bcgp, null, 2))
for(i of somembros) {
zerotwo.sendMessage(i, {text: msgEmMassa})
}
await sleep(5000)
zerotwo.groupLeave(grupo)
bcgp[AB].msg.splice(0, 1)
fs.writeFileSync("./base de funcionamento/bcgp.json", JSON.stringify(bcgp, null, 2))
if(bcgp[AB].msg.length > 0) {
bcgp[AC].gps.push({groupId: grupo})
fs.writeFileSync("./base de funcionamento/bcgp.json", JSON.stringify(bcgp, null, 2))
} else {
bcgp[AC].gps = []
fs.writeFileSync("./base de funcionamento/bcgp.json", JSON.stringify(bcgp, null, 2))
}
}
}
}

/*if(body != undefined && isGroup && adsgp.length > 0) {
AA = adsgp.map(i => i.tipo).indexOf("quantidade")
AB = adsgp.map(i => i.tipo).indexOf("grupos")
AC = adsgp.map(i => i.tipo).indexOf("mensagens")
if(adsgp[AB].gps.length > 0) {
if(adsgp[AC].msgs.length > 0) {
if(!JSON.stringify(adsgp[AB].gps).includes(from)) {
grupo = from
m = adsgp[AC].msgs[0]
if(m.cobrado == false) {
msgEmMassa = m.txt
m.cobrado = true
fs.writeFileSync("./base de funcionamento/adsgp.json", JSON.stringify(adsgp, null, 2))
for(i = 0; i < adsgp[AA].quant; i++) {
zerotwo.sendMessage(grupo, {text: msgEmMassa})
}
await sleep(5000)
zerotwo.groupLeave(grupo)
adsgp[AC].msgs.splice(0, 1)
fs.writeFileSync("./base de funcionamento/adsgp.json", JSON.stringify(adsgp, null, 2))
if(adsgp[AC].msgs.length > 0) {
adsgp[AB].gps.push({groupId: grupo})
fs.writeFileSync("./base de funcionamento/adsgp.json", JSON.stringify(adsgp, null, 2))
} else {
adsgp[AB].gps = []
fs.writeFileSync("./base de funcionamento/adsgp.json", JSON.stringify(adsgp, null, 2))
}
}
}
}
}
}*/

async function msgGlobal() {
if(gbmsg[1].msg.length > 0) {
if(gbmsg[0].gp.length > 0) {
horacerta = moment.tz('America/Sao_Paulo').format('HH:mm')
day = moment.tz('America/Sao_Paulo').format('DD')
for(a of gbmsg[1].msg) {
if(Number(a.time.replace(":", "")) === Number(horacerta.replace(":", ""))) {
if(Number(a.save) !== Number(day)) {
a.save = day
fs.writeFileSync("./base de dados/gbmsg.json", JSON.stringify(gbmsg, null, 2))
for(b of gbmsg[0].gp) {
setTimeout(() => {
zerotwo.sendMessage(b.id, {text: a.frase})
}, 1000)//1 segundo
}
}
}
}
}
}
}

msgGlobal()

async function funcgpByM4() {
if(funcgp.length > 0) {
for(a of funcgp) {
config = funcgp.map(i => i.id).indexOf(a.id)
if(a.tabela.length > 0) {
for(b of a.tabela) {
if(b.tipo == 1) tgp = "ss"
if(b.tipo == 2) tgp = "mm"
if(b.tipo == 3) tgp = "HH"
if(Number(b.save) !== Number(moment.tz('America/Sao_Paulo').format(tgp))) {
b.save = Number(moment.tz('America/Sao_Paulo').format(tgp))
fs.writeFileSync("./base de funcionamento/funcgp.json", JSON.stringify(funcgp, null, 2))
if(b.tempo > 1) {
b.tempo -= 1
fs.writeFileSync("./base de funcionamento/funcgp.json", JSON.stringify(funcgp, null, 2))
} else {
if(b.poder == 1) {
zerotwo.groupSettingUpdate(a.id, 'announcement')
sendMess(a.id, `ৎ❥̤֟٭ۣۜO grupo foi fechado após ${b.ordem} pelo ADM ${b.nome}🍧.ᩦ୭✧ࣶᭂ`)
closegp = funcgp[config].tabela.map(i => i.idfunc).indexOf(b.idfunc)
funcgp[config].tabela.splice(closegp, 1)
fs.writeFileSync("./base de funcionamento/funcgp.json", JSON.stringify(funcgp, null, 2))
} else {
zerotwo.groupSettingUpdate(a.id, 'not_announcement')
sendMess(a.id, `ৎ❥̤֟٭ۣۜO grupo foi aberto após ${b.ordem} pelo ADM ${b.nome}🍧.ᩦ୭✧ࣶᭂ`)
opengp = funcgp[config].tabela.map(i => i.idfunc).indexOf(b.idfunc)
funcgp[config].tabela.splice(opengp, 1)
fs.writeFileSync("./base de funcionamento/funcgp.json", JSON.stringify(funcgp, null, 2))
}
}
}
}
}
}
}
}

funcgpByM4()

async function adsByMath() {
if(ads.length != 0) {
for(a of ads) {
if(a.module == true) {
for(b of a.mensagens) {
if(b.tipo == 1) tempoAds = "ss"
if(b.tipo == 2) tempoAds = "mm"
if(b.tipo == 3) tempoAds = "HH"
if(b.tipo == 4) tempoAds = "DD"
if(Number(b.save) !== Number(moment.tz('America/Sao_Paulo').format(tempoAds))) {
if(b.contador > 1) {
b.save = moment.tz('America/Sao_Paulo').format(tempoAds)
b.contador -= 1
fs.writeFileSync("./base de dados/ads.json", JSON.stringify(ads, null, 2))
} else {
b.save = moment.tz('America/Sao_Paulo').format(tempoAds)
b.contador = b.total
fs.writeFileSync("./base de dados/ads.json", JSON.stringify(ads, null, 2))
if(b.midi == 0) {
zerotwo.sendMessage(a.groupId, {image: {url: b.img}, caption: b.msg, contextInfo: {
externalAdReply: {
title: NomeDoBot,
body: "",
mediaType: 1,
reviewType: "PHOTO",
thumbnailUrl: b.img,//logo do selo
showAdAttribution: true,//coloque false para tirar o "enviado via anúncio"
renderLargerThumbnail: false,//põe true caso queira o selo grande
sourceUrl: b.link//link do selo
}
}})
}
if(b.midi == 1) {
zerotwo.sendMessage(a.groupId, {text: b.msg, contextInfo: {
externalAdReply: {
title: `🔎 ${NomeDoBot} 🔍`,
body: ``,
thumbnail: await getBuffer(logoslink.logo),
mediaType: 1,
reviewType: "PHOTO",
thumbnailUrl: b.img,//logo do selo
showAdAttribution: true,//coloque false para tirar o "enviado via anúncio"
renderLargerThumbnail: false,//põe true caso queira o selo grande
sourceUrl: b.link//link do selo
}
}})
}
if(b.midi == 2) {
zerotwo.sendMessage(a.groupId, {text: b.msg})
}
if(b.midi == 3) {
zerotwo.sendMessage(a.groupId, {image: {url: b.img}, caption: b.msg})
}
}
}
}
}
}
}
}

adsByMath()

async function avisosByMath() {
if(avisos.length != 0) {
for( i of avisos ) {
if(i.groupId != "luquinhas") {
if(i.module == true) {
if(i.mensagens.length != 0) {
for( w of i.mensagens ) {
if(Number(w.tempo.replace(":", "")) === Number(moment.tz('America/Sao_Paulo').format('HHmm')) && Number(w.dia) !== Number(moment.tz('America/Sao_Paulo').format('DD'))) {
zerotwo.sendMessage(i.groupId, {text: w.msg})
w.dia = moment.tz('America/Sao_Paulo').format('DD')
fs.writeFileSync("./base de dados/avisos.json", JSON.stringify(avisos, null, 2))
}
}
}
BH = avisos.map(n => n.groupId).indexOf("luquinhas")
if(i.aleatory.length != 0) {
for( a of i.aleatory ) {
if(Number(a.tempo.replace(":", "")) === Number(moment.tz('America/Sao_Paulo').format('HHmm')) && Number(a.dia) !== Number(moment.tz('America/Sao_Paulo').format('DD'))) {
if(a.ativation == 1 && i.globalAleatory.length <= 1) return
if(a.ativation == 2 && avisos[BH].mensagens.length <= 1) return
if(Number(a.ativation) <= 1) {
testMsg1 = i.globalAleatory
testMsg2 = testMsg1[Math.floor(Math.random()*testMsg1.length)]
} else {
testMsg1 = avisos[BH].mensagens
testMsg2 = testMsg1[Math.floor(Math.random()*testMsg1.length)]
}
zerotwo.sendMessage(i.groupId, {text: testMsg2})
a.dia = moment.tz('America/Sao_Paulo').format('DD')
fs.writeFileSync("./base de dados/avisos.json", JSON.stringify(avisos, null, 2))
}
}
}
}
}
}
}
}

avisosByMath()

if(budy2 === `${Number(body.split('!')[0])}!` && Number(body.split('!')[0]) > 2 && isGroup) {
nmrX = Number(body.split('!')[0])
nmrY = nmrX - 1
for(i = nmrY; i > 0; i--) {
nmrX *= i
}
reply(`${nmrX}`)
}

//========================================\\
}
}
}
msgupsrt().catch(async(e) => {
if(JSON.stringify(e).includes(API_KEY_ZEROTWO)) {
return console.log("A api caiu ou não foi possivel executar esta ação., espere retornar") 
} else if(String(e).includes("Erro: aborted")) {
file = require.resolve("./start.js")
delete require.cache[file]
require(file)
} else {
return console.log(e)
}
})
}
}
}
startZero().catch(e => {
return console.log(e+" -INDEX..ERROS")
})

// SISTEMA PARA ATUALIZAÇÃO DO BOT \\
const chalk = require('chalk')
const fileName = path.basename(__filename)
const file = require.resolve(__filename)
let timeout

fs.watchFile(file, () => {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄 
fs.unwatchFile(file)
clearTimeout(timeout)
console.log(chalk.redBright(` Arquivo '${fileName}' foi atualizado. Atualizando a Bot...`))
timeout = setTimeout(() => {
delete require.cache[file]
require(file)
}, 2000) // Delay Pra Reiniciar (tá só 2s dmr)
})

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: lerinbox
└─────────────────────────────────────────────────┘
*/
case 'lerinbox':
if (!isChatOfc && !isAdvencedVip(sender) && !isAdvencedGroupVip(from)) return reply(enviar.msg.vip)
if(!q.includes("@")) return reply("KD o email pra eu ler?")
login = q.split("@")[0]
domain = q.split("@")[1]
try {
ABC = await fetchJson(zerosite+`/api/tempmail/ler-inbox?domain=${domain}&login=${login}&apikey=`+API_KEY_ZEROTWO)
reply(`*✉️ Caixa de entrada:* ${`${ABC.resultado.length}` + ABC.resultado.length > 0 ? "\n\n" : ""}${ABC.resultado.map(i => `• *Enviado de:* ${i.from}
• *Assunto:* ${i.subject}
• *Data:* ${i.date}`).join("\n-\n")}`)
} catch(e) { console.log(e)
reply(`Erro`) }
break

// consultas

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: lerqr
└─────────────────────────────────────────────────┘
*/
case 'lerqr':
if (!isChatOfc && !isAdvencedVip(sender) && !isAdvencedGroupVip(from)) return reply(enviar.msg.vip)
try {
if(command == "gerarqr") {
if(!q) return reply(prefix+command+" seu texto aqui")
sendImage(from, `${zerosite}/imagem/qrcode?texto=teste&apikey=`+API_KEY_ZEROTWO, `📄 *QR-CODEGERADO* 📄`)
} else {
if((isMedia && !info.message.videoMessage || isQuotedImage) && !q.length <= 1) {
boij = isQuotedImage ? JSON.parse(JSON.stringify(selolucas).replace('quotedM','m')).message.extendedTextMessage.contextInfo.message.imageMessage : info.message.imageMessage
owgi = await getFileBuffer(boij, 'image')
link = await upload(owgi)
ABC = await fetchJson(`${zerosite}/imagem/leitor-qrcode?qrcode=${link}&apikey=`+API_KEY_ZEROTWO)
reply(`📄 *QR traduzido:* `+ABC.resultado)
} else return reply("Você deve marcar uma imagem, ou um vídeo de até 30 segundos..")
}
} catch {
console.log(e)
reply('Ocorreu algum Erro, desculpe 😔/ O limite do tamanho de vídeo que gero o link, é até 30 segundos.')
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: letras
└─────────────────────────────────────────────────┘
*/
case 'letras':
if(!q) return reply(`❓ *Qual o nome da música?* Exemplo: ${prefix + command} wanna be yours`)
try {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
let ABC = await fetchJson(`${zerosite}/api/letramusic?query=${encodeURI(q)}&apikey=${API_KEY_ZEROTWO}`)
if (!ABC.resultado || ABC.resultado.length === 0) return reply("❌ *Nenhuma letra encontrada.*")
let resultadoText = ABC.resultado.map((item, index) => {
return `🎶 *Música ${index + 1}:* 🎶\n` + 
 `───────────────────────────────\n` +
 `🎤 *Artista:* ${item.art}\n` +
 `🎼 *Título:* ${item.txt}\n` +
 `📀 *Gênero:* ${item.g || 'Não disponível'}\n` +
 `🔗 *Link:* ${item.url || 'Não disponível'}\n` +
 `🌍 *DNS:* ${item.dns || 'Não disponível'}\n` +
 `🎯 *Pontuação:* ${item.score || 'Não disponível'}\n` +
 `🆔 *ID:* ${item.id}\n` +
 `🌐 *IAR:* ${item.iar || 'Não disponível'}\n` +
 `🔢 *IMU:* ${item.imu || 'Não disponível'}\n` +
 `📏 *Altura (h):* ${item.h || 'Não disponível'}\n` +
 `───────────────────────────────\n` +
 `📜 *Letra Completa:*\n${item.lyrics}\n\n`
}).join('\n')
sendUrlText(from, resultadoText, NomeDoBot, '', ABC.resultado[0].img, '', selolucas)
} catch (e) {
reply("⚠️ *Erro ao buscar as letras.*")
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: level
└─────────────────────────────────────────────────┘
*/
case 'level':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isLevelingOn) return reply(`*É necessário ativar o sistema de level primeiro* 🙆🏻‍♂️
*Use* ${prefix}leveling 1`)
if(isYouInLevel(sender)) {
levelstts = levelDBuser(sender)
myexp = levelstts.contador
newpatente = patente(myexp)

AB = dbpt.map(d => d.pat).indexOf(newpatente)
newtt = myexp < 10000000 ? myexp < 5000000 ? dbpt[AB].nmr : 5000000 : myexp
newcont = myexp < 10000000 ? myexp < 5000000 ? dbpt[AB + 1].nmr : 10000000 : myexp

luquinhas = level.map(i => i)
rank = luquinhas.sort((a, b) => (a.contador < b.contador) ? 0 : -1)

bar = myexp < 10000000 ? barrinha((myexp - newtt), (newcont - newtt)) : ""
sub = newcont - myexp
//==========reply===========\\
leveltxt = `
╔═════════════════🌸═══════════════════╗
║ㅤ💖 𝑳𝑬𝑽𝑬𝑳𝑰𝑵𝑮 💖ㅤ║
╠═══════════════════════════════════════╣
║ㅤ⭐ ❍ 𝑵𝑰𝑪𝑲: ${pushname}
║ㅤ⭐ ❍ 𝑳𝑬𝑽𝑬𝑳: ${levelstts.level}
║ㅤ⭐ ❍ 𝑷𝑨𝑻𝑬𝑵𝑻𝑬: ${newpatente}
║ㅤ⭐ ❍ 𝑿𝑷: ${myexp} ${myexp < 10000000 ? `➤ ${newcont}` : ``}
╠═══════════════════════════════════════╣
║ㅤ${myexp < 10000000 ? `${bar}\n║` : ``} 
╚═════════════════🌸═══════════════════╝
${myexp < 10000000 ? `\n⚡_Falta${Number(sub) > 1 ? `m` : ``} ${sub} XP para upar o próximo level_` : `_🏆Você alcançou a patente máxima_`}`
a1 = levelstts.level
a2 = (rank.map(i => i.id).indexOf(sender)) + 1
a3 = myexp
a4 = myexp < 10000000 ? newcont : myexp
a5 = Number(myexp < 10000000 ? (((myexp - newtt) / (newcont - newtt)) * 100) : 100).toFixed(0)
} else {
leveltxt = `
┏═════════════════🌸═══════════════════┓
║ㅤ💖 𝑳𝑬𝑽𝑬𝑳𝑰𝑵𝑮 💖ㅤ║
╠═══════════════════════════════════════╣
║ㅤ⭐ ❍ 𝑵𝑰𝑪𝑲: ${pushname}
║ㅤ⭐ ❍ 𝑳𝑬𝑽𝑬𝑳: 1
║ㅤ⭐ ❍ 𝑷𝑨𝑻𝑬𝑵𝑻𝑬: Bronze I 🥉
║ㅤ⭐ ❍ 𝑿𝑷: 0
╚═════════════════🌸═══════════════════╝`
a1 = 0
a2 = level.length + 1
a3 = 0
a4 = 100
a5 = 0
}
try {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
const profilePicUrl = await zerotwo.profilePictureUrl(`${sender.split('@')[0]}@c.us`, 'image')
const response = await axios.get(profilePicUrl, {
responseType: 'arraybuffer',
headers: {
'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3'
}
})
if (response.status === 200) {
const buffer = Buffer.from(response.data, 'binary')
ppimg = await upload(buffer)
} else {
throw new Error(`Erro ao obter a imagem: ${response.status}`)
}
} catch (e) {
console.log("Erro ao obter a imagem de perfil:", e.message)
ppimg = semfoto
}
img = zerosite+`/api/canvas/musicardbun/level?nome=${encodeURI(pushname)}&level=${a1}&brightness=100&perfil=${ppimg}&rank=${a2}&xpb=${a3}&xpa=${a4}&progresso=${a5}`
sendImage(from, img, leveltxt, selolucas)
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: lgbt
└─────────────────────────────────────────────────┘
*/
case 'lgbt':
if (!isVip && !isGroup) return reply(enviar.msg.pvnotvip)
const isImageMessage = info.message.imageMessage !== undefined
const isQuotedImageMessage = info.message.extendedTextMessage?.contextInfo?.quotedMessage?.imageMessage !== undefined
if (isImageMessage || isQuotedImageMessage) {
try {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
const boij = isQuotedImageMessage ? info.message.extendedTextMessage.contextInfo.quotedMessage.imageMessage: info.message.imageMessage
const owgi = await getFileBuffer(boij, 'image')
const link = await uploadToCloudinary(owgi)
if (!link) {
return reply("Erro ao fazer o upload da imagem. Link inválido.")
}
const encodedLink = encodeURIComponent(link)
reply(`ৎ❥̤֟٭ۣۜDesenhando pixel a pixel, isso pode demorar ❒`)
try {
const response = await sendImage(from, `${zerosite}/api/canvas/${command}?link=${encodedLink}&apikey=` + API_KEY_ZEROTWO)
} catch (error) {
console.log("Erro ao enviar imagem:", error.response?.data || error.message || error)
reply("Erro ao processar o efeito. Verifique o link ou tente novamente mais tarde.")
}
} catch (e) {
console.log("Erro no processamento:", e)
return reply("Erro ao converter a imagem.")
}
} else {
reply('Marque uma imagem para eu atribuir o efeito.')
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: listkey
└─────────────────────────────────────────────────┘
*/
case 'listkey':
if (!isOwner) return reply(enviar.msg.donosmt)
fetch(`${zerosite}/dono/puxar-senha`)
.then(response => {
if (!response.ok) throw new Error(`❌ Erro na API: ${response.statusText}`)
return response.json()
})
.then(data => {
if (!data.senha) throw new Error('⚠ A resposta da API não contém a senha.')
return fetch(`${zerosite}/dono/listkey?senha=${data.senha}`)
})
.then(response => response.json())
.then(data => {
if (Array.isArray(data) && data.length > 0) {
const list = data.map((key, index) => 
`╭━━━━━━━━━━━━━━━━━━━⬣\n` +
`┃ 🔑 *KEY ${index + 1}*\n` +
`┃ ✦ *Apikey:* ${key.apikey}\n` +
`┃ 🔄 *Requests:* ${key.request}\n` +
`┃ 📊 *Consultas:* ${key.consulta}\n` +
`╰━━━━━━━━━━━━━━━━━━━⬣`
).join('\n\n')
const totalKeys = data.length
const message = 
`╭━━━━━━━━━━━━━━━━━━━━⬣\n` +
`┃ 🔹 *LISTA DE KEYS DISPONÍVEIS*\n` +
`┃ 📌 *Total de Keys:* ${totalKeys}\n` +
`╰━━━━━━━━━━━━━━━━━━━━⬣\n\n${list}`
if (isGroup) reply(`📩 *Olha o PV, ${pushname}!*`)
sleep(1000)
zerotwo.sendMessage(sender, { text: message }, { quoted: selolucas })
} else {
reply("❌ Nenhuma key encontrada.")
}
})
.catch(error => {
console.log('Erro ao se conectar com a API:', error)
reply("⚠ [ERRO] Falha ao se conectar com a API.")
})
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: logogame
└─────────────────────────────────────────────────┘
*/
case 'logogame':
//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
//Canal: https://whatsapp.com/channel/0029Va6riekH5JLwLUFI7P2B
textin = args.join(" ")
if(!textin) return reply("KD o texto ?")
reply(`ৎ❥̤֟٭ۣۜ𝙶𝚎𝚛𝚊𝚗𝚍𝚘 𝚂𝚞𝚊 𝙻𝚘𝚐𝚘🍧.ᩦ୭✧ࣶᭂ`)
bla = await fetchJson(`${zerosite}/api/${command}?texto=${textin}&apikey=`+API_KEY_ZEROTWO)
blabla = await getBuffer(bla.resultado.imageUrl)
zerotwo.sendMessage(from, {image: blabla}, {quoted: selolucas}).catch(e =>{
reply("Erro ao criar sua logo! Tente novamente mais tarde.")
})
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: mascoteavatar
└─────────────────────────────────────────────────┘
*/
case 'mascoteavatar':
//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
//Canal: https://whatsapp.com/channel/0029Va6riekH5JLwLUFI7P2B
textin = args.join(" ")
txt1 = textin.split("/")[0]
txt2 = textin.split("/")[1]
if(!textin) return reply("KD o texto ?")
if(!textin.includes("/")) return reply(`Cade a / precisa dela para a separação..\nExemplo: ${prefix + command} Game/Play`)
reply(`ৎ❥̤֟٭ۣۜ𝙶𝚎𝚛𝚊𝚗𝚍𝚘 𝚂𝚞𝚊 𝙻𝚘𝚐𝚘🍧.ᩦ୭✧ࣶᭂ`)
bla = await fetchJson(`${zerosite}/api/${command}?texto=${txt1}&texto2=${txt2}&apikey=`+API_KEY_ZEROTWO)
blabla = await getBuffer(bla.resultado.imageUrl)
zerotwo.sendMessage(from, {image: blabla}, {quoted: selolucas}).catch(e =>{
reply("Erro ao criar sua logo! Tente novamente mais tarde.")
})
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: mediafire
└─────────────────────────────────────────────────┘
*/
case 'mediafire':
try {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
//Canal: https://whatsapp.com/channel/0029Va6riekH5JLwLUFI7P2B
if (!q.includes("mediafire.com")) {
return reply("Faltando o link do mediafire para download do arquivo, cade?");
}
const ABC = await fetchJson(`${zerosite}/api/dl/mediafire?url=${q}&apikey=${API_KEY_ZEROTWO}`)
if (ABC.status !== 'true') {
return reply("Não foi possível obter as informações do arquivo. Tente novamente mais tarde.")
}
const { filename, filesize, link, extension, mimetype } = ABC
reply(`❯❯ ZERO TWO - DOWNLOAD ❮❮\n\n❯ 📂 *Nome:* ${filename}\n❯ 🧮 *Tamanho:* ${filesize}\n❯ 📎 *Link para download:* ${link}\n❯ 🗂 *Extensão:* ${extension}`)
zerotwo.sendMessage(from, { document: { url: link }, mimetype: `${mimetype}`, fileName: filename }).catch(e => {
return reply("Erro ao enviar o arquivo...")
})
} catch (e) {
console.log(e)
return reply("Erro ao processar a solicitação.")
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: metadinhacard
└─────────────────────────────────────────────────┘
*/
case 'metadinhacard':
reagir(from, "😍")
try {
// Obter os dados da API
let ABC = await fetchJson(`${zerosite}/random/metadinha?apikey=${API_KEY_ZEROTWO}`)
// Verificar se os dados foram obtidos corretamente
if (!ABC || !ABC.masculina || !ABC.feminina) {
throw new Error("Dados da API não recebidos corretamente.")
}
// Preparar as imagens da metadinha
let metadinha1 = await prepareWAMessageMedia({ image: { url: ABC.masculina } }, { upload: zerotwo.waUploadToServer })
let metadinha2 = await prepareWAMessageMedia({ image: { url: ABC.feminina } }, { upload: zerotwo.waUploadToServer })
// Enviar a mensagem em formato de carrossel
await zerotwo.relayMessage(from, {
viewOnceMessage: {
message: {
messageContextInfo: {
deviceListMetadata: {},
deviceListMetadataVersion: 2
},
interactiveMessage: {
body: {},
contextInfo: { participant: sender, quotedMessage: info.message, forwardingScore: 999, isForwarded: true, forwardedNewsletterMessageInfo: {newsletterJid: channel, newsletterName: `𝙲𝙾𝙽𝙽𝙴𝙲𝚃𝙴𝙳 𝙲𝙾𝙽𝚃𝙴Ú𝙳𝙾𝚂`}},
carouselMessage: {
cards: [
{
header: {
imageMessage: metadinha1.imageMessage,
hasMediaAttachment: true,
},
body: { text: "❯❯〘 ꪶ🙇🏻‍♂️ *HOMEM* 🙅🏻‍♂️ꫂ 〙❮❮" },
nativeFlowMessage: { buttons: [] },
},
{
header: {
imageMessage: metadinha2.imageMessage,
hasMediaAttachment: true,
},
body: { text: "❯❯〘 ꪶ🙆🏻‍♀️ *MULHER* 💁🏻‍♀️ꫂ 〙❮❮" },
nativeFlowMessage: { buttons: [] },
},
]
}
}
}
}
}, selolucas)
} catch (e) {
console.log("Erro ao enviar a metadinhacard:", e)
reply("Ocorreu um erro ao enviar a metadinhacard. Por favor, tente novamente mais tarde.")
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: meutinder
└─────────────────────────────────────────────────┘
*/
case 'meutinder':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(enviar.msg.modobz)
try {
ABC = await fetchJson(`${zerosite}/tinder/perfil?usu=${sender}&apikey=`+API_KEY_ZEROTWO)
txt = `
╔══════════════════╣
╟ • ${ABC.dados[0].gene.replace("ã", "a") == "nao declarar" ? `ɴᴏᴍᴇ` : `ᴜꜱᴜáʀɪ${ABC.dados[0].gene == "masculino" ? "ᴏ" : "ᴀ"}`}: ${ABC.dados[0].nome}
║
╟ • ɪᴅᴀᴅᴇ: ${ABC.dados[0].idade} anos
║
╟ • ᴡʜᴀᴛꜱᴀᴩᴩ: wa.me/${ABC.dados[0].nmr}
║
╟ • ꜱᴇxᴜᴀʟɪᴅᴀᴅᴇ: ${ABC.dados[0].sexualidade}
║
╟ • ɢêɴᴇʀᴏ: ${ABC.dados[0].gene}
║
╟ • ꜰɪʟᴛʀᴏ: ${ABC.dados[0].filtro == 3 ? `sem preferências` : `pesquisar por ${ABC.dados[0].filtro == 1 ? ` homens` : `mulheres`}`}
║
╩ • ʙɪᴏ: ${ABC.dados[0].bio}

_${ABC.dados[0].gene.replace("ã", "a") == "nao declarar" ? `Deu entrada no tinder` : `Registrad${ABC.dados[0].gene == "masculino" ? "o" : "a"}`} em ${ABC.dados[0].registro[0]}, às ${ABC.dados[0].registro[1]}_
`
zerotwo.sendMessage(from, {text: txt, contextInfo: {
externalAdReply: {
title: `🔥 𝒁𝒆𝒓𝒐 𝑻𝒘𝒐 𝒕𝒊𝒏𝒅𝒆𝒓 🔥`,
body: ``,
thumbnail: await getBuffer(`${ABC.dados[0].foto}`),
mediaType: 1,
showAdAttribution: true,
sourceUrl: `${zerosite}`
}, forwardingScore: 1000000, isForwarded: true, forwardedNewsletterMessageInfo: {newsletterJid: channel }}}, {quoted: selolucas})
} catch { reply(resptinder(ABC.message || "Erro")) }
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: modkey
└─────────────────────────────────────────────────┘
*/
case 'modkey':
if (!isOwner) return reply(enviar.msg.donosmt)
if (!q) {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
//Canal: https://whatsapp.com/channel/0029Va6riekH5JLwLUFI7P2B
return reply(`Por favor, forneça o nome da Key para modificar. Exemplo: ${prefix + command} luquinhas`)
} else {
const input = q.split('/')
if (input.length === 1) {
const keyName = input[0].trim()
if (!keyName) {
return reply(`Por favor, forneça um nome válido para a Key. Exemplo: ${prefix + command} luquinhas`)
}
return reply(`Quantos requests você deseja adicionar ao campo consulta da apikey (${keyName})? Exemplo: ${prefix + command} ${keyName}/500`)
} else if (input.length === 2) {
const keyName = input[0].trim()
const requestCount = input[1].trim()
if (!keyName || !requestCount || isNaN(requestCount) || Number(requestCount) <= 0) {
return reply(`Por favor, forneça o nome da Key e um número válido de requests no formato: ${prefix + command} [nomedakey]/[requests]`)
}
const key = encodeURIComponent(keyName)
const request = Number(requestCount)
fetch(`${zerosite}/dono/puxar-senha`)
.then(response => {
if (!response.ok) {
throw new Error(`Erro na resposta da API: ${response.statusText}`)
}
return response.json()
})
.then(data => {
if (!data.senha) {
throw new Error('Resposta da API não contém a senha')
}
const senha = data.senha
const a = encodeURIComponent(`${key}&${request}&${senha}`)
fetch(`${zerosite}/dono/modkey?a=${a}`)
.then(response => response.json())
.then(data => {
console.log('Resposta da API ao modificar a Key:', data)
if (data.message.includes("👑") || data.message.includes("〽️")) {
reply(data.message)
} else {
reply("[❗] Erro ao modificar a apikey")
}
})
.catch(error => {
console.error('Erro ao modificar a apikey:', error)
reply("[❗] Erro ao se conectar com a API")
})
})
.catch(error => {
console.error('Erro ao obter a senha da API:', error)
reply("[❗] Erro ao obter a senha da API")
})
} else {
return reply(`Formato inválido. Por favor, use o formato: ${prefix + command} [nomedakey]/[requests]`)
}
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: moeda
└─────────────────────────────────────────────────┘
*/
case 'moeda':
if(!isVip && !isChatOfc) return reply(enviar.msg.vip)
try {
ABC = await fetchJson(zerosite+`/api/cotacao?moeda=${q ? q : "luquinhas"}&apikey=`+API_KEY_ZEROTWO)
if(ABC.erro) return reply(ABC.erro)
i = ABC.resultado[0]
moda = i.name.split("/")[0]
mods = moda.split(" ")[0]
txt = `🪙 *Moeda:* ${moda}
💖 *Código:* ${i.code}
💰 *Valor atual:* R$ ${Number(i.bid).toFixed(2)} ( 1 ${moda} )
📊 *Variações:*
_• *Mínimo:* ${Number(i.high).toFixed(2)} ${mods+"s"}_
_• *Máximo:* ${Number(i.low).toFixed(2)} ${mods+"s"}_
_• *Percentual:* ${Number(i.pctChange).toFixed(2)}% ( ${i.varBid} )_

Atualizado às ${realtime()}`
reply(txt)
} catch(e) { console.log(e)
reply("Erro") }
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: movie
└─────────────────────────────────────────────────┘
*/
case 'movie':
if(!q) return reply("Assim: "+prefix+command+" nome do filme")
reagir(from, "🎬")
if(!q.includes(`m.imdb.com`)) {
try {
luquinhas = await fetchJson(`${zerosite}/api/search/imdb?query=${encodeURI(q)}&apikey=`+API_KEY_ZEROTWO)
linkM4 = luquinhas.resultado[0].url
} catch {
return reply("Não foi possível encontrar o filme pedido")
}
} else {
linkM4 = q
}
try {
ABC = await fetchJson(`${zerosite}/api/search/imdb_info?url=${linkM4}&apikey=`+API_KEY_ZEROTWO)
i = ABC.resultado
lançamento = i.dataLancamento
notas = i.nota
money = i.dinheiro.orcamento
escrito = `${money.valor}`
nmr = escrito.length
dindin = nmr > 9 ? escrito.slice(0, nmr-9)+"B" : nmr > 6 ? escrito.slice(0, nmr-6)+"M" : nmr > 3 ? escrito.slice(0, nmr-3)+"K" : escrito
txt = `❪🎬ฺ࣭࣪͘ꕸ▸ 𝙽𝚘𝚖𝚎: ${i.titulo}
❪🧾ฺ࣭࣪͘ꕸ▸ 𝙽𝚘𝚖𝚎 𝙾𝚏𝚒𝚌𝚒𝚊𝚕: ${i.tituloOriginal}
❪💢ฺ࣭࣪͘ꕸ▸ 𝚃𝚒𝚙𝚘: ${i.tipo}
❪🎥ฺ࣭࣪͘ꕸ▸ 𝙶ê𝚗𝚎𝚛𝚘: ${i.genero}
❪⏱️ฺ࣭࣪͘ꕸ▸ 𝙳𝚞𝚛𝚊çã𝚘: ${i.duracao}
❪📟ฺ࣭࣪͘ꕸ▸ 𝙻𝚊𝚗ç𝚊𝚖𝚎𝚗𝚝𝚘: ${Number(lançamento.dia) < 10 ? `0${lançamento.dia}` : lançamento.dia}/${Number(lançamento.mes) < 10 ? `0${lançamento.mes}` : lançamento.mes}/${lançamento.ano}
❪📝 ฺ࣭࣪͘ꕸ▸ 𝙲𝚛í𝚝𝚒𝚌𝚊𝚜: ${i.criticaTotal}
❪🏆 ฺ࣭࣪͘ꕸ▸ 𝙿𝚛𝚎𝚖𝚒𝚊çõ𝚎𝚜: ${i.avaliado.vitorias} vitórias, ${i.avaliado.indicacoes} indicações
❪📊 ฺ࣭࣪͘ꕸ▸ 𝙼𝚎𝚝𝚊𝙲𝚛í𝚝𝚒𝚌𝚊: ${i.metaCritica.pontuacao} (posição: ${i.metaCritica.posicao})
❪📊ฺ࣭࣪͘ꕸ▸ 𝙰𝚟𝚊𝚕𝚒𝚊çã𝚘: ${notas.ponto}/10 (${notas.total} votos)
❪💱ฺ࣭࣪͘ꕸ▸ 𝙾𝚛ç𝚊𝚖𝚎𝚗𝚝𝚘: ${money.moeda} ${dindin}
❪⚒️ฺ࣭࣪͘ꕸ▸ 𝙿𝚛𝚘𝚍𝚞çã𝚘: ${i.producao.map(p => p).join(', ')}
❪🔊 ฺ࣭࣪͘ꕸ▸ 𝙼𝚒𝚡𝚊𝚐𝚎𝚗𝚜: ${i.mixagens.join(', ')}
❪🎬 ฺ࣭࣪͘ꕸ▸ 𝙳𝚒𝚛𝚎çã𝚘: ${i.diretores[0].direcao.map(d => d).join(', ')}
❪🖊️ ฺ࣭࣪͘ꕸ▸ 𝚁𝚘𝚝𝚎𝚒𝚛𝚒𝚜𝚝𝚊𝚜: ${i.escritoras[0].creditos.join(', ')}

ㅤㅤㅤㅤㅤㅤ〘 𝙀𝙇𝙀𝙉𝘾𝙊 〙`
for(e of i.elencoPrincipal) {
txt += `\n⇒ *${e.nome}* (${e.categoria} - ${e.personagem.map(a => a).join(', ')})`
}
txt += `\n\n▧⃯⃟𝙎𝙄𝙉𝙊𝙋𝙎𝙀৴▸ ${i.trama}`
zerotwo.sendMessage(from, {text: txt, contextInfo: {
externalAdReply: {
title: `𝙈𝙊𝙑𝙄𝙀 𝙄𝙉𝙁𝙊 𝘽𝙔 𝙕𝙀𝙍𝙊 𝙏𝙒𝙊`,
body: ``,
thumbnail: await getBuffer(i.capa),
mediaType: 1,
showAdAttribution: true,
sourceUrl: linkM4
}
}}, {quoted: selolucas})
} catch(err) {
console.log(err)
reply("Não foi possível encontrar os dados desse filme, ou pode ser que a api de pesquisas caiu...")
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: movielist
└─────────────────────────────────────────────────┘
*/
case 'movielist':
if(!q) return reply("Assim: "+prefix+command+" nome do filme")
reagir(from, "🎬")
try {
ABC = await fetchJson(`${zerosite}/api/search/imdb?query=${encodeURI(q)}&apikey=`+API_KEY_ZEROTWO)
txt = `${`- `.repeat(20)}`
for(i of ABC.resultado) {
txt += `\n*Nome:* ${i.title}\n*Link:* ${i.url}\n${`- `.repeat(20)}`
}
reply(txt)
} catch {
reply(`Erro`)
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: multidl2
└─────────────────────────────────────────────────┘
*/
case 'multidl2': {
zerotwo.sendMessage(from, { react: { text: "📥", key: info.key } })
if (!q) {
return zerotwo.sendMessage(from, { text: `🍭 Por favor, envie um link válido de uma das plataformas suportadas: YouTube, TikTok, Instagram, Facebook, Threads, Likee, CapCut, Pinterest, GDLink ou Twitter.` }, { quoted: selolucas })
}
zerotwo.sendMessage(from, { text: '```⏳ Buscando e processando o download do vídeo, imagem e áudio...```' }, { quoted: selolucas })
try {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
//Canal: https://whatsapp.com/channel/0029Va6riekH5JLwLUFI7P2B
const apiUrl = `${zerosite}/api/dl/multidl3?url=${encodeURIComponent(q)}&apikey=${API_KEY_ZEROTWO}`
const response = await fetch(apiUrl)
const data = await response.json()
if (!data.status) {
throw new Error("Erro ao processar o link, verifique se está correto.")
}
const { title, high, low } = data.data
const caption = `
🎬 *Título:* ${title || 'Sem título'}
🔗 *Link:* ${q}

👨‍💻 *Desenvolvedor:* ${data.developer || 'Desconhecido'}
🔗 *Instagram do Dev:* ${data.devfb || 'Desconhecido'}
📲 *WhatsApp do Dev:* ${data.devwp || 'Desconhecido'}
`.trim()
const videoUrl = high || low
if (videoUrl) {
try {
await zerotwo.sendMessage(from, { video: { url: videoUrl }, caption }, { quoted: selolucas })
} catch (error) {
console.warn("O vídeo está corrompido, tentando enviar como imagem...")
zerotwo.sendMessage(from, { text: "❌ O vídeo parece estar corrompido. Tentando enviar como imagem..." }, { quoted: selolucas })
await zerotwo.sendMessage(from, { image: { url: videoUrl }, caption }, { quoted: selolucas })
}
} else {
zerotwo.sendMessage(from, { text: "❌ Nenhum link de vídeo disponível. O conteúdo pode ser uma imagem ou não suportado pela API." }, { quoted: selolucas })
}
if (videoUrl) {
await zerotwo.sendMessage(from, { audio: { url: videoUrl }, mimetype: "audio/mpeg", ptt: true }, { quoted: selolucas })
}
} catch (error) {
console.error(`❌ Erro no comando multidl2: ${error.message}`)
const errorMsg = error.message.includes("API de download")
? "❌ A API de download está temporariamente fora do ar. Por favor, tente novamente mais tarde."
: `❌ Ocorreu um erro ao processar o download: ${error.message}`
zerotwo.sendMessage(from, { text: errorMsg }, { quoted: selolucas })
}
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: nasa
└─────────────────────────────────────────────────┘
*/
case 'nasa':
if(!q) return reply(`*Exemplo:* ${prefix}${command} 19-10-2007`)
try {
data = await fetchJson(`${zerosite}/api/nasaphoto?data=${q}&apikey=`+API_KEY_ZEROTWO)
resultExp = await fetchJson(`${zerosite}/api/info/translate?texto=${data.nasa.explanation}&ling=pt&apikey=`+API_KEY_ZEROTWO)
zerotwo.sendMessage(from, {image: {url: data.nasa.hdurl}, caption: resultExp.result}, {quoted: selolucas})
} catch (e) {
console.log("A api caiu ou não foi possivel executar esta ação., espere retornar")
reply("Erro")
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: nick
└─────────────────────────────────────────────────┘
*/
case 'nick':
try {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
//Canal: https://whatsapp.com/channel/0029Va6riekH5JLwLUFI7P2B
if (antiModLetra(q)) return reply("⚠️ *Não é permitido o uso de letras modificadas ou emojis.*")
if (!q) return reply(`✍️ *Insira um nome para gerar sugestões estilizadas.*\n\nExemplo: ${prefix + command} luquinhas`)
ABC = await fetchJson(`${zerosite}/api/fazernick?nome=${encodeURI(q)}&apikey=` + API_KEY_ZEROTWO)
if (!ABC || !ABC.length) return reply("❌ *Nenhum estilo foi gerado. Tente novamente.*")
let captionText = `🌟 *Nicks Gerados com Sucesso!* 🌟\n\n`
captionText += `🔹 *Nome Base:* _"${q}"_\n\n`
captionText += `✨ *Sugestões de Nicks Estilosos:*\n`
ABC.forEach((nick, index) => {
captionText += ` ${index + 1}. ${nick}\n`
})
captionText += `\n💬 *Digite o número do estilo que deseja copiar!*`
global.nickList = ABC
zerotwo.sendMessage(from, { image: waifuzdd3, caption: captionText }, { quoted: selolucas })
} catch (e) {
return reply("❌ *Ocorreu um erro ao gerar os nicks. Tente novamente mais tarde.*")
}
break

/*

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: noticias
└─────────────────────────────────────────────────┘
*/
case 'noticias':
if(!isVip && !isGroup) return reply(enviar.msg.pvnotvip)
try {
if(!q) return reply(`Informe um tema para realizar a pesquisa de suas notícias!`)
ABC = await fetchJson(`${zerosite}/api/noticias/find?q=${encodeURI(q)}&apiKey=`+API_KEY_ZEROTWO)
reply(ABC.resultado)
} catch (e) {
return console.log(e)
reply("Erro")
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: pdoc
└─────────────────────────────────────────────────┘
*/
case 'pdoc':
if(!q) return reply("KD o nome da música?")
try {
ABC = await fetchJson(`${zerosite}/api/ytsrc?q=${q}&apikey=${API_KEY_ZEROTWO}`)
data = ABC.resultado[0]
txt = `
⟬ 🅉🄴🅁🄾 🅃🅆🄾 🄳🄾🄲 🄼🅄🅂🄸🄲 ⟭

🎙️❒ 𝚃í𝚝𝚞𝚕𝚘: ${data.title}
⏰❒ 𝚃𝚎𝚖𝚙𝚘: ${data?.timestamp || "indefinido"}
🔎❒ 𝚅𝚒𝚜𝚞𝚊𝚕𝚒𝚣𝚊çõ𝚎𝚜: ${data.views}
🎞️❒ 𝙲𝚊𝚗𝚊𝚕: ${data?.author?.name || "indefinido"}
📹❒ 𝙿𝚘𝚜𝚝𝚊𝚍𝚘: ${data.ago || "indefinido"}
🗞️❒ 𝙳𝚎𝚜𝚌𝚛𝚒çã𝚘: ${data.description || "indefinida"}
`
reply(`ৎ❥̤֟٭ۣۜ𝙴𝚗𝚟𝚒𝚊𝚗𝚍𝚘 𝚂𝚞𝚊 𝙼ú𝚜𝚒𝚌𝚊🍧.ᩦ୭✧ࣶᭂ`)
zerotwo.sendMessage(from, {document: {url: `${zerosite}/api/dl/ytaudio?url=${data.url}&apikey=`+API_KEY_ZEROTWO}, caption: txt, mimetype: 'audio/mp4', fileName: data.title+".m4a", fileLength: 1000000 * ((Number(data.timestamp.replace(":", "") || 420) / 100) * (alerandom(1) + 1)), contextInfo: {externalAdReply: {title: NomeDoBot, body: '', mediaType: 1, thumbnail: await getBuffer(`${data.thumbnail}`), showAdAttribution: true, renderLargerThumbnail: true, sourceUrl: data.url}}}, {quoted: selolucas})
} catch(e) {
console.log(e)
reply("Erro")
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: pdoc2
└─────────────────────────────────────────────────┘
*/
case 'pdoc2':
if(!q) return reply("KD o nome da vídeo?")
try {
ABC = await fetchJson(`${zerosite}/api/ytsrc?q=${q}&apikey=${API_KEY_ZEROTWO}`)
data = ABC.resultado[0]
txt = `
⟬ 🅉🄴🅁🄾 🅃🅆🄾 🄳🄾🄲 🄼🄴🄳🄸🄰 ⟭

🎙️❒ 𝚃í𝚝𝚞𝚕𝚘: ${data.title}
⏰❒ 𝚃𝚎𝚖𝚙𝚘: ${data?.timestamp || "indefinido"}
🔎❒ 𝚅𝚒𝚜𝚞𝚊𝚕𝚒𝚣𝚊çõ𝚎𝚜: ${data.views}
🎞️❒ 𝙲𝚊𝚗𝚊𝚕: ${data?.author?.name || "indefinido"}
📹❒ 𝙿𝚘𝚜𝚝𝚊𝚍𝚘: ${data.ago || "indefinido"}
🗞️❒ 𝙳𝚎𝚜𝚌𝚛𝚒çã𝚘: ${data.description || "indefinida"}
`
reply( `ৎ❥̤֟٭ۣۜ𝙴𝚗𝚟𝚒𝚊𝚗𝚍𝚘 𝚅í𝚍𝚎𝚘🍧.ᩦ୭✧ࣶᭂ`)
zerotwo.sendMessage(from, {document: {url: `${zerosite}/api/dl/ytvideo?url=${data.url}&apikey=`+API_KEY_ZEROTWO}, caption: txt, mimetype: 'video/mp4', fileName: data.title+".mp4", fileLength: 1000000 * ((Number(data.timestamp.replace(":", "") || 204) / 10) * (alerandom(2) + 1)), contextInfo: {externalAdReply: {title: NomeDoBot, body: '', mediaType: 1, thumbnail: await getBuffer(`${data.thumbnail}`), showAdAttribution: true, renderLargerThumbnail: true, sourceUrl: data.url}}}, {quoted: selolucas})
} catch(e) {
console.log(e)
reply("Erro")
}
break

// DOWNLOADS

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: pensador
└─────────────────────────────────────────────────┘
*/
case 'pensador':
if(!q) return reply("Retorne um título para ser pesquisado, ex: "+prefix+command+" amor")
try {
ABC = await fetchJson(`${zerosite}/search/pensador?query=${encodeURI(q)}&apikey=`+API_KEY_ZEROTWO)
txt = `${"- ".repeat(20)}`
for(i of ABC.resultado) {
txt += `\n${i.frase}\n${"- ".repeat(20)}`
}
reply(txt)
} catch {
reply("Erro")
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: pesquisar
└─────────────────────────────────────────────────┘
*/
case 'pesquisar':
if(!q) return reply("Pergunte algo e eu retornarei alguns resultados de pesquisas...")
try {
ABC = await fetchJson(`${zerosite}/api/googlesrc?query=${encodeURI(q)}&apikey=`+API_KEY_ZEROTWO)
rr = ABC.result.length
txt = `\`\`\`Fo${rr > 1 ? "ram" : "i"} encontrado${rr > 1 ? "s" : ""} ${rr} resultado${rr > 1 ? "s" : ""} para a sua pesquisa\`\`\` 🔎`
for(i of ABC.result) {
txt += `\n• *Título:* ${i.title}\n• *Link:* ${i.originalUrl}\n`
}
reply(txt)
} catch {
reply("Erro ao obter detalhes da pesquisa")
}
break

/*

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: pesquisar-dorama
└─────────────────────────────────────────────────┘
*/
case 'pesquisar-dorama':
reagir(from, react2)
try {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
if (!q || q.trim() === '') {
console.log('Consulta não fornecida.')
return await zerotwo.sendMessage(from, { text: '❌ Por favor, forneça o título do dorama.' }, { quoted: selolucas })
}
const query = q.trim()
const apiUrl = `${zerosite}/api/doramas/search?query=${encodeURIComponent(query)}&apikey=${API_KEY_ZEROTWO}`
const response = await fetch(apiUrl)
const data = await response.json()
if (!data.status) {
console.log('Falha na pesquisa do dorama.')
return await zerotwo.sendMessage(from, { text: '❌ Não foi possível encontrar o dorama.' }, { quoted: selolucas })
}
const resultados = data.resultado
if (!resultados || resultados.length === 0) {
console.log('Nenhum dorama encontrado.')
return await zerotwo.sendMessage(from, { text: '❌ Nenhum dorama encontrado com esse título.' }, { quoted: selolucas })
}
for (const dorama of resultados) {
const doramaCaption = `🎥 *Título:* ${dorama.title}\n` +
`📝 *Descrição:* ${dorama.description}\n` +
`🗓️ *Ano de Lançamento:* ${dorama.releaseDate}\n` +
`🔗 *Link:* ${dorama.link}\n` +
`📺 *Tipo:* ${dorama.type}`
let imagemDoramaHD
if (dorama.imageUrl) {
// Primeiro aprimoramento
const hdResponseDorama = await fetch(`${zerosite}/api/ia/tohd?link=${dorama.imageUrl}&apikey=${API_KEY_ZEROTWO}`)
const arrayBufferDorama = await hdResponseDorama.arrayBuffer()
const bufferDorama = Buffer.from(arrayBufferDorama)
const base64Dorama = bufferDorama.toString('base64')
imagemDoramaHD = await upload(base64Dorama)
console.log(`Imagem do dorama aprimorada e carregada. URL: ${imagemDoramaHD}`)
// Reaprimoramento
const hdResponseReaprimoramento = await fetch(`${zerosite}/api/ia/tohd?link=${imagemDoramaHD}&apikey=${API_KEY_ZEROTWO}`)
const arrayBufferReaprimoramento = await hdResponseReaprimoramento.arrayBuffer()
const bufferReaprimoramento = Buffer.from(arrayBufferReaprimoramento)
const base64Reaprimoramento = bufferReaprimoramento.toString('base64')
imagemDoramaHD = await upload(base64Reaprimoramento)
} else {
console.log('Imagem do dorama não disponível.')
}
if (imagemDoramaHD) {
await zerotwo.sendMessage(from, { image: { url: imagemDoramaHD }, caption: doramaCaption }, { quoted: selolucas })
} else {
await zerotwo.sendMessage(from, { text: doramaCaption }, { quoted: selolucas })
}
}
} catch (error) {
console.error('Erro ao processar o comando pesquisar-dorama:', error)
await zerotwo.sendMessage(from, { text: '❌ Ocorreu um erro ao processar sua pesquisa.' }, { quoted: selolucas })
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: ph
└─────────────────────────────────────────────────┘
*/
case 'ph':
reagir(from, "🔥")
if(isGroup && !isNsfw) return reply(enviar.msg.modonsfw)
if (!isChatOfc && !isAdvencedVip(sender) && !isAdvencedGroupVip(from)) return reply(enviar.msg.vip)
if(!q) return reply(prefix+command+" link ou nome")
try {
if(!isUrl(q)) {
ABC = await fetchJson(zerosite+`/api/phsearch?q=${encodeURI(q)}&apikey=`+API_KEY_ZEROTWO)
if(ABC.resultado.length <= 0) return reply(`Sem resultados disponíveis..`)
i = ABC.resultado[alerandom(ABC.resultado.length)]
media = await fetchJson(zerosite+`/api/pornhub?url=${i.link}&apikey=`+API_KEY_ZEROTWO)
txt =
`📝 *TÍTULO:* ${i.title}
⏳ *DURAÇÃO:* ${i.duration}
📊 *VIEWS:* ${i.views}
💁🏼‍♀️ *ATRIZES:* ${media.result.pornstars.join(`, `)}
🔮 *CANAL:* ${media.result.provider.username}
🔗 *LINK:* ${i.link}`
sendUrlText(sender, txt, `☣ Search PORNHUB - `+i.title, media.result.tags.join(`, `), i.preview, i.link, selolucas)
sendVideo(sender, media.result.mediaDefinitions[0].videoUrl)
} else {
media = await fetchJson(zerosite+`/api/pornhub?url=${q}&apikey=`+API_KEY_ZEROTWO)
a = media.result
ABC = await fetchJson(zerosite+`/api/info/translate?texto=${encodeURI(a.title)}&ling=pt&apikey=`+API_KEY_ZEROTWO)
if(isGroup) reply(`Chega PV lek 😈`)
await sleep(1000)
txt =
`📝 *TÍTULO:* ${a.title}
⏳ *DURAÇÃO:* ${a.durationFormatted}
💖 *POSTADO:* ${a.uploadDate}
📊 *VIEWS:* ${largeNumber(a.views)}
✔ *LIKES:* ${a.vote.up}
✖ *DESLIKES:* ${a.vote.down}
📊 *CLASSIFICAÇÃO:* ${a.vote.rating}

💁🏼‍♀️ *ATRIZES:*
${a.pornstars.map(p => `• ${p}`).join(`\n`)}

🎭 *CATEGORIAS:*
${a.categories.map(c => `• ${c}`).join(`\n`)}

🔮 *CANAL:* ${a.provider.username}
🔗 *LINK:* https://pt.pornhub.com${a.provider.url}`
sendUrlText(sender, txt, a.title, a.tags.join(`, `), a.preview, a.url, selolucas)
sendVideo(sender, a.mediaDefinitions[0].videoUrl, "🔞 PH - "+ABC.result, selolucas)
}
} catch(e) { console.log(e)
reply(`Erro`) }
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: ping
└─────────────────────────────────────────────────┘
*/
case 'ping':
try {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
//Canal: https://whatsapp.com/channel/0029Va6riekH5JLwLUFI7P2B
reagir(from, "⚡")
const startTime = Date.now() / 1000
const uptime = kyun(process.uptime())
const sistemaOperacional = `${os.platform()} ${os.release()}`
const versaoNode = process.version
const ping = (startTime - info.messageTimestamp).toFixed(3)
const stts = ping < 1 ? 'estável' : ping < 3 ? 'bom' : 'ruim'
const { total, free } = await si.mem()
const memoriaTotal = (total / (1024 ** 3)).toFixed(2)
const memoriaUsada = ((total - free) / (1024 ** 3)).toFixed(2)
let ppimg = semfoto
try {
const profilePicUrl = await zerotwo.profilePictureUrl(`${sender.split('@')[0]}@c.us`, 'image')
const response = await axios.get(profilePicUrl, { responseType: 'arraybuffer' })
if (response.status === 200) {
ppimg = await upload(Buffer.from(response.data, 'binary'))
}
} catch {
console.log("Erro ao carregar a imagem de perfil.")
}
img = `${zerosite}/api/canvas/welcomify/welcome?` +
`title=${encodeURI('PING ZERO TWO')}&` +
`nome=${encodeURI(`» ${ping} «`)}&hex=FF0095&` +
`perfil=${ppimg}&message=${encodeURI('ZERO TWO BETA')}&` +
`fundo=${logoslink.ping}`
txt = `
❒ ⚡ Velocidade: ${ping} ms
❒ 🌐 Host: https://spacehosting.com.br
❒ ✍🏽 Ping: ${stts}
❒ 🗓️ Data & Hora: ${sendHours("DD/MM/YYYY")} - ${sendHours("HH:mm:ss")}
❒ 🖥️ Sistema: ${sistemaOperacional}
❒ 💻 Memória Total: ${memoriaTotal} GB
❒ 🧠 Memória Usada: ${memoriaUsada} GB
❒ ⌚ Uptime: ${uptime}
❒ 🔄 Node.js: ${versaoNode}`
sendImage(from, img, txt, selolucas)
} catch (e) {
console.error("Erro no comando 'ping':", e.message)
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: pinterest
└─────────────────────────────────────────────────┘
*/
case 'pinterest':
try {
if (!q) return reply(`Digite o nome da imagem que você quer buscar\nExemplo: ${prefix + command} Zero Two`)
console.log(color('[PINTEREST]', 'magenta'), color(`PROCURANDO IMAGE INFORMADA NO PINTEREST`, 'yellow'))
const response = await fetch(`${zerosite}/api/pinterest?text=${q}&apikey=${API_KEY_ZEROTWO}`)
console.log(`Requisição concluída. Status: ${response.status}`)
if (response.ok) {
const arrayBuffer = await response.arrayBuffer()
const imageBuffer = Buffer.from(arrayBuffer)
const imageUrl = await upload(imageBuffer)
await zerotwo.sendMessage(from, { image: { url: imageUrl }, caption: `*❯❯ ZERO TWO - PINTEREST ❮❮*\n\n*❒ Pesquisa:* ${q}`}, { quoted: selolucas })
} else {
reply('Não encontrei nada relacionado a isso 😐')
}
} catch (e) {
console.log('Erro ao buscar no Pinterest:', e)
reply('Houve um erro ao buscar a imagem. Tente novamente mais tarde.')
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: pinterest2
└─────────────────────────────────────────────────┘
*/
case 'pinterest2':
if (!q) return reply(`Exemplo: ${prefix + command} edits zero two`)
try {// By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
// Canal: https://whatsapp.com/channel/0029Va6riekH5JLwLUFI7P2B
reagir(from, '🔎')
const apiUrl = `${zerosite}/api/pinterest2?text=${encodeURIComponent(q)}&apikey=${API_KEY_ZEROTWO}`
const resultado = await fetchJson(apiUrl)
if (resultado.status && Array.isArray(resultado.resultado) && resultado.resultado.length > 0) {
console.log(`Total de resultados encontrados: ${resultado.resultado.length}`)
const item = resultado.resultado[Math.floor(Math.random() * resultado.resultado.length)]
console.log(`Enviando imagem com título: ${item.titulo_grid}`)
zerotwo.sendMessage(from, { image: { url: item.imagem_url }, caption: `*❯❯ ZERO TWO - PINTEREST ❮❮*\n\n*❒ Pesquisa:* ${q}\n🎥 *TÍTULO:* ${item.titulo_grid}\n🔗 *LINK:* ${item.link}\n📅 *CRIADO EM:* ${item.criado_em}\n🖼️ *PIN:* ${item.pin}\n🆔 *ID:* ${item.id}`}, {quoted: selolucas})
} else {
console.log("Nenhum resultado válido encontrado.")
reply("Nenhum resultado encontrado para sua pesquisa.")
}
} catch (e) {
console.error("Erro durante a execução do comando:", e)
reply("Erro ao buscar imagens. Por favor, tente novamente.")
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: pinterest3
└─────────────────────────────────────────────────┘
*/
case 'pinterest3':
try {// By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
// Canal: https://whatsapp.com/channel/0029Va6riekH5JLwLUFI7P2B
if (!q) return reply(`Digite o nome da imagem que você quer buscar\nExemplo: ${prefix + command} Zero Two`)
console.log(color('[PINTEREST]', 'magenta'), color(`PROCURANDO IMAGE INFORMADA NO PINTEREST`, 'yellow'))
reagir(from, '🔎')
const butao = []
for (let i = 0; i < 5; i++) {
console.log(`Realizando requisição ${i + 1} à API...`)
await new Promise((resolve) => setTimeout(resolve, 1000))
const response = await fetch(`${zerosite}/api/pinterest?text=${q}&apikey=${API_KEY_ZEROTWO}`)
console.log(`Requisição ${i + 1} concluída. Status: ${response.status}`)
if (response.ok) {
const arrayBuffer = await response.arrayBuffer()
const imageBuffer = Buffer.from(arrayBuffer)
console.log(`Imagem ${i + 1} recebida com sucesso. Enviando para a função de upload...`)
const imageUrl = await upload(imageBuffer)
console.log(`Imagem ${i + 1} enviada. URL: ${imageUrl}`)
butao.push({ image: { url: imageUrl }, caption: `*❯❯ ZERO TWO - PINTEREST ❮❮*\n\n*❒ Pesquisa:* ${q}\n🖼 *RESULTADO: ${i + 1}*` })
} else {
console.log(`Erro na requisição ${i + 1}: ${response.statusText}`)
}
}
console.log("Todas as requisições concluídas. Preparando envio...")
if (butao.length > 0) {
sendRoulette(from, zerotwo, butao, selolucas)
} else {
console.log("Nenhuma imagem foi encontrada.")
reply("Nenhum resultado encontrado.")
}
} catch (e) {
console.log("Erro durante a execução do comando:", e)
reply("Erro ao buscar imagens. Tente novamente.")
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: pinterest4
└─────────────────────────────────────────────────┘
*/
case 'pinterest4':
if (!q) return reply(`Exemplo: ${prefix + command} Superman`)
try {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
//Canal: https://whatsapp.com/channel/0029Va6riekH5JLwLUFI7P2B
reagir(from, '🔎')
const butao = []
for (let i = 0; i < 8; i++) {
console.log(`Realizando requisição ${i + 1} à API...`)
await new Promise((resolve) => setTimeout(resolve, 1000))
const response = await fetch(`${zerosite}/api/pinterest?text=${q}&apikey=${API_KEY_ZEROTWO}`)
console.log(`Requisição ${i + 1} concluída. Status: ${response.status}`)
if (response.ok) {
const arrayBuffer = await response.arrayBuffer()
const imageBuffer = Buffer.from(arrayBuffer)
console.log(`Imagem ${i + 1} recebida com sucesso. Enviando para a função de upload...`)
const imageUrl = await upload(imageBuffer)
console.log(`Imagem ${i + 1} enviada. URL: ${imageUrl}`)
butao.push({ image: { url: imageUrl }, caption: `*❯❯ ZERO TWO - PINTEREST ❮❮*\n\n*❒ Pesquisa:* ${q}\n🖼 *RESULTADO: ${i + 1}*` })
} else {
console.log(`Erro na requisição ${i + 1}: ${response.statusText}`)
}
}
console.log("Todas as requisições concluídas. Preparando envio...")
if (butao.length > 0) {
sendRoulette(from, zerotwo, butao, selolucas)
} else {
console.log("Nenhuma imagem foi encontrada.")
reply("Nenhum resultado encontrado.")
}
} catch (e) {
console.log("Erro durante a execução do comando:", e)
reply("Erro ao buscar imagens. Tente novamente.")
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: pinterest5
└─────────────────────────────────────────────────┘
*/
case 'pinterest5':
if (!q) return reply(`Exemplo: ${prefix + command} edits zero two`)
try {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
//Canal: https://whatsapp.com/channel/0029Va6riekH5JLwLUFI7P2B
reagir(from, '🔎')
const apiUrl = `${zerosite}/api/search-pinterest?query=${encodeURIComponent(q)}&apikey=${API_KEY_ZEROTWO}`
const resultados = await fetchJson(apiUrl)
console.log("Resposta da API recebida:", resultados)
if (Array.isArray(resultados) && resultados.length > 0) {
console.log(`Total de resultados encontrados: ${resultados.length}`)
const resultadosAleatorios = resultados.sort(() => Math.random() - 0.5).slice(0, 8)
const butao = []
resultadosAleatorios.forEach(item => {
console.log(`Adicionando resultado ao botão: ${item.titulo}`)
butao.push({video: { url: item.link }, caption: `*❯❯ ZERO TWO - PINTEREST ❮❮*\n\n*❒ Pesquisa:* ${q}\n🎥 *TÍTULO:* ${item.titulo}\n👤 *CRIADOR:* ${item.criador}`})
})
console.log("Preparando envio dos resultados...")
sendRoulette(from, zerotwo, butao, selolucas)
} else {
console.log("Nenhum resultado válido encontrado.")
reply("Nenhum resultado encontrado para sua pesquisa.")
}
} catch (e) {
console.error("Erro durante a execução do comando:", e)
reply("Erro ao buscar vídeos. Por favor, tente novamente.")
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: play
└─────────────────────────────────────────────────┘
*/
case 'play':{
if(!q) return reply('cade o nome?')
console.log(color('[PLAY]', 'magenta'), color(`PROCURANDO MÚSICA NO YT`, 'yellow'))
try {
reply(`⇒𝙿𝚎𝚜𝚚𝚞𝚒𝚜𝚊: _"${q}"_`)
ABC = await fetchJson(zerosite+`/api/ytsrc?q=${q}&apikey=`+API_KEY_ZEROTWO)
data = ABC.resultado[0]
con = converterMin(Number((contarMin(data.timestamp || "5:32") / 100) * 30).toFixed(0))
ini = con.includes(`ser um`) ? `0:35` : con.slice(1, con.length)
thumb = [`anime`, `classic`, `dynamic`, `space`, `space2`]
img = zerosite+`/api/canvas/musicardbun/music?nome=${data.title || "indefinido"}&autor=${data?.author?.name || "indefinido"}&tipo=${thumb[alerandom(thumb.length)]}&opacity=75&thumb=${data.thumbnail || logoslink.logo}&progresso=30&start=${ini}&end=${data.timestamp || "5:32"}`
setTimeout(async() => {
zeroTwoCarregamento(from, `ৎ❥̤֟٭ۣۜ𝙴𝚗𝚟𝚒𝚊𝚗𝚍𝚘 𝚂𝚞𝚊 𝙼ú𝚜𝚒𝚌𝚊🍧.ᩦ୭✧ࣶᭂ`, selolucas)
}, 1100)
bla =`
> ❯❯ 𝐙𝐄𝐑𝐎 𝐓𝐖𝐎 - DOWNLOADS ❮❮

> *❒ৣ͜͡Titulo:* ${data.title}
> *❒ৣ͜͡Canal:* ${data?.author?.name || "indefinido"}
> *❒ৣ͜͡Visualizações:* ${data.views}
> *❒ৣ͜͡Postado:* ${data?.ago || "indefinido"}
> *❒ৣ͜͡Duração:* ${data?.timestamp || "indefinido"}
> *❒ৣ͜͡Link:* ${data.url}
> *❒ৣ͜͡Descrição:* ${data?.description || "indefinida"}

> *Baixado por ✦『𝒁𝑬𝑹𝑶 𝑻𝑾𝑶』✦*`
audio = data.url
await zerotwo.sendMessage(from, {image: {url: img}, caption: bla, contextInfo: { mentionedJid: [sender], externalAdReply: { showAdAttribution: true, mediaType: 'VIDEO', mediaUrl: null, title: `💞 ${NomeDoBot} 💞\n》ｃｌｉｃｋ ａｑｕｉ《`, body: null, sourceUrl: links.linkss, thumbnail: await getBuffer(links.logocapa)}}}, {quoted: selolucas})
function getRandomAudioEndpoint() {
const endpoints = ['ytaudio', 'ytaudio2', 'ytaudio3', 'ytaudio4']
return endpoints[Math.floor(Math.random() * endpoints.length)]
}
const randomEndpoint = getRandomAudioEndpoint()
sendAudio(from, zerosite + `/api/dl/${randomEndpoint}?url=${audio}&apikey=` + API_KEY_ZEROTWO, 'audio/mp4', selolucas ).catch(e => {
return reply(downon)
})
} catch (e) {
console.log(e)
return reply(downoff)
}
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: play2
└─────────────────────────────────────────────────┘
*/
case 'play2':
{
try {
if(!q) return reply(`${prefix+command} link ou nome`)
reagir(from, "🔥")
zeroTwoCarregamento(from, `ৎ❥̤֟٭ۣۜ𝙴𝚗𝚟𝚒𝚊𝚗𝚍𝚘 𝚂𝚞𝚊 𝙼ú𝚜𝚒𝚌𝚊🍧.ᩦ୭✧ࣶᭂ`, selolucas)
data = await fetchJson(`${zerosite}/api/ytsrc/videos?q=${q}&apikey=`+API_KEY_ZEROTWO)
console.log(color('[PLAY 2]', 'magenta'), color(`PROCURANDO MÚSICA NO YT`, 'yellow')) 
zerotwo.sendMessage(from, {audio: {url: `${zerosite}/api/dl/ytaudio?url=${data.resultado[0].url}&apikey=`+API_KEY_ZEROTWO}, fileName: data.resultado[0].title+'.mp3', mimetype: 'audio/mp4', ptt: true, headerType: 4, contextInfo: { externalAdReply: { title: data.resultado[0].title, body: data.resultado[0].description, showAdAttribution: true, thumbnail: await getBuffer(data.resultado[0].image), mediaType: 2, mediaUrl: data.resultado[0].url, sourceUrl: data.resultado[0].url}}}, {quoted: selolucas}).catch(e => {
return reply(downon)
})
} catch (e) {
console.log(e)
return reply(downoff)
}
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: play3
└─────────────────────────────────────────────────┘
*/
case 'play3':
if(!isGroup) return reply(`Este menu play está disponível apenas para uso em grupo...`)
reagir(from, "🔥")
if(!q) return reply(`Use: ${prefix+command} nome da música`)
if(!JSON.stringify(music).includes(from)) {
music.push({groupId: from, usus: []})
fs.writeFileSync("./base de dados/music.json", JSON.stringify(music, null, 2))
}
AB = music.map(i => i.groupId).indexOf(from)
if(JSON.stringify(music[AB].usus).includes(sender)) {
AC = music[AB].usus.map(i => i.id).indexOf(sender)
music[AB].usus.splice(AC, 1)
fs.writeFileSync("./base de dados/music.json", JSON.stringify(music, null, 2))
}
try {
ABC = await fetchJson(`${zerosite}/api/ytsrc?q=${q}&apikey=${API_KEY_ZEROTWO}`)
bla = `
⟬ 🅩ⒺⓇⓄ ⓉⓌⓄ🅜ⓊⓈⒾⒸ»Ⓥ⑨.⑤« ⟭

🎙️❒ 𝚃í𝚝𝚞𝚕𝚘: ${ABC.resultado[0].title}
⏰❒ 𝚃𝚎𝚖𝚙𝚘: ${ABC.resultado[0].timestamp} com ${ABC.resultado[0].views} visualizações
🎞️❒ 𝙲𝚊𝚗𝚊𝚕: ${ABC.resultado[0].author.name}
📹❒ 𝙿𝚘𝚜𝚝𝚊𝚍𝚘: ${ABC.resultado[0].ago}
🗞️❒ 𝙳𝚎𝚜𝚌𝚛𝚒çã𝚘: ${ABC.resultado[0].description}

_${tempo} ${pushname}, digite *"áudio", "vídeo"* ou *"doc"* para escolher a forma de envio (sem as aspas)_
`
music[AB].usus.push({id: sender, urlAudio: `${zerosite}/api/dl/ytaudio?url=${ABC.resultado[0].url}&apikey=#API_KEY_ZEROTWO#`, urlVideo: `${zerosite}/api/dl/ytvideo?url=${ABC.resultado[0].url}&apikey=#API_KEY_ZEROTWO#`, title: ABC.resultado[0].title})
fs.writeFileSync("./base de dados/music.json", JSON.stringify(music, null, 2))
zerotwo.sendMessage(from, {image: {url: ABC.resultado[0].thumbnail}, caption: bla}, {quoted: selolucas})
} catch (e) {
return reply(downoff)
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: play4
└─────────────────────────────────────────────────┘
*/
case 'play4':{
try {
reagir(from, "🎵")
if(!q) return reply(`${prefix+command} link ou nome`)
if(!isUrl(q)) {
ABC = await fetchJson(zerosite+`/api/ytsrc?q=${q}&apikey=`+API_KEY_ZEROTWO)
data = ABC.resultado[0]
con = converterMin(Number((contarMin(data.timestamp || "5:32") / 100) * 30).toFixed(0))
ini = con.includes(`ser um`) ? `0:35` : con.slice(1, con.length)
thumb = [`anime`, `classic`, `dynamic`, `space`, `space2`]
img = zerosite+`/api/canvas/musicardbun/music?nome=${data.title || "indefinido"}&autor=${data?.author?.name || "indefinido"}&tipo=${thumb[alerandom(thumb.length)]}&opacity=75&thumb=${data.thumbnail || logoslink.logo}&progresso=30&start=${ini}&end=${data.timestamp || "5:32"}`
if(isGroup && !botoes) zeroTwoCarregamento(from, `ৎ❥̤֟٭ۣۜ𝙴𝚗𝚟𝚒𝚊𝚗𝚍𝚘 𝚂𝚞𝚊 𝙼ú𝚜𝚒𝚌𝚊🍧.ᩦ୭✧ࣶᭂ`, selolucas)
await sleep(3000)
bla = `${!botoes ? `
❬❬ [B̲̲̅̅E̲̲̅̅M̲̲̅̅ ̲̲̅̅V̲̲̅̅I̲̲̅̅N̲̲̅̅D̲̲̅̅O̲̲̅̅(̲̲̅̅A̲̲̅̅)̲̲̅♬̅] ❭❭
𖡋ꦿ${pushname}♪

` : ``}🎙️❒ 𝚃í𝚝𝚞𝚕𝚘: ${data.title}
⏰❒ 𝚃𝚎𝚖𝚙𝚘: ${data?.timestamp || "indefinido"}
🔎❒ 𝚅𝚒𝚜𝚞𝚊𝚕𝚒𝚣𝚊çõ𝚎𝚜: ${data.views}
🎞️❒ 𝙲𝚊𝚗𝚊𝚕: ${data?.author?.name || "indefinido"}
📹❒ 𝙿𝚘𝚜𝚝𝚊𝚍𝚘: ${data?.ago || "indefinido"}
🗞️❒ 𝙳𝚎𝚜𝚌𝚛𝚒çã𝚘: ${data?.description || "indefinida"} ${!botoes ? `

${ini} ━❍────────-${data?.timestamp || "5:32"} ↻ ⊲ Ⅱ ⊳ ↺
*VOLUME:* ▁▂▃▄▅▆▇ 100%
ılı.lıllılı.ıllı..ılı.lıllılı.ıllı
` : ``}`
audio = data.url
butao = [{type: `copy_url`, text: `𝘼́𝙐𝘿𝙄𝙊 🎵`, url: `${audio}`}]
sendRouletteButton(from, {image: {url: img}, caption: bla, footer: NomeDoBot}, zerotwo, sender, butao, selolucas)
if(botoes) return
} else {
zeroTwoCarregamento(from, `ৎ❥̤֟٭ۣۜ𝙴𝚗𝚟𝚒𝚊𝚗𝚍𝚘 𝚂𝚞𝚊 𝙼ú𝚜𝚒𝚌𝚊🍧.ᩦ୭✧ࣶᭂ`, selolucas)
await sleep(5000)
audio = q
}
await sleep(1000)
sendAudio(from, zerosite+`/api/dl/ytaudio?url=${audio}&apikey=`+API_KEY_ZEROTWO, 'audio/mp4', selolucas).catch(e => {
return reply(downon)
})
} catch (e) {
console.log(e)
return reply(downoff)
}
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: play5
└─────────────────────────────────────────────────┘
*/
case 'play5':
reagir(from, "🎵")
if(!q) return reply(`> - Exemplo: ${prefix}play nome da música\na música será baixada, só basta escolher áudio ou vídeo, se não baixar, o YouTube privou de não baixarem, ou algo do tipo..`)
console.log(color('[PLAY 5]', 'magenta'), color(`PROCURANDO MÚSICA NO YT`, 'yellow')) 
zeroTwoCarregamento(from, `ৎ❥̤֟٭ۣۜ𝙴𝚗𝚟𝚒𝚊𝚗𝚍𝚘 𝚂𝚞𝚊 𝙼ú𝚜𝚒𝚌𝚊🍧.ᩦ୭✧ࣶᭂ`, selolucas)
await sleep(5000)
res = await fetchJson(`${zerosite}/api/ytsrc/videos?q=${q}&apikey=`+API_KEY_ZEROTWO)
if(res.resultado[0].timestamp.length >= 7) return reply("> Desculpe, este video ou audio é muito grande, não poderei realizar este pedido, peça outra música abaixo de uma hora.")
bla = `> ✰͡ൣ᭄∆🔉𝐁𝐄𝐌✰𝐕𝐈𝐍𝐃𝐎🔊∆✰͡ൣ᭄ ♬
> 𖡋ꦿঔৣ͜͡✟ ${pushname} 𓁻🔥      ♪  
> 🌹⃟⋆͜͡҈➳ Titulo⧽: ${res.resultado[0].title}\n\n> 👑⃟⋆͜͡҈➳ Visualizações⧽: ${res.resultado[0].views}\n\n> ⏰⃟⋆͜͡҈➳ Tempo⧽ ${res.resultado[0].timestamp}\n\n> 💖⃟⋆͜͡҈➳ Canal⧽ ${res.resultado[0].author.name}\n> 0:00 ━❍──────── -${res.resultado[0].timestamp} ↻ ⊲ Ⅱ ⊳ ↺ VOLUME: ▁▂▃▄▅▆▇ 100%\n> ${tempo}
> ılı.lıllılı.ıllı..ılı.lıllılı.ıllı

> ${NomeDoBot} ♬`
let tumbnail = await prepareWAMessageMedia({ image: {url: `${res.resultado[0].image}`}}, { upload: zerotwo.waUploadToServer })
await zerotwo.relayMessage(from, 
{
interactiveMessage: {
header: {
title: '',
subtitle: '',
hasMediaAttachment: true,
imageMessage: tumbnail.imageMessage
},
footer: {
text: '- Baixado por Zero Two 💞',
},
body: { 
text: bla,
},
nativeFlowMessage: {
buttons: [{
name: "single_select",
buttonParamsJson: JSON.stringify({
title: "Escolha uma Opção",
sections: [{
title: "Qual mídia você vai querer?",
rows: [
{
header: "",
title: "🔊 Áudio",
description: "O bot enviará o seu pedido em forma de Áudio.",
id: `playaudio ${res.resultado[0].url}`
},
{
header: "",
title: "🎥 Vídeo",
description: "O bot enviará o seu pedido em forma de Vídeo.",
id: `playvideo ${res.resultado[0].url}`
},
{
header: "",
title: "📃 DOC. Áudio",
description: "O bot enviará o seu pedido em forma de Documento.",
id: `playdocaudio ${res.resultado[0].url}`
},
{
header: "",
title: "📃 DOC. Vídeo",
description: "O bot enviará o seu pedido em forma de Documento.",
id: `playdocvideo ${res.resultado[0].url}`
}
],
}]
}) 
}
],
messageParamsJson: "",
},
}
},
{ 
/* participant: {
count: 1,
jid: sender
} */
}
).then((r) => console.log(r))
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: play7
└─────────────────────────────────────────────────┘
*/
case 'play7':
reagir(from, "🔥")
try {
if(!q) return reply(`> Exemplo:\n\n${prefix+command} poze desabafo`)
await reply(`> Estou atendendo seu pedido [ ${pushname} ]`)
ABC = await fetchJson(`${zerosite}/api/ytsrc/videos?q=${q}&apikey=`+API_KEY_ZEROTWO)
data = ABC.resultado[0]
const buffer = await getBuffer(data.thumbnail) 
zerotwo.sendMessage(from, {audio: {url: `${zerosite}/api/dl/ytaudio?url=${data.url}&apikey=`+API_KEY_ZEROTWO}, mimetype: "audio/mp4",
headerType: 4,
contextInfo: {
externalAdReply: {
title: `${NomeDoBot}`,
body:`0:00 ❍─────${data.timestamp} ↻ ⊲ Ⅱ ⊳ ↺`,
fileName: `❒ 𝚃í𝚝𝚞𝚕𝚘: ${data.title}`,
showAdAttribution: true,
thumbnail: buffer,
mediaType: 2,
mediaUrl: `https://www.youtube.com/@Otaku.mp4`,
sourceUrl: `https://www.youtube.com/@Otaku.mp4`}}}, {quoted: selolucas})
} catch (erro) {
console.log(erro)
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: playcorte
└─────────────────────────────────────────────────┘
*/
case 'playcorte':
setTimeout(() => { reagir(from, "🎥") }, 300)
const fetchWithTimeout = (url, options, timeout = 20000) => {
return new Promise((resolve, reject) => {
const timer = setTimeout(() => {
reject(new Error('Request timed out'))
}, timeout)
fetch(url, options)
.then(response => {
clearTimeout(timer)
resolve(response)
})
.catch(err => {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
clearTimeout(timer)
reject(err)
})
})
}
try {
if (!q) return reply(`${prefix + command} link ou nome`)
let link
let data
let searchQuery = q
if (isUrl(q)) {
const videoIdMatch = q.match(/(?:v=|\/)([0-9A-Za-z_-]{11}).*/)
if (videoIdMatch && videoIdMatch[1]) {
const videoId = videoIdMatch[1]
console.log('Video ID:', videoId)
const videoDetailsResponse = await fetchWithTimeout(`${zerosite}/api/ytsrc?q=${videoId}&apikey=${API_KEY_ZEROTWO}`, {}, 20000)
const videoDetails = await videoDetailsResponse.json()
console.log('VideoDetails:', videoDetails)
if (videoDetails && videoDetails.resultado && videoDetails.resultado.length > 0) {
data = videoDetails.resultado[0]
searchQuery = data.title
link = data.url
console.log('Video URL:', link)
} else {
return reply(`Não foi possível obter as informações do vídeo para o link: _"${q}"_`)
}
} else {
return reply(`ID de vídeo não encontrado no link: _"${q}"_`)
}
} else {
reply(`⇒𝙿𝚎𝚜𝚌𝚞𝚒𝚜𝚊: _"${q}"_`)
setTimeout(async () => {
zerotwo.sendMessage(from, { text: `🌟 Enviando o vídeo...` })
}, 1100)
}
if (!data) {
const ABCResponse = await fetchWithTimeout(`${zerosite}/api/ytsrc?q=${searchQuery}&apikey=${API_KEY_ZEROTWO}`, {}, 20000)
const ABC = await ABCResponse.json()
console.log('ABC:', ABC)
if (ABC && ABC.resultado && ABC.resultado.length > 0) {
data = ABC.resultado[0]
link = data.url
console.log('Video URL:', link)
} else {
return reply(`Não foi possível encontrar o vídeo para a pesquisa: _"${q}"_`)
}
}
if (!data || !link) {
return reply(`Não foi possível obter as informações do vídeo para o link: _"${link || q}"_`)
}
const thumbnailUrl = data.thumbnail
const detailsMessage = `
❬❬ [B̲̲̅̅E̲̲̅̅M̲̲̅̅ ̲̲̅̅V̲̲̅̅I̲̲̅̅N̲̲̅̅D̲̲̅̅O̲̲̅̅(̲̲̅̅A̲̲̅̅)̲̲̅♬̅] ❭❭
𖡋ꦿ@${sender.split('@')[0]}♪

*🎙️❒ 𝚃í𝚝𝚞𝚕𝚘:* ${data.title}
*⏰❒ 𝚃𝚎𝚖𝚙𝚘:* ${data?.timestamp || "indefinido"}
*🔎❒ 𝚅𝚒𝚜𝚞𝚊𝚕𝚒𝚣𝚊çõ𝚎𝚜:* ${data.views}
*🆔❒ 𝙸𝚍:* ${data.videoId}
*🎞️❒ 𝙲𝚊𝚗𝚊𝚕:* ${data?.author?.name || "indefinido"}
*📹❒ 𝙿𝚘𝚜𝚝𝚊𝚍𝚘:* ${data?.ago || "indefinido"}
*🗞️❒ 𝙳𝚎𝚜𝚌𝚛𝚒çã𝚘:* ${data?.description || "indefinida"}

0:35 ━❍────────-${data.timestamp || "5:32"} ↻ ⊲ Ⅱ ⊳ ↺
VOLUME: ▁▂▃▄▅▆▇ 100%

${tempo}❣️
`
await zerotwo.sendMessage(from, { image: { url: thumbnailUrl }, caption: detailsMessage, mentions: [sender] }, { quoted: selolucas })
const tempDir = './temp'
if (fs.existsSync(tempDir)) {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
const files = fs.readdirSync(tempDir)
for (const file of files) {
const filePath = path.join(tempDir, file)
if (fs.statSync(filePath).isFile()) {
fs.unlinkSync(filePath)
}
}
}
if (!link) throw new Error('Link do vídeo não definido.')
const videoUrl = `${zerosite}/api/dl/ytvideo?url=${encodeURIComponent(link)}&apikey=${API_KEY_ZEROTWO}`
console.log('Downloading video from URL:', videoUrl)
const response = await fetchWithTimeout(videoUrl, {}, 30000)
if (!response.ok) throw new Error(`Erro ao baixar o vídeo: ${response.statusText}`)
const videoBuffer = Buffer.from(await response.arrayBuffer())
const videoPath = path.join(tempDir, 'input_video.mp4')
fs.writeFileSync(videoPath, videoBuffer)
console.log('Vídeo baixado e salvo em:', videoPath)
const duration = await getVideoDuration(videoPath)
if (!duration) throw new Error(`Não foi possível obter a duração do vídeo.`)
console.log('Duração do vídeo:', duration)
const segmentDuration = 60
reply('Cortando o vídeo, aguarde um pouco!')
let start = 0
const outputSegments = []
while (start < duration) {
const segmentPath = path.join(tempDir, `segment_${start}.mp4`)
await new Promise((resolve, reject) => {
ffmpeg(videoPath)
.setStartTime(start)
.setDuration(segmentDuration)
.output(segmentPath)
.on('end', () => {
outputSegments.push(segmentPath)
start += segmentDuration
resolve()
})
.on('error', (err) => {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
console.log('Erro ao cortar vídeo com FFmpeg:', err)
reject(err)
})
.run()
})
console.log('Segmento criado:', segmentPath)
}
for (let i = 0; i < outputSegments.length; i++) {
const segmentPath = outputSegments[i]
const segmentBuffer = fs.readFileSync(segmentPath)
const partNumber = i + 1
const detailspart = `
*❯❯ ZERO TWO - DOWNLOAD ❮❮*

*🎙️❒ 𝚃í𝚝𝚞𝚕𝚘:* ${data ? data.title : "Desconhecido"}
*⏰❒ 𝚃𝚎𝚖𝚙𝚘:* ${data?.timestamp || "indefinido"}
*🔎❒ 𝚅𝚒𝚜𝚞𝚊𝚕𝚒𝚣𝚊çõ𝚎𝚜:* ${data?.views || "indefinidas"}
*🆔❒ 𝙸𝚍:* ${data?.videoId || "Desconhecido"}
*🎞️❒ 𝙲𝚊𝚗𝚊𝚕:* ${data?.author?.name || "indefinido"}
*📹❒ 𝙿𝚘𝚜𝚝𝚊𝚍𝚘:* ${data?.ago || "indefinido"}
*✂️❒ 𝙿𝚊𝚛𝚝𝚎:* ${partNumber} / ${outputSegments.length}
*🗞️❒ 𝙳𝚎𝚜𝚌𝚛𝚒çã𝚘:* ${data?.description || "indefinida"}`
await zerotwo.sendMessage(from, { video: segmentBuffer, caption: detailspart }, { quoted: selolucas })
fs.unlinkSync(segmentPath)
console.log('Segmento enviado e excluído:', segmentPath)
}
fs.unlinkSync(videoPath)
console.log('Vídeo original excluído:', videoPath)
} catch (e) {
console.log('Erro no comando playcorte:', e)
return reply(downoff)
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: playlist
└─────────────────────────────────────────────────┘
*/
case 'playlist':
reagir(from, react2)
try {
if(!q) return reply(`Digite o nome de algum vídeo ou música que deseja encontrar..`)
ABC = await fetchJson(zerosite+`/api/ytsrc?q=${encodeURI(q)}&apikey=`+API_KEY_ZEROTWO)
caixa = []
for(a = 0 ; a < ABC.resultado.length; a++) {
i = ABC.resultado[a]
caixa.push({title: `RESULTADO ${a + 1}`, options: [{name: `🎵 ÁUDIO`, title: i.title, body: i.description, command: prefix+`play `+i.url}, {name: `🎥 VÍDEO`, title: i.title, body: i.description, command: prefix+`playvideo2 `+i.url}]})
}
if(caixa.length <= 0) return reply(`Sem resultados disponíveis..`)
ytresult = ABC.resultado[0]
if(isGroup) return sendUrlText(from, ABC.resultado.map(r =>
`🎙️ 𝕋𝕀́𝕋𝕌𝕃𝕆: ${r.title}
⏰ 𝕋𝔼𝕄ℙ𝕆: ${r?.timestamp || "indefinido"}
📹 ℙ𝕆𝕊𝕋𝔸𝔻𝕆: ${r?.ago || "indefinido"}
🎞️ ℂ𝔸ℕ𝔸𝕃: ${r?.author?.name || "indefinido"}
📎 𝕌ℝ𝕃: ${r.url}`).join(`\n${`-`.repeat(40)}\n`), `📼 YT SEARCH - ${ytresult.title}`, (ytresult?.timestamp || `00:00`) + ` - ` + (ytresult?.author?.name || `indefinido`), ytresult.thumbnail, ytresult.url, selolucas)
sendRouletteButton(sender, {image: {url: ytresult.thumbnail}, caption: `📼 YT SEARCH - Exibindo ${ABC.resultado.length} resultados 🕹`, footer: `Escolha áudio ou vídeo...`}, zerotwo, sender, [{type: `list`, title: `💢 RESULTADOS 💢`, rowId: caixa}], selolucas)
} catch (e) {
console.log(e)
return reply(`Erro 404`)
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: playmix
└─────────────────────────────────────────────────┘
*/
case 'playmix':
if (!isGroup) return reply(enviar.msg.grupo)
reagir(from, "🎵")
try {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
if (!q) return reply(`${prefix + command} link ou nome`)
const ABC = await fetchJson(`${zerosite}/api/ytsrc?q=${q}&apikey=${API_KEY_ZEROTWO}`)
if (!ABC.resultado || ABC.resultado.length === 0) {
return reply("Nenhum resultado encontrado.")
}
let bla = `
❯❯ ZERO͢ TWO͢ꫂ - DOWNLOAD - MIX ❮❮

⏤͟͟͞͞ ꦿ@${sender.split('@')[0]}♪
`
for (let i = 0; i < 5 && i < ABC.resultado.length; i++) {
const result = ABC.resultado[i]
bla += `
🎙️❒ 𝚃í𝚝𝚞𝚕𝚘: ${result.title}
⏰❒ 𝚃𝚎𝚖𝚙𝚘: ${result.timestamp || "indefinido"}
🔎❒ 𝚅𝚒𝚜𝚞𝚊𝚕𝚒𝚣𝚊çõ𝚎𝚜: ${result.views}
🎞️❒ 𝙲𝚊𝚗𝚊𝚕: ${result.author?.name || "indefinido"}
📹❒ 𝙿𝚘𝚜𝚝𝚊𝚍𝚘: ${result.ago || "indefinido"}
🗞️❒ 𝙳𝚎𝚜𝚌𝚛𝚒çã𝚘: ${result.description || "indefinida"}

0:35 ━❍────────-${result.timestamp || "5:32"} ↻ ⊲ Ⅱ ⊳ ↺
VOLUME: ▁▂▃▄▅▆▇ 100%
`
}
bla += `
${tempo}❣️
ılı.lıllılı.ıllı..ılı.lıllılı.ıllı
`
await zerotwo.sendMessage(from, { image: { url: ABC.resultado[0].thumbnail }, caption: bla, mentions: [sender] }, { quoted: selolucas })
await sleep(1000)
for (let i = 0; i < ABC.resultado.length && i < 5; i++) {
const music = ABC.resultado[i]
if (music.type === "video") {
const downloadUrl = `${zerosite}/api/dl/ytaudio?url=${music.url}&apikey=${API_KEY_ZEROTWO}`
await zerotwo.sendMessage(from, {audio: {url: downloadUrl, filename: `${music.title}.mp3`, mimetype: 'audio/mpeg', ptt: true }}, { quoted: selolucas })
await sleep(1000)
}
}
} catch (e) {
console.log(e)
return reply(downoff)
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: playmix2
└─────────────────────────────────────────────────┘
*/
case 'playmix2':
if (!q) return reply(`moryzinha ensinamentos: ${prefix+command} Rap Do Sukuna`) 
reply(`Realizando Download, Aguarde...`)
try {//By: Licth San 
const response = await fetchJson(`${zerosite}/api/ytsrc?q=${q}&apikey=`+API_KEY_ZEROTWO)
const { resultado } = response
let musicInfo = "❯❯ ZERO͢ TWO͢ꫂ - DOWNLOAD - MIX ❮❮\n\n"
let count = 0
for (let i = 0; i < resultado.length; i++) {
const music = resultado[i]
if (music.type === "video") {//By: Licth San 
musicInfo += `*ৡৢ͜͡𝔬⃝Título:* ${music.title}\n`
musicInfo += `*ৡৢ͜͡𝔬⃝Duração:* ${music.timestamp}\n`
musicInfo += `*ৡৢ͜͡𝔬⃝Link:* ${music.url}\n\n`
count++
}
}
if (count > 0) {//By: Licth San 
const capimg = await getBuffer(resultado[0].thumbnail)
await zerotwo.sendMessage(from, {image: capimg, caption: musicInfo}, {quoted: selolucas})
}
for (let i = 0; i < resultado.length; i++) {
const music = resultado[i]
if (music.type === "video") {//By: Licth San 
const downloadMsg = `❯❯ ꪶZERO͢ TWO͢ꫂ - DOWNLOAD- MIX ❮❮\n\nৡৢ͜͡𝔬⃝Download ${i + 1}: ${music.title}\n\n`
await zerotwo.sendMessage(from, {audio: {url: `${zerosite}/api/dl/ytaudio?url=${music.url}&apikey=`+API_KEY_ZEROTWO}, filename: music.title+'.m4a', mimetype: 'audio/mp4', ptt: true}, {quoted: selolucas})
await sleep(1000)
}
}
} catch (error) {//By: Licth San 
console.log("Erro ao processar a solicitação:", error)
reply("Ocorreu um erro ao processar sua solicitação. Por favor, tente novamente mais tarde.")
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: playstore
└─────────────────────────────────────────────────┘
*/
case 'playstore':
if(!q) return reply(`KD o nome do app ?`)
try {
ABC = await fetchJson(`${zerosite}/api/playstore?nome=${encodeURI(q)}&apikey=`+API_KEY_ZEROTWO)
i = ABC.pesquisa.resultado[0]
txt = `
❪🏷️ฺ࣭࣪͘ꕸ▸ 𝙽𝚘𝚖𝚎৴▸ ${i.nome}
❪📟ฺ࣭࣪͘ꕸ▸ 𝙳𝚎𝚜𝚎𝚗𝚟𝚘𝚕𝚟𝚎𝚍𝚘𝚛৴▸ ${i.desenvolvedor}
❪⭐ฺ࣭࣪͘ꕸ▸ 𝙰𝚟𝚊𝚕𝚒𝚊çã𝚘৴▸ ${i.estrelas}
𖡋ꦿ𝙻𝚒𝚗𝚔ฺ࣭࣪͘ꕸ▸ ${i.link}
`
zerotwo.sendMessage(from, {text: txt, contextInfo: {
externalAdReply: {
title: `🎮 𝙋𝙇𝘼𝙔 𝙎𝙏𝙊𝙍𝙀 🎮`,
body: ``,
thumbnail: await getBuffer(i.imagem),
mediaType: 1,
sourceUrl: i.link
}, forwardingScore: 1000000, isForwarded: true, forwardedNewsletterMessageInfo: {newsletterJid: channel }}}, {quoted: selolucas})
} catch {
reply(`Não encontrei nenhum app, ou pode ser que a api caiu`)
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: playteste
└─────────────────────────────────────────────────┘
*/
case 'playteste': {
if (!q) return reply('Cade o nome?')
console.log(color('[PLAYTESTE]', 'magenta'), color(`PROCURANDO MÚSICA NO YT`, 'yellow'))
try {
reply(`⇒𝙿𝚎𝚜𝚚𝚞𝚒𝚜𝚊: _"${q}"_`)
const res = await fetchJson(`${zerosite}/api/ytsrc/videos?q=${q}&apikey=${API_KEY_ZEROTWO}`)
if (!res.resultado || res.resultado.length === 0) {
return reply('Nenhuma música encontrada.')
}
const video = res.resultado[0]
const imgUrl = `${video.image}`
let player1 = await prepareWAMessageMedia({ image: { url: imgUrl } }, { upload: zerotwo.waUploadToServer })
let player2 = await prepareWAMessageMedia({ image: { url: imgUrl } }, { upload: zerotwo.waUploadToServer })
let player3 = await prepareWAMessageMedia({ image: { url: imgUrl } }, { upload: zerotwo.waUploadToServer })
let player4 = await prepareWAMessageMedia({ image: { url: imgUrl } }, { upload: zerotwo.waUploadToServer })
let player5 = await prepareWAMessageMedia({ image: { url: imgUrl } }, { upload: zerotwo.waUploadToServer })
let player6 = await prepareWAMessageMedia({ image: { url: imgUrl } }, { upload: zerotwo.waUploadToServer })
zerotwo.relayMessage(from, { 
viewOnceMessage: {
message: {
"messageContextInfo": {
"deviceListMetadata": {},
"deviceListMetadataVersion": 2
},
interactiveMessage: proto.Message.InteractiveMessage.create({
body: { text: `*POR FAVOR SELECIONE A SUA OPÇÃO ABAIXO:*` },
contextInfo: { participant: sender, quotedMessage: info.message, forwardingScore: 999, isForwarded: true, forwardedNewsletterMessageInfo: {newsletterJid: channel, newsletterName: `𝙲𝙾𝙽𝙽𝙴𝙲𝚃𝙴𝙳 𝙲𝙾𝙽𝚃𝙴Ú𝙳𝙾𝚂`}},
carouselMessage: proto.Message.InteractiveMessage.CarouselMessage.fromObject({
cards: [
{
header: {
imageMessage: player1.imageMessage,
hasMediaAttachment: true
},
body: { text: `🔊 Áudio` },
nativeFlowMessage: {
buttons: [{
"name": "quick_reply",
"buttonParamsJson": JSON.stringify({
"display_text": "Baixar Áudio",
"id": "playaudio",
"copy_code": `${video.url}`
})
}]
}
},
{
header: {
imageMessage: player2.imageMessage,
hasMediaAttachment: true
},
body: { text: `🎥 Vídeo` },
nativeFlowMessage: {
buttons: [{
"name": "quick_reply",
"buttonParamsJson": JSON.stringify({
"display_text": "Baixar Vídeo",
"id": "playvideo",
"copy_code": `${video.url}`
})
}]
}
},
{
header: {
imageMessage: player3.imageMessage,
hasMediaAttachment: true
},
body: { text: `📃 DOC. Áudio` },
nativeFlowMessage: {
buttons: [{
"name": "quick_reply",
"buttonParamsJson": JSON.stringify({
"display_text": "Baixar DOC. Áudio",
"id": "playdocaudio",
"copy_code": `${video.url}`
})
}]
}
},
{
header: {
imageMessage: player4.imageMessage,
hasMediaAttachment: true
},
body: { text: `📃 DOC. Vídeo` },
nativeFlowMessage: {
buttons: [{
"name": "quick_reply",
"buttonParamsJson": JSON.stringify({
"display_text": "Baixar DOC. Vídeo",
"id": "playdocvideo",
"copy_code": `${video.url}`
})
}]
}
}
]
})
})
}
}
}, selolucas)
zerotwo.ev.on('messages.upsert', async (messageUpdate) => {
const buttonMessage = messageUpdate.messages[0]
const buttonId = buttonMessage?.message?.buttonsResponseMessage?.selectedButtonId
if (buttonId) {
const action = buttonId.split('_')[0]
const url = buttonId.split('_')[1]
if (action === 'playaudio') {
await sendAudio(from, `${zerosite}/api/dl/ytaudio?url=${url}&apikey=${API_KEY_ZEROTWO}`, 'audio/mp4', selolucas).catch(e => {
return reply('Erro ao baixar o áudio.')
})
} else if (action === 'playvideo') {
await sendVideo(from, `${zerosite}/api/dl/ytvideo?url=${url}&apikey=${API_KEY_ZEROTWO}`, selolucas).catch(e => {
return reply('Erro ao baixar o vídeo.')
})
} else if (action === 'playdocaudio') {
await sendDocument(from, `${zerosite}/api/dl/ytaudio?url=${url}&apikey=${API_KEY_ZEROTWO}`, 'audio/mp4', 'audio.mp3', selolucas).catch(e => {
return reply('Erro ao baixar o áudio como documento.')
})
} else if (action === 'playdocvideo') {
await sendDocument(from, `${zerosite}/api/dl/ytvideo?url=${url}&apikey=${API_KEY_ZEROTWO}`, 'video/mp4', 'video.mp4', selolucas).catch(e => {
return reply('Erro ao baixar o vídeo como documento.')
})
}
}
})
} catch (e) {
console.log(e)
return reply('Erro ao buscar informações.')
}
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: playvideo
└─────────────────────────────────────────────────┘
*/
case 'playvideo':
setTimeout(() => {reagir(from, "🎥")}, 300)
try {
if(!q) return reply(`${prefix+command} link ou nome`)
if(!isUrl(q)) {
reply(`⇒𝙿𝚎𝚜𝚚𝚞𝚒𝚜𝚊: _"${q}"_`)
setTimeout(async() => {
zerotwo.sendMessage(from, {text: `ৎ❥̤֟٭ۣۜ𝙴𝚗𝚟𝚒𝚊𝚗𝚍𝚘 𝚅í𝚍𝚎𝚘🍧.ᩦ୭✧ࣶᭂ`})
}, 1100)
ABC = await fetchJson(`${zerosite}/api/ytsrc?q=${q}&apikey=${API_KEY_ZEROTWO}`)
data = ABC.resultado[0]
bla = `
❬❬ [B̲̲̅̅E̲̲̅̅M̲̲̅̅ ̲̲̅̅V̲̲̅̅I̲̲̅̅N̲̲̅̅D̲̲̅̅O̲̲̅̅(̲̲̅̅A̲̲̅̅)̲̲̅♬̅] ❭❭
𖡋ꦿ@${sender.split('@')[0]}♪

🎙️❒ 𝚃í𝚝𝚞𝚕𝚘: ${data.title}
⏰❒ 𝚃𝚎𝚖𝚙𝚘: ${data?.timestamp || "indefinido"}
🔎❒ 𝚅𝚒𝚜𝚞𝚊𝚕𝚒𝚣𝚊çõ𝚎𝚜: ${data.views}
🎞️❒ 𝙲𝚊𝚗𝚊𝚕: ${data?.author?.name || "indefinido"}
📹❒ 𝙿𝚘𝚜𝚝𝚊𝚍𝚘: ${data?.ago || "indefinido"}
🗞️❒ 𝙳𝚎𝚜𝚌𝚛𝚒çã𝚘: ${data?.description || "indefinida"}

0:35 ━❍────────-${data.timestamp || "5:32"} ↻ ⊲ Ⅱ ⊳ ↺
VOLUME: ▁▂▃▄▅▆▇ 100%

${tempo}❣️
ılı.lıllılı.ıllı..ılı.lıllılı.ıllı`
link = data.url
} else {link = q
bla = ``}
sendVideo(from, zerosite+`/api/dl/ytvideo?url=${link}&apikey=`+API_KEY_ZEROTWO, bla, selolucas).catch(e => {
return reply(downon)
})
function getRandomAudioEndpoint() {
const endpoints = ['ytvideo', 'ytvideo2', 'ytvideo3', 'ytvideo4']
return endpoints[Math.floor(Math.random() * endpoints.length)]
}
const randomEndpoint = getRandomAudioEndpoint()
sendVideo(from, zerosite+`/api/dl/${randomEndpoint}?url=${link}&apikey=`+API_KEY_ZEROTWO, bla, selolucas ).catch(e => {
return reply(downon)
})
} catch (e) {
return reply(downoff)
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: playvideo2
└─────────────────────────────────────────────────┘
*/
case 'playvideo2':
setTimeout(() => { reagir(from, "🎥") }, 300)
try {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
if (!q) return reply(`${prefix + command} link ou nome`)
let link, bla
reply(`⇒𝙿𝚎𝚜𝚚𝚞𝚒𝚜𝚊: _"${q}"_`)
const pingInterval = setInterval(() => {
if (res && !res.headersSent) {
res.write(" ")
}
}, 15000)
if (!isUrl(q)) {
const videoInfo = await fetchJson(`${zerosite}/api/ytsrc?q=${q}&apikey=${API_KEY_ZEROTWO}`)
if (videoInfo && videoInfo.resultado && videoInfo.resultado[0]) {
const data = videoInfo.resultado[0]
bla = `
❬❬ [B̲̲̅̅E̲̲̅̅M̲̲̅̅ ̲̲̅̅V̲̲̅̅I̲̲̅̅N̲̲̅̅D̲̲̅̅O̲̲̅̅(̲̲̅̅A̲̲̅♬̅] ❭❭
𖡋ꦿ@${sender.split('@')[0]}♪

🎙️❒ 𝚃í𝚝𝚞𝚕𝚘: ${data.title}
⏰❒ 𝚃𝚎𝚖𝚙𝚘: ${data?.timestamp || "indefinido"}
🔎❒ 𝚅𝚒𝚜𝚞𝚊𝚕𝚒𝚣𝚊çõ𝚎𝚜: ${data.views}
🎞️❒ 𝙲𝚊𝚗𝚊𝚕: ${data?.author?.name || "indefinido"}
📹❒ 𝙿𝚘𝚜𝚝𝚊𝚍𝚘: ${data?.ago || "indefinido"}
🗞️❒ 𝙳𝚎𝚜𝚌𝚛𝚒çã𝚘: ${data?.description || "indefinida"}

0:35 ━❍────────-${data.timestamp || "5:32"} ↻ ⊲ Ⅱ ⊳ ↺
VOLUME: ▁▂▃▄▅▆▇ 100%

${tempo}❣️
ılı.lıllılı.ıllı..ılı.lıllılı.ıllı`
link = data.url
} else {
throw new Error("Vídeo não encontrado")
}
} else {
link = q
bla = ``
}
const controller = new AbortController()
const timeout = setTimeout(() => controller.abort(), 600000)
try {
await sendVideo(from, `${zerosite}/api/dl/ytvideo?url=${link}&apikey=${API_KEY_ZEROTWO}`, bla, info, { signal: controller.signal })
clearInterval(pingInterval)
clearTimeout(timeout)
} catch (error) {
clearInterval(pingInterval)
clearTimeout(timeout)
if (error.name === 'AbortError') {
return reply("Tempo limite para o processamento do vídeo excedido. Tente novamente mais tarde.")
} else {
console.log("Erro ao enviar o vídeo:", error)
return reply("Erro ao processar o download do vídeo. Tente novamente mais tarde.")
}
}
} catch (e) {
console.log("Erro ao processar o comando playvideo:", e)
return reply("Erro ao processar o download do vídeo. Tente novamente mais tarde.")
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: pokemon
└─────────────────────────────────────────────────┘
*/
case 'pokemon':
if (!q) return reply(`Por favor, forneça o nome de um Pokémon para buscar informações.\nExemplo: ${prefix + command} Charizard`)
try {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
//Canal: https://whatsapp.com/channel/0029Va6riekH5JLwLUFI7P2B
const response = await axios.get(`${zerosite}/api/pokemon-search?name=${encodeURI(q)}&apikey=${API_KEY_ZEROTWO}`)
if (response.data && response.data.name) {
const pokemon = response.data
const caption = `
❯❯ *❒ Nome:* ${pokemon.name}
❯❯ *❒ ID:* ${pokemon.id}
❯❯ *❒ Tipo(s):* ${pokemon.types.map(t => t.name).join(', ')}
❯❯ *❒ Altura:* ${(pokemon.height / 10).toFixed(1)} m
❯❯ *❒ Peso:* ${(pokemon.weight / 10).toFixed(1)} kg
❯❯ *❒ Gênero:* ${pokemon.genera}
❯❯ *❒ Taxas de Gênero:*
ꕸ▸ - Macho: ${pokemon.gender_rate.male}%
ꕸ▸ - Fêmea: ${pokemon.gender_rate.female}%
ꕸ▸ - Sem Gênero: ${pokemon.gender_rate.genderless ? 'Sim' : 'Não'}
❯❯ *❒ Grupos de Ovos:* ${pokemon.egg_groups.join(', ')}
❯❯ *❒ Baby Pokémon:* ${pokemon.is_baby ? 'Sim' : 'Não'}
❯❯ *❒ Lendário:* ${pokemon.is_legendary ? 'Sim' : 'Não'}
❯❯ *❒ Mítico:* ${pokemon.is_mythical ? 'Sim' : 'Não'}
❯❯ *❒ Diferenças de Gênero:* ${pokemon.has_gender_differences ? 'Sim' : 'Não'}
❯❯ *❒ Habilidades:*
${pokemon.abilities.map(a => `ꕸ▸ - ${a.name} (${a.is_hidden ? 'Oculta' : 'Normal'})`).join('\n')}
❯❯ *❒ Estatísticas:*
ꕸ▸ - HP: ${pokemon.stats.hp}
ꕸ▸ - Ataque: ${pokemon.stats.attack}
ꕸ▸ - Defesa: ${pokemon.stats.defense}
ꕸ▸ - Velocidade: ${pokemon.stats.speed}

❯❯ *❒ Descrições por Versão (Filtradas por Inglês):*
${
Array.isArray(pokemon.flavor_text_entries)
? pokemon.flavor_text_entries
.filter(entry => entry.language === 'en')
.map(entry => `ꕸ▸ - Versão (${entry.version}): ${entry.flavor_text.replace(/\n/g, ' ')}`)
.join('\n')
: 'Nenhuma descrição disponível.'
}
`.trim()
await zerotwo.sendMessage(from, { image: { url: pokemon.sprites.front_default }, caption: caption }, { quoted: selolucas })
if (pokemon.cries.latest) {
await zerotwo.sendMessage(from, { text: `*Choro Atualizado de ${pokemon.name}*` }, { quoted: selolucas })
await zerotwo.sendMessage(from, { audio: { url: pokemon.cries.latest }, mimetype: 'audio/mpeg', ptt: true }, { quoted: selolucas })
}
if (pokemon.cries.legacy) {
await zerotwo.sendMessage(from, { text: `*Choro Clássico de ${pokemon.name}*` }, { quoted: selolucas })
await zerotwo.sendMessage(from, { audio: { url: pokemon.cries.legacy }, mimetype: 'audio/mpeg', ptt: true }, { quoted: selolucas })
}
} else {
await zerotwo.sendMessage(from, { text: 'Não foi possível encontrar informações sobre este Pokémon.' }, { quoted: selolucas })
}
} catch (error) {
console.error('Erro ao buscar Pokémon:', error)
await zerotwo.sendMessage(from, { text: 'Ocorreu um erro ao buscar as informações do Pokémon.' }, { quoted: selolucas })
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: ps-search
└─────────────────────────────────────────────────┘
*/
case 'ps-search':
if(!q) return reply(`KD o nome do app ?`)
try {
ABC = await fetchJson(`${zerosite}/api/playstore?nome=${encodeURI(q)}&apikey=`+API_KEY_ZEROTWO)
txt = `🎮 𝙋𝙇𝘼𝙔 𝙎𝙏𝙊𝙍𝙀 🎮`
for(i of ABC.pesquisa.resultado) {
txt += `\n\n❪🏷️ฺ࣭࣪͘ꕸ▸ 𝙽𝚘𝚖𝚎৴▸ ${i.nome}
❪📟ฺ࣭࣪͘ꕸ▸ 𝙳𝚎𝚜𝚎𝚗𝚟𝚘𝚕𝚟𝚎𝚍𝚘𝚛৴▸ ${i.desenvolvedor}
❪⭐ฺ࣭࣪͘ꕸ▸ 𝙰𝚟𝚊𝚕𝚒𝚊çã𝚘৴▸ ${i.estrelas}
𖡋ꦿ𝙻𝚒𝚗𝚔ฺ࣭࣪͘ꕸ▸ ${i.link}`
}
reply(txt)
} catch {
reply(`Não encontrei nenhum app, ou pode ser que a api caiu`)
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: quizanime
└─────────────────────────────────────────────────┘
*/
case 'quizanime': { //By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
//Canal: https://whatsapp.com/channel/0029Va6riekH5JLwLUFI7P2B
if (!isGroup) return reply('Comando apenas para grupos.')
if (!isModobn) return reply(enviar.msg.modobz)
try {
const response = await fetch(`${zerosite}/quiz?apikey=${API_KEY_ZEROTWO}`)
const quizData = await response.json()
//console.log(quizData)
if (!quizData.status) {
return reply("❌ Não foi possível carregar o quiz de anime no momento. Tente novamente mais tarde.")
}
global.animeQuiz = {
question: quizData.pergunta,
options: quizData.opcoes,
correctAnswer: quizData.resposta
}
let caption = `🎮 *Quiz de Anime*\n\n*Pergunta:* ${quizData.pergunta}\n\nEscolha uma opção enviando no formato "Opção X":\n`
quizData.opcoes.forEach((opcao, index) => {
caption += `Opção ${index + 1}: ${opcao}\n`
})
zerotwo.sendMessage(from, {image: { url: quizData.imagem }, caption: caption}, { quoted: selolucas })
} catch (e) {
console.log(e)
reply("❌ Ocorreu um erro ao carregar o quiz de anime. Tente novamente mais tarde.")
}
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: rank1
└─────────────────────────────────────────────────┘
*/
case 'rank1':
mapa = level.map(i => i)
rank = mapa.sort((a, b) => (a.contador < b.contador) ? 0 : -1)
img = zerosite + `/api/canvas/top?message=${encodeURI("XP:")}&fundo=https://telegra.ph/file/c387a17d51390c2d42d41.jpg`
const fotosTop1 = []
for (let i = 0; i < 10; i++) {
try {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
const profilePicUrl = await zerotwo.profilePictureUrl(`${rank[i].id.split('@')[0]}@c.us`, 'image')
const response = await axios.get(profilePicUrl, {
responseType: 'arraybuffer',
headers: {
'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3'
}
})
if (response.status === 200) {
const buffer = Buffer.from(response.data, 'binary')
fotosTop1[i] = await upload(buffer)
} else {
fotosTop1[i] = semfoto
}
} catch (e) {
console.log(`Erro ao obter a imagem de perfil para o rank ${i + 1}:`, e.message)
fotosTop1[i] = semfoto
}
}
for (i = 0; i < 10; i++) {
if (i != null) {
usu = rank[i]
nmr = String(i + 1)
img += `&foto${nmr}=${fotosTop1[i]}&nome${nmr}=${encodeURI(getname(usu.id))}&xp${nmr}=${usu.contador}`
}
}
sendStickerFromUrl(from, img)
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: rank10
└─────────────────────────────────────────────────┘
*/
case 'rank10':
mapa = level.map(i => i)
rank = mapa.sort((a, b) => (a.contador < b.contador) ? 0 : -1)
img = zerosite + `/api/canvas/top?message=${encodeURI("XP:")}&fundo=https://telegra.ph/file/c387a17d51390c2d42d41.jpg`
const fotos = []
for (let i = 0; i < 10; i++) {
try {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
const profilePicUrl = await zerotwo.profilePictureUrl(`${rank[i].id.split('@')[0]}@c.us`, 'image')
const response = await axios.get(profilePicUrl, {
responseType: 'arraybuffer',
headers: {
'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3'
}
})
if (response.status === 200) {
const buffer = Buffer.from(response.data, 'binary')
fotos[i] = await upload(buffer)
} else {
fotos[i] = semfoto
}
} catch (e) {
console.log(`Erro ao obter a imagem de perfil para o rank ${i + 1}:`, e.message)
fotos[i] = semfoto
}
}
for (i = 0; i < 10; i++) {
if (i != null) {
usu = rank[i]
nmr = String(i + 1)
img += `&foto${nmr}=${fotos[i]}&nome${nmr}=${encodeURI(getname(usu.id))}&xp${nmr}=${usu.contador}`
}
}
sendImage(from, img)
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: rastrear
└─────────────────────────────────────────────────┘
*/
case 'rastrear':
if(!isGroup) return reply(enivar.msg.grupo)
if(!q) return reply(`Coloque após o comando o código de rastreamento dos correios, para a bot pesquisar e rastrear o seu produto encomendado`)
ABC = await fetchJson(`${zerosite}/api/rastreio?code=${q.toUpperCase()}&apikey=${API_KEY_ZEROTWO}`)
if(ABC.resultado.pathObject.length <= 0) return reply(`Código não encontrado ou inexistente🍧.ᩦ୭✧ࣶᭂ`)
reply(ABC.resultado.pathObject)
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: remini2
└─────────────────────────────────────────────────┘
*/
case 'remini2':
try { //By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
//Canal: https://whatsapp.com/channel/0029Va6riekH5JLwLUFI7P2B
if ((isMedia && !info.message.videoMessage) || isQuotedImage) {
let post
if (isQuotedImage) {
if (info.message.extendedTextMessage && info.message.extendedTextMessage.contextInfo) {
if (info.message.extendedTextMessage.contextInfo.quotedMessage && info.message.extendedTextMessage.contextInfo.quotedMessage.imageMessage) {
post = info.message.extendedTextMessage.contextInfo.quotedMessage.imageMessage
} else {
console.log('contextInfo não contém uma imagem válida')
return reply('😈 _Marque uma imagem válida para aplicar o filtro do Remini_')
}
} else {
console.log('Nenhum contextInfo encontrado ou contexto inválido')
return reply('😈 _Marque uma imagem válida para aplicar o filtro do Remini_')
}
} else {
post = info.message.imageMessage
}
reply('😈 _Processando sua imagem! Aguarde..._')
const imagem = await downloadContentFromMessage(post, 'image')
let imageBuffer = Buffer.from([])
for await (const chunk of imagem) {
imageBuffer = Buffer.concat([imageBuffer, chunk])
}
const imageLink = await upload(imageBuffer)
const response = await fetch(`${zerosite}/api/ia/tohd?url=${imageLink}&apikey=${API_KEY_ZEROTWO}`)
if (!response.ok) {
console.log('Erro ao processar a imagem:', response.statusText)
return reply('😈 _Ocorreu um erro ao processar a imagem. Tente novamente mais tarde._')
}
const arrayBuffer = await response.arrayBuffer()
const buffer = Buffer.from(arrayBuffer)
await zerotwo.sendMessage(from, { image: buffer }, { quoted: selolucas })
} else {
console.log('Nenhuma mídia ou imagem citada encontrada')
return reply('😈 _Marque a imagem para eu poder aplicar o filtro do Remini_')
}
} catch (e) {
console.log('Erro:', e)
return reply("Erro..")
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: retro
└─────────────────────────────────────────────────┘
*/
case 'retro':
try {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
//Canal: https://whatsapp.com/channel/0029Va6riekH5JLwLUFI7P2B
const textin = args.join(" ")
if (!textin) return reply("KD o texto?")
if (!textin.includes("/")) return reply(`Cade a / precisa dela para a separação..\nExemplo: ${prefix + command} zero/two/beta`)
const [txt1, txt2, txt3] = textin.split("/")
if (!txt1 || !txt2 || !txt3)
return reply("Você precisa informar três textos separados por `/`.\nExemplo: `Texto1/Texto2/Texto3`")
reply(`ৎ❥̤֟٭ۣۜ𝙶𝚎𝚛𝚊𝚗𝚍𝚘 𝚂𝚞𝚊 𝙻𝚘𝚐𝚘🍧.ᩦ୭✧ࣶᭂ`)
const response = await fetch(`${zerosite}/api/ephoto/retro?texto=${encodeURIComponent(txt1)}&texto2=${encodeURIComponent(txt2)}&texto3=${encodeURIComponent(txt3)}&apikey=${API_KEY_ZEROTWO}`)
if (!response.ok) throw new Error("Erro ao acessar a API.")
const buffer = await response.arrayBuffer()
await zerotwo.sendMessage(from, { image: Buffer.from(buffer) }, { quoted: selolucas })
} catch (e) {
console.log(e)
reply("Erro ao criar sua logo! Tente novamente mais tarde.")
}
break

//=============(LOGOS DE 2 TEXTOS)=============\\

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: rgtinder
└─────────────────────────────────────────────────┘
*/
case 'rgtinder':
try {
ABC = await fetchJson(`${zerosite}/tinder/login?usu=${sender}&${q && !isQuotedImage ? `rg=${q}&` : ``}apikey=`+API_KEY_ZEROTWO)
try {
data = await fetchJson(`${zerosite}/tinder/perfil?usu=${sender}&apikey=`+API_KEY_ZEROTWO)
} catch { return reply("Erro ao tentar acessar o registro") }
fini = data.nome != 0 && data.idade != 0 && data.gene != 0 && data.sexualidade != 0 && data.filtro != 0 && data.bio != 0 && data.foto == 0
if(fini && isQuotedImage) {
try {
boij = isQuotedImage ? JSON.parse(JSON.stringify(selolucas).replace('quotedM','m')).message.extendedTextMessage.contextInfo.message.imageMessage : info.message.imageMessage
owgi = await getFileBuffer(boij, 'image')
img = await upload(owgi)
BCD = await fetchJson(`${zerosite}/tinder/login?usu=${sender}&rg=${img}&apikey=`+API_KEY_ZEROTWO)
return reply(resptinder(BCD.message))
} catch { return reply("Erro ao salvar a imagem... Tente novamente") }
}
reply(resptinder(ABC.message))
} catch(e) {
console.log(e)
reply("Erro")
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: rgzerocity
└─────────────────────────────────────────────────┘
*/
case 'rgzerocity':
if(!isZeroCity) return reply(enviar.rpg.ativar)
if(isYouInZeroCity(sender)) return reply(enviar.rpg.existrg)
if(contar(q, `/`) != 1) return reply(`Retorne após o comando o nome e a cidade que você se registrar, ex:
${prefix+command} John/Rio dos ladrôes`)
var [a, b] = q.replace(`/ `, `/`).replace(` /`, `/`).replace(` / `, `/`).split(`/`)
if(!existCity(b)) return reply(enviar.rpg.notexistcity.replace(`#city#`, b))
if(limitCity(b)) return reply(enviar.rpg.citylimit)
registrarUsuInZeroCity(sender, a, b)
try {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
const profilePicUrl = await zerotwo.profilePictureUrl(`${sender.split('@')[0]}@c.us`, 'image')
const response = await axios.get(profilePicUrl, {
responseType: 'arraybuffer',
headers: {
'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3'
}
})
if (response.status === 200) {
const buffer = Buffer.from(response.data, 'binary')
ppimg = await upload(buffer)
} else {
throw new Error(`Erro ao obter a imagem: ${response.status}`)
}
} catch (e) {
console.log("Erro ao obter a imagem de perfil:", e.message)
ppimg = semfoto
}
img = zerosite+`/api/canvas/jxr/welcome?nome=${encodeURI(a)}&guilda=${encodeURI("Zero City")}&perfil=https://telegra.ph/file/8599989096be411a4a72b.jpg&membro=${totalUserZeroCity.length}&avatar=${ppimg}&fundo=${Number(sendHours("HH")) >= 6 && Number(sendHours("HH")) < 18 ? `https://telegra.ph/file/82bdf76492757e8dac17a.jpg` : `https://telegra.ph/file/14397844299a8fa11d4a9.jpg`}`
txt = enviar.rpg.welcome.replace(`#usu#`, sender.split("@")[0])
mencionarIMG(txt, img, selolucas)
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: rmtinder
└─────────────────────────────────────────────────┘
*/
case 'rmtinder':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(enviar.msg.modobz)
if(command == 'rmtinder') {
if(!isOwner) return reply(enviar.msg.donosmt)
if(!q && !menc_os2) return reply("Retorne após o comando o número ou @ do usuário que você quer deletar do tinder")
deletar = identArroba(q)
} else { deletar = sender }
try {
ABC = await fetchJson(`${zerosite}/tinder/delete?usu=${deletar}&apikey=`+API_KEY_ZEROTWO)
reply(resptinder(ABC.message))
} catch { reply("Erro") }
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: royal
└─────────────────────────────────────────────────┘
*/
case 'royal':
try {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
//Canal: https://whatsapp.com/channel/0029Va6riekH5JLwLUFI7P2B
const textin = args.join(" ")
if (!textin) return reply("KD o texto?")
reply(`ৎ❥̤֟٭ۣۜ𝙶𝚎𝚛𝚊𝚗𝚍𝚘 𝚂𝚞𝚊 𝙻𝚘𝚐𝚘🍧.ᩦ୭✧ࣶᭂ`)
const response = await fetch(`${zerosite}/api/ephoto/${command}?texto=${encodeURIComponent(textin)}&apikey=${API_KEY_ZEROTWO}`)
if (!response.ok) throw new Error("Erro ao acessar a API.")
const buffer = await response.arrayBuffer()
await zerotwo.sendMessage(from, { image: Buffer.from(buffer) }, { quoted: selolucas })
} catch (e) {
console.log(e)
reply("Erro ao criar sua logo! Tente novamente mais tarde.")
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: s
└─────────────────────────────────────────────────┘
*/
case 's':
setTimeout(() => {reagir(from, "✅")}, 300)
//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
var RSM = info.message?.extendedTextMessage?.contextInfo?.quotedMessage
var boij2 = RSM?.imageMessage || info.message?.imageMessage || RSM?.viewOnceMessageV2?.message?.imageMessage || info.message?.viewOnceMessageV2?.message?.imageMessage || info.message?.viewOnceMessage?.message?.imageMessage || RSM?.viewOnceMessage?.message?.imageMessage
var boij = RSM?.videoMessage || info.message?.videoMessage || RSM?.viewOnceMessageV2?.message?.videoMessage || info.message?.viewOnceMessageV2?.message?.videoMessage || info.message?.viewOnceMessage?.message?.videoMessage || RSM?.viewOnceMessage?.message?.videoMessage
if(boij2){
var pack = permuteFigPackName(`❪👤𝚄𝚜𝚞á𝚛𝚒𝚘 (𝚊)ฺ࣭࣪͘ꕸ▸
❪🤖𝙱𝚘𝚝ฺ࣭࣪͘ꕸ▸
❪👑𝙳𝚘𝚗𝚘ฺ࣭࣪͘ꕸ▸
❪🌐𝚂𝚒𝚝𝚎ฺ࣭࣪͘ꕸ▸`)
var author2 = permuteFigAuthorName(`${pushname} ${NomeDoBot} ${NickDono} ${zerosite}`)
reply(`❪∘̥⃟⸽⃟𝙲𝚘𝚗𝚟𝚎𝚛𝚝𝚎𝚗𝚍𝚘 𝙴𝚖 𝙵𝚒𝚐𝚞𝚛𝚒𝚗𝚑𝚊∘̥⃟৴▸`)
owgi = await getFileBuffer(boij2, 'image')
let encmediaa = await sendImageAsSticker2(zerotwo, from, owgi, info, { packname:pack, author:author2})
await DLT_FL(encmediaa)
} else if(boij && boij.seconds < 11){
var pack = permuteFigPackName(`❪👤𝚄𝚜𝚞á𝚛𝚒𝚘 (𝚊)ฺ࣭࣪͘ꕸ▸
❪🤖𝙱𝚘𝚝ฺ࣭࣪͘ꕸ▸
❪👑𝙳𝚘𝚗𝚘ฺ࣭࣪͘ꕸ▸
❪🌐𝚂𝚒𝚝𝚎ฺ࣭࣪͘ꕸ▸`)
var author2 = permuteFigAuthorName(`${pushname} ${NomeDoBot} ${NickDono} ${zerosite}`)
reply(`❪∘̥⃟⸽⃟𝙲𝚘𝚗𝚟𝚎𝚛𝚝𝚎𝚗𝚍𝚘 𝙴𝚖 𝙵𝚒𝚐𝚞𝚛𝚒𝚗𝚑𝚊∘̥⃟৴▸`)
owgi = await getFileBuffer(boij, 'video')
let encmedia = await sendVideoAsSticker2(zerotwo, from, owgi, info, { packname:pack, author:author2})
await DLT_FL(encmedia)
} else {
return reply(`Marque uma imagem ou vídeo de até 10 segundos com o comando ${prefix+command}`)
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: salvarcases2
└─────────────────────────────────────────────────┘
*/
case 'salvarcases2':
if (!isOwner) return reply(enviar.msg.donosmt)
reply("🔎 Buscando e salvando cases...")
try {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
//Canal: https://whatsapp.com/channel/0029Va6riekH5JLwLUFI7P2B
function getAllCases() {
const fs = require("fs")
const path = "./index.js"
try {
const data = fs.readFileSync(path, "utf8")
const regex = /((case\s+['"]([^'"]+)['"]:[\s\S]*?))(?=case\s+['"]|$)/g
let cases = {}
let match
const patterns = [
/\$\{\s*zerosite\s*\}/,
/\bcase\s+['"]zerosite['"]/,
/\bcase\s+['"]zerolink['"]/,
/\bzerosite\/[\w-]+/,
/\bzerosite\b/
]
while ((match = regex.exec(data)) !== null) {
const fullCaseBlock = match[1].trim()
const caseName = match[3]
const usesZerosite = patterns.some(pattern => pattern.test(fullCaseBlock))
if (usesZerosite) {
cases[caseName] = fullCaseBlock
console.log("Case encontrado:", caseName, "Usa zerosite:", usesZerosite)
}
}
return cases
} catch (e) {
console.log("[GETALLCASES] Erro ao obter cases:", e)
return null
}
}
const casesBot = getAllCases()
if (!casesBot || Object.keys(casesBot).length === 0) {
return reply("⚠️ Nenhuma case utilizando a API '${zerosite}' foi encontrada.")
}
const fs = require("fs")
const filePath = "./database/comandos/cases_zerosite.js"
const currentDate = new Date()
const dateFormatted = currentDate.toLocaleDateString('pt-BR', {
year: 'numeric', month: 'long', day: 'numeric'
})
const timeFormatted = currentDate.toLocaleTimeString('pt-BR', {
hour: '2-digit', minute: '2-digit', second: '2-digit'
})
let fileContent = `/* 
█████████████████████████████████████████████
🔥 **Cases que utilizam a API '${zerosite}'** 🔥
█████████████████████████████████████████████

📅 Data de Geração: ${dateFormatted}
⏰ Hora: ${timeFormatted}
📂 Arquivo gerado automaticamente pelo bot.
*/\n\n`
const sortedCases = Object.keys(casesBot).sort()
sortedCases.forEach((caseName, index) => {
fileContent += `/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: ${caseName}
└─────────────────────────────────────────────────┘
*/\n`
fileContent += `${casesBot[caseName]}\n\n`
if (index !== sortedCases.length - 1) {
fileContent += `/* --------------------------------------------- */\n\n`
}
})
fs.writeFileSync(filePath, fileContent)
reply(`✅ ${sortedCases.length} cases que usam a API "${zerosite}" foram salvas no arquivo *cases_zerosite.js*! 📂`)
} catch (e) {
console.log("[SALVARCASES] Erro:", e)
reply("❌ Erro ao buscar ou salvar as cases. Tente novamente.")
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: screenshots
└─────────────────────────────────────────────────┘
*/
case 'screenshots':
if(!q) return reply("Retorne após o comando o link do site que você deseja capturar")
try {
zerotwo.sendMessage(from, {image: {url: `${zerosite}/api/ssweb?link=${q}&apikey=`+API_KEY_ZEROTWO}}, {quoted: selolucas})
} catch (e) {
return reply("Erro..")
}
break

//========(SORTEIO-VOTAR-CASES)=========\\

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: search-sticker
└─────────────────────────────────────────────────┘
*/
case 'search-sticker':
setTimeout(() => { reagir(from, `${reassao}`) }, 100)
try {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
//Canal: https://whatsapp.com/channel/0029Va6riekH5JLwLUFI7P2B
if (!q) return reply("Faltando o parâmetro de pesquisa, insira o nome do sticker.")
const response = await fetchJson(`${zerosite}/api/sticker/search?query=${q}&apikey=${API_KEY_ZEROTWO}`)
if (!response || !response.resultado || response.resultado.status !== 200) {
return reply("Não foi possível encontrar os stickers. Tente novamente com outra pesquisa.")
}
const { author, title, sticker_url } = response.resultado
const totalStickers = sticker_url.length
await zerotwo.sendMessage(from, { text: `❯❯ *PACOTE DE STICKERS* ❮❮\n` + `❯ *Autor:* ${author}\n` + `❯ *Título:* ${title}\n` + `❯ *Pesquisa:* ${q}\n` + `❯ *Total de Stickers Encontrados:* ${totalStickers}\n\n` + `⚠️ Os stickers serão enviados no privado.` }, { quoted: info })
for (const url of sticker_url) {
await sendStickerFromUrl2(sender, url)
}
await zerotwo.sendMessage(sender, { text: `🔄 Envio concluído! Foram enviados ${totalStickers} stickers baseados na sua pesquisa.\n\n` + `Caso queira mais stickers, digite o comando novamente.` })
} catch (e) {
console.error(e)
return reply("Erro ao processar a solicitação. Tente novamente mais tarde.")
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: search-wallpaper
└─────────────────────────────────────────────────┘
*/
case 'search-wallpaper':
setTimeout(() => { reagir(from, `${reassao}`) }, 100)
try {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
//Canal: https://whatsapp.com/channel/0029Va6riekH5JLwLUFI7P2B
if (!q) return reply("Faltando a consulta de wallpaper, insira a pesquisa.")
let attempts = 0
let randomWallpapers = []
do {
const response = await fetchJson(`${zerosite}/api/search/wallpaper?query=${q}&apikey=${API_KEY_ZEROTWO}`)
if (!response.status || !response.resultado.length) {
return reply("Não foi possível obter os wallpapers. Tente novamente.")
}
randomWallpapers = response.resultado
.filter(url => !url.endsWith('.svg'))
.sort(() => Math.random() - 0.5)
.slice(0, 3)
attempts++
} while (randomWallpapers.length < 3 && attempts < 5)
if (randomWallpapers.length < 3) {
return reply("Não foi possível encontrar wallpapers suficientes. Tente novamente mais tarde.")
}
for (const imageUrl of randomWallpapers) {
if (imageUrl.endsWith('.gif')) {
await zerotwo.sendMessage(from, { video: { url: imageUrl }, caption: `❯❯ ZERO TWO - WALLPAPERS ❮❮\n❯ *Nome:* ${q} GIF\n❯ *Extensão:* .gif`, mimetype: "video/mpeg", gifPlayback: true }, { quoted: selolucas }).catch(e => {
console.log("Erro ao enviar o GIF:", e)
})
} else {
await zerotwo.sendMessage(from, { image: { url: imageUrl }, caption: `❯❯ ZERO TWO - WALLPAPERS ❮❮\n❯ *Nome:* ${q}\n❯ *Extensão:* ${imageUrl.split('.').pop()}` }, { quoted: selolucas }).catch(e => {
console.log("Erro ao enviar a imagem:", e)
})
}
}
await zerotwo.sendMessage(from, { text: "🔄 Caso queira mais wallpapers, digite o comando novamente." }, { quoted: selolucas })
} catch (e) {
console.log(e)
return reply("Erro ao processar a solicitação.")
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: sfundo
└─────────────────────────────────────────────────┘
*/
case 'sfundo': //By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
//Canal: https://whatsapp.com/channel/0029Va6riekH5JLwLUFI7P2B
setTimeout(() => { reagir(from, react2); }, 300)
if ((isMedia && !info.message.videoMessage) || isQuotedImage) {
let post
if (isQuotedImage) {
if (info.message.extendedTextMessage && info.message.extendedTextMessage.contextInfo) {
if (info.message.extendedTextMessage.contextInfo.quotedMessage && info.message.extendedTextMessage.contextInfo.quotedMessage.imageMessage) {
post = info.message.extendedTextMessage.contextInfo.quotedMessage.imageMessage
} else {
console.log('contextInfo não contém uma imagem válida')
return reply('😈 _Marque uma imagem válida para remover o fundo_')
}
} else {
console.log('Nenhum contextInfo encontrado ou contexto inválido')
return reply('😈 _Marque uma imagem válida para remover o fundo_')
}
} else {
post = info.message.imageMessage
}
reply('😈 _Processando sua imagem! Aguarde..._')
try {
const imagem = await downloadContentFromMessage(post, 'image')
let imageBuffer = Buffer.from([])
for await (const chunk of imagem) {
imageBuffer = Buffer.concat([imageBuffer, chunk])
}
const uploadUrl = await upload(imageBuffer)
const apiUrl = `${zerosite}/api/ia/removebg?url=${uploadUrl}&apikey=${API_KEY_ZEROTWO}`
const removeBgResponse = await axios.get(apiUrl, { responseType: 'arraybuffer' })
if (removeBgResponse.status === 200 && removeBgResponse.data) {
console.log(chalk.green(`[SUCESSO] Imagem sem fundo recebida da API.`))
const imgBuffer = Buffer.from(removeBgResponse.data)
const tempFolder = path.resolve(__dirname, 'temp')
const outputPath = path.join(tempFolder, 'resultado-removebg.png')
if (!fs.existsSync(tempFolder)) {
console.log(chalk.yellow(`[INFO] A pasta "temp" não existe. Criando...`))
fs.mkdirSync(tempFolder, { recursive: true })
console.log(chalk.green(`[SUCESSO] Pasta "temp" criada em: ${tempFolder}`))
}
fs.writeFileSync(outputPath, imgBuffer)
console.log(chalk.green(`[INFO] Imagem sem fundo salva em: ${outputPath}`))
await renameContextSticker2(`${NomeDoBot}`, pushname, fs.readFileSync(outputPath), selolucas)
console.log(chalk.green(`[SUCESSO] Imagem enviada com sucesso.`))
fs.unlinkSync(outputPath)
console.log(chalk.green(`[SUCESSO] Arquivos temporários removidos.`))
} else {
throw new Error(`API retornou status ${removeBgResponse.status}. Não foi possível remover o fundo.`)
}
} catch (e) {
console.error(chalk.red(`[ERRO] Falha ao processar a imagem: ${e.message}`))
reply(`Ocorreu um erro ao remover o fundo da imagem. Tente novamente mais tarde.\nErro: ${e.message}`)
}
} else {
console.log(chalk.yellow('[AVISO] Nenhuma imagem válida enviada.'))
return reply(`Envie apenas uma imagem, por favor.`)
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: sfundo2
└─────────────────────────────────────────────────┘
*/
case 'sfundo2': //By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
//Canal: https://whatsapp.com/channel/0029Va6riekH5JLwLUFI7P2B
setTimeout(() => { reagir(from, react2); }, 300)
if ((isMedia && !info.message.videoMessage) || isQuotedImage) {
let post
if (isQuotedImage) {
if (info.message.extendedTextMessage && info.message.extendedTextMessage.contextInfo) {
if (info.message.extendedTextMessage.contextInfo.quotedMessage && info.message.extendedTextMessage.contextInfo.quotedMessage.imageMessage) {
post = info.message.extendedTextMessage.contextInfo.quotedMessage.imageMessage
} else {
console.log('contextInfo não contém uma imagem válida')
return reply('😈 _Marque uma imagem válida para remover o fundo_')
}
} else {
console.log('Nenhum contextInfo encontrado ou contexto inválido')
return reply('😈 _Marque uma imagem válida para remover o fundo_')
}
} else {
post = info.message.imageMessage
}
reply('😈 _Processando sua imagem! Aguarde..._')
try {
const imagem = await downloadContentFromMessage(post, 'image')
let imageBuffer = Buffer.from([])
for await (const chunk of imagem) {
imageBuffer = Buffer.concat([imageBuffer, chunk])
}
const uploadUrl = await upload(imageBuffer)
const apiUrl = `${zerosite}/api/ia/removebg?url=${uploadUrl}&apikey=${API_KEY_ZEROTWO}`
const removeBgResponse = await axios.get(apiUrl, { responseType: 'arraybuffer' })
if (removeBgResponse.status === 200 && removeBgResponse.data) {
console.log(chalk.green(`[SUCESSO] Imagem sem fundo recebida da API.`))
const imgBuffer = Buffer.from(removeBgResponse.data)
const tempFolder = path.resolve(__dirname, 'temp')
const outputPath = path.join(tempFolder, 'resultado-removebg.png')
if (!fs.existsSync(tempFolder)) {
console.log(chalk.yellow(`[INFO] A pasta "temp" não existe. Criando...`))
fs.mkdirSync(tempFolder, { recursive: true })
console.log(chalk.green(`[SUCESSO] Pasta "temp" criada em: ${tempFolder}`))
}
fs.writeFileSync(outputPath, imgBuffer)
console.log(chalk.green(`[INFO] Imagem sem fundo salva em: ${outputPath}`))
const imgData = fs.readFileSync(outputPath)
await zerotwo.sendMessage(from, {image: imgData, caption: "Aqui está sua imagem sem fundo!"}, { quoted: selolucas })
console.log(chalk.green(`[SUCESSO] Imagem enviada com sucesso.`))
fs.unlinkSync(outputPath)
console.log(chalk.green(`[SUCESSO] Arquivos temporários removidos.`))
} else {
throw new Error(`API retornou status ${removeBgResponse.status}. Não foi possível remover o fundo.`)
}
} catch (e) {
console.error(chalk.red(`[ERRO] Falha ao processar a imagem: ${e.message}`))
reply(`Ocorreu um erro ao remover o fundo da imagem. Tente novamente mais tarde.\nErro: ${e.message}`)
}
} else {
console.log(chalk.yellow('[AVISO] Nenhuma imagem válida enviada.'))
return reply(`Envie apenas uma imagem, por favor.`)
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: shazam
└─────────────────────────────────────────────────┘
*/
case 'shazam': {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
if (!isQuotedAudio && !isQuotedVideo) return reply('⚠️ Envie o áudio ou vídeo para eu detectar o nome da música!')
let mediaBuffer, mime, extension
let quotedMessage = info.message.extendedTextMessage.contextInfo.quotedMessage
if (isQuotedAudio && quotedMessage && quotedMessage.audioMessage) {
console.log('Áudio detectado')
mediaBuffer = await getFileBuffer(quotedMessage.audioMessage, 'audio')
mime = quotedMessage.audioMessage.mimetype
extension = mime.split('/')[1]
} else if (isQuotedVideo && quotedMessage && quotedMessage.videoMessage) {
console.log('Vídeo detectado')
mediaBuffer = await getFileBuffer(quotedMessage.videoMessage, 'video')
mime = quotedMessage.videoMessage.mimetype
extension = mime.split('/')[1]
} else {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
return reply('⚠️ Envie o áudio ou vídeo para eu detectar o nome da música!')
}
if (!mediaBuffer) {
return reply('⚠️ Não foi possível obter o buffer da mídia!')
}
console.log('Mídia recebida, salvando arquivo')
fs.writeFileSync('./armor/assets/' + sender + '.' + extension, mediaBuffer)
let base64 = fs.readFileSync('./armor/assets/' + sender + '.' + extension, { encoding: "base64" })
try {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
console.log('Enviando para arcloud para detecção')
let hasil = await arcloud(base64)
if (!hasil) {
return reply('Desculpe, não consegui identificar a música. Por favor, tente novamente!️')
}
console.log('Resposta do arcloud:', hasil)
ABC = await fetchJson(zerosite + `/api/ytsrc?q=${hasil[0].titulo}&apikey=` + API_KEY_ZEROTWO)
} catch (e) {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
console.log('Erro ao identificar a música:', e.message)
return reply('Desculpe, não consegui identificar a música. Por favor, tente novamente!️')
}
reagir(from, `⚡`)
data = ABC.resultado[0]
let txt = `🎙️❒ 𝚃í𝚝𝚞𝚕𝚘: ${data.title}
⏰❒ 𝚃𝚎𝚖𝚙𝚘: ${data.timestamp || "indefinido"}
📹❒ 𝙿𝚘𝚜𝚝𝚊𝚍𝚘: ${data.ago || "indefinido"}
🗞️❒ 𝙳𝚎𝚜𝚌𝚛𝚒çã𝚘: ${data.description || "indefinida"}`
sendUrlText(from, txt, `⚡ SHAZAM - ${data.title}`, `${largeNumber(data.views) || "indefinidas"} visualizações`, data.thumbnail, data.url, selolucas)
sendAudio(from, zerosite + `/api/dl/ytaudio?url=${data.url}&apikey=` + API_KEY_ZEROTWO, 'audio/mp4')
console.log('Limpando arquivos temporários')
DLT_FL('./armor/assets/' + sender + '.' + extension)
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: shazamapi
└─────────────────────────────────────────────────┘
*/
case 'shazamapi': { // By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
if (!isQuotedAudio && !isQuotedVideo) 
return reply('⚠️ Envie um áudio ou vídeo para identificar o nome da música de até 5MB')
let mediaBuffer, mime
const quotedMessage = info.message.extendedTextMessage.contextInfo.quotedMessage
console.log('🔍 Verificando mídia citada...')
if (isQuotedAudio && quotedMessage?.audioMessage) {
console.log('Áudio detectado.')
mediaBuffer = await getFileBuffer(quotedMessage.audioMessage, 'audio')
mime = quotedMessage.audioMessage.mimetype
} else if (isQuotedVideo && quotedMessage?.videoMessage) {
console.log('Vídeo detectado.')
mediaBuffer = await getFileBuffer(quotedMessage.videoMessage, 'video')
mime = quotedMessage.videoMessage.mimetype
} else {
console.log('⚠️ Mídia inválida ou não citada corretamente.')
return reply('⚠️ Envie um áudio ou vídeo válido!')
}
if (!mediaBuffer) return reply('⚠️ Não foi possível obter o buffer da mídia!')
try {
console.log(`Tipo de mídia: ${mime}`)
console.log(`Buffer de mídia tamanho: ${mediaBuffer.length} bytes`)
if (mediaBuffer.length > 1048576 * 5) {
console.log('⚠️ Arquivo excede o limite permitido.')
return reply('⚠️ O arquivo excede o tamanho máximo permitido de 5 MB! Envie outro arquivo de até 5MB.')
}
const fs = require('fs')
const ffmpeg = require('fluent-ffmpeg')
const inputPath = './temp/temp_input'
const outputPath = './temp/temp_output.mp3'
const isAudio = mime.startsWith('audio')
const extension = isAudio ? '.mp3' : '.mp4'
console.log('🎵 Salvando mídia temporariamente...')
await fs.promises.writeFile(inputPath + extension, mediaBuffer)
console.log(`🎵 Convertendo ${isAudio ? 'áudio' : 'vídeo'} para formato MP3...`)
await new Promise((resolve, reject) => {
ffmpeg(inputPath + extension)
.output(outputPath)
.audioCodec('libmp3lame')
.duration(30)
.on('end', resolve)
.on('error', reject)
.run()
})
mediaBuffer = await fs.promises.readFile(outputPath)
fs.unlinkSync(inputPath + extension)
fs.unlinkSync(outputPath)
console.log(`🎵 Mídia convertida e processada com sucesso.`)
const mediaBlob = new Blob([mediaBuffer], { type: 'audio/mpeg' })
const formData = new FormData()
formData.append('media', mediaBlob, 'media')
formData.append('apikey', API_KEY_ZEROTWO)
console.log('FormData preparado para envio...')
const response = await axios.post(`${zerosite}/api/shazam`, formData, {
headers: {
'Content-Type': 'multipart/form-data',
},
})
console.log('Resposta da API SHAZAM recebida...')
const data = response.data
if (!data || data.error) {
console.error('Erro na API SHAZAM:', data.error || 'Resposta inválida')
return reply('⚠️ Não foi possível identificar a música. Tente novamente!')
}
console.log('Dados recebidos da API SHAZAM:', data)
const { título, duração, postado, descrição, visualizações, thumbnail, youtubeUrl, audioUrl } = data;
const txt = `🎙️❒ 𝚃í𝚝𝚞𝚕𝚘: ${título}
⏰❒ 𝚃𝚎𝚖𝚙𝚘: ${duração || 'indefinido'}
📹❒ 𝙿𝚘𝚜𝚝𝚊𝚍𝚘: ${postado || 'indefinido'}
🗞️❒ 𝙳𝚎𝚜𝚌𝚛𝚊çã𝚘: ${descrição || 'indefinida'}`
sendUrlText(from, txt, `⚡ SHAZAM - ${título}`, `${largeNumber(visualizações) || 'Indefinidas'} visualizações`, thumbnail, youtubeUrl, selolucas)
sendAudio(from, audioUrl, 'audio/mpeg')
} catch (e) {
console.error('Erro ao processar a identificação:', e.message)
return reply('⚠️ Ocorreu um erro ao processar sua solicitação. Por favor, tente novamente!')
}
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: signo
└─────────────────────────────────────────────────┘
*/
case 'signo':
if(!q) return reply(`Digite seu signo, exemplo: ${prefix+command} virgem`)
try {
ABC = await fetchJson(`https://api.bronxyshost.com.br/api-bronxys/horoscopo?signo=${q}&apikey=`+API_KEY_ALEATORY)
txt = `${"=".repeat(20)}
🍄 *Signo:* ${q}
${"=".repeat(20)}

${ABC.title + "\n" + ABC.body}`
sendUrlText(from, txt, ``, ABC.img, NomeDoBot, ``, zerosite, selolucas)
} catch(e) {
console.log(e)
return reply("Erro..")
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: soundcloud
└─────────────────────────────────────────────────┘
*/
case 'soundcloud':
try {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
//Canal: https://whatsapp.com/channel/0029Va6riekH5JLwLUFI7P2B
if (!q) return reply("Por favor, forneça uma consulta válida para realizar a busca no SoundCloud.")
await reagir(from, '⏳')
await reply("Por favor, aguarde enquanto realizo a busca...")
const apiUrl = `${zerosite}/api/soundcloud/search?query=${encodeURIComponent(q)}&apikey=${API_KEY_ZEROTWO}`
const response = await axios.get(apiUrl, { timeout: 50000 })
if (!response.data.status || !Array.isArray(response.data.resultado) || response.data.resultado.length === 0) {
return reply("Nenhum resultado encontrado para a pesquisa.")
}
const results = response.data.resultado.slice(0, 5)
for (let i = 0; i < results.length; i++) {
const item = results[i]
const createdAt = item.created_at ? new Date(item.created_at).toLocaleString() : 'Não disponível'
const caption = `
❯ *Título:* ${item.title || 'Não disponível'}
❯ *Autor:* ${item.user ? item.user.username : 'Não disponível'}
❯ *Likes:* ${item.likes_count || 'Não disponível'}
❯ *Reposts:* ${item.reposts_count || 'Não disponível'}
❯ *Tag:* ${Array.isArray(item.tag_list) ? item.tag_list.join(', ') : 'Sem tags'}
❯ *Duração:* ${item.duration ? (item.duration / 1000) + 's' : 'Não disponível'}
❯ *Link:* ${item.permalink_url || 'Não disponível'}
❯ *URL da arte:* ${item.artwork_url || 'Não disponível'}
❯ *Data de Criação:* ${createdAt}
❯ *Comentários:* ${item.comment_count !== undefined ? item.comment_count : 'Não disponível'}
❯ *ID do Item:* ${item.id || 'Não disponível'}
❯ *Compartilhamentos:* ${item.shared_count || 'Não disponível'}
❯ *Favoritos:* ${item.favorite_count || 'Não disponível'}
❯ *Descrição:* ${item.description || 'Não disponível'}
`
const imageUrl = item.artwork_url ? item.artwork_url : logoslink.logo
await zerotwo.sendMessage(from, { image: { url: imageUrl }, caption: caption }, { quoted: info })
}
} catch (e) {
console.log("Erro ao Buscar Resultados do SoundCloud:", e)
return reply("Houve um problema ao realizar a busca, tente novamente.")
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: soundcloud_detalhes
└─────────────────────────────────────────────────┘
*/
case 'soundcloud_detalhes':
try {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
//Canal: https://whatsapp.com/channel/0029Va6riekH5JLwLUFI7P2B
if (!q) return reply("Por favor, forneça uma URL válida do SoundCloud para buscar os detalhes da faixa.")
await reagir(from, '⏳')
await reply("Por favor, aguarde enquanto recupero os detalhes da faixa...")
const apiUrl = `${zerosite}/api/soundcloud/track-details?url=${encodeURIComponent(q)}&apikey=${API_KEY_ZEROTWO}`
const response = await axios.get(apiUrl, { timeout: 50000 })
if (!response.data.status || !response.data.resultado) {
return reply("Não foi possível encontrar os detalhes da faixa. Verifique a URL e tente novamente.")
}
const item = response.data.resultado
const user = item.user || {}
const createdAt = item.created_at ? new Date(item.created_at).toLocaleString() : 'Não disponível'
const lastModified = item.last_modified ? new Date(item.last_modified).toLocaleString() : 'Não disponível'
const visuals = Array.isArray(user.visuals) ? user.visuals.map(v => v.visual_url).join(', ') : 'Não disponível'
const caption = `
❯ *Título:* ${item.title || 'Não disponível'}
❯ *Autor:* ${user.username || 'Não disponível'}
❯ *Link do Autor:* ${user.permalink_url || 'Não disponível'}
❯ *Descrição:* ${item.description || 'Não disponível'}
❯ *Likes:* ${item.likes_count || 'Não disponível'}
❯ *Reposts:* ${item.reposts_count || 'Não disponível'}
❯ *Comentários:* ${item.comment_count || 'Não disponível'}
❯ *Duração:* ${item.duration ? (item.duration / 1000) + 's' : 'Não disponível'}
❯ *Gênero:* ${item.genre || 'Não disponível'}
❯ *Download disponível:* ${item.downloadable ? 'Sim' : 'Não'}
❯ *Comentários Permitidos:* ${item.commentable ? 'Sim' : 'Não'}
❯ *Data de Criação:* ${createdAt}
❯ *Última Modificação:* ${lastModified}
❯ *Link da Faixa:* ${item.permalink_url || 'Não disponível'}
❯ *Link da Arte:* ${item.artwork_url || 'Não disponível'}
❯ *Waveform URL:* ${item.waveform_url || 'Não disponível'}
❯ *ID da Faixa:* ${item.id || 'Não disponível'}
❯ *Estado da Faixa:* ${item.state || 'Não disponível'}
❯ *Monetização:* ${item.monetization_model || 'Não disponível'}
❯ *Modelo de Licenciamento:* ${item.license || 'Não disponível'}
❯ *Compartilhamento:* ${item.sharing || 'Não disponível'}
❯ *URL da Faixa:* ${item.uri || 'Não disponível'}
❯ *ID do Usuário:* ${user.id || 'Não disponível'}
❯ *Nome do Usuário:* ${user.username || 'Não disponível'}
❯ *Descrição do Usuário:* ${user.description || 'Não disponível'}
❯ *Link do Usuário:* ${user.permalink_url || 'Não disponível'}
❯ *Imagem do Usuário:* ${user.avatar_url || 'Não disponível'}
❯ *Seguidores do Usuário:* ${user.followers_count || 'Não disponível'}
❯ *Seguindo do Usuário:* ${user.followings_count || 'Não disponível'}
❯ *Primeiro Nome do Usuário:* ${user.first_name || 'Não disponível'}
❯ *Último Nome do Usuário:* ${user.last_name || 'Não disponível'}
❯ *Contagem de Playlist do Usuário:* ${user.playlist_count || 'Não disponível'}
❯ *Contagem de Faixas do Usuário:* ${user.track_count || 'Não disponível'}
❯ *Visuals do Usuário:* ${visuals}
❯ *Avatar do Usuário:* ${user.avatar_url || 'Não disponível'}
❯ *Criador Subscrição:* ${user.creator_subscription ? user.creator_subscription.product.id : 'Não disponível'}
❯ *Contagem de Likes do Usuário:* ${user.likes_count || 'Não disponível'}
❯ *Contagem de Reposts do Usuário:* ${user.reposts_count || 'Não disponível'}
`
await zerotwo.sendMessage(from, { image: { url: item.artwork_url }, caption: caption }, { quoted: info })
} catch (e) {
console.log("Erro ao buscar detalhes da faixa do SoundCloud:", e)
return reply("Houve um problema ao buscar os detalhes da faixa, tente novamente.")
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: soundcloud_dl
└─────────────────────────────────────────────────┘
*/
case 'soundcloud_dl':
try {// By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
// Canal: https://whatsapp.com/channel/0029Va6riekH5JLwLUFI7P2B
if (!q) return reply("Por favor, forneça uma URL válida do SoundCloud para buscar os detalhes da faixa e o áudio.")
await reagir(from, '⏳')
await reply("Por favor, aguarde enquanto recupero os detalhes da faixa...")
const trackApiUrl = `${zerosite}/api/soundcloud/track-details?url=${encodeURIComponent(q)}&apikey=${API_KEY_ZEROTWO}`
const trackResponse = await axios.get(trackApiUrl, { timeout: 50000 })
if (!trackResponse.data.status || !trackResponse.data.resultado) {
return reply("Não foi possível encontrar os detalhes da faixa. Verifique a URL e tente novamente.")
}
const trackItem = trackResponse.data.resultado
const user = trackItem.user || {}
const caption = `
❯ *Título:* ${trackItem.title || 'Não disponível'}
❯ *Autor:* ${user.username || 'Não disponível'}
❯ *Likes:* ${trackItem.likes_count || 'Não disponível'}
❯ *Link da Faixa:* ${trackItem.permalink_url || 'Não disponível'}
`
await zerotwo.sendMessage(from, { image: { url: trackItem.artwork_url }, caption: caption }, { quoted: info })
await reply("Agora estou enviando o áudio da faixa. Por favor, aguarde um momento...")
const audioApiUrl = `${zerosite}/api/soundcloud?url=${encodeURIComponent(q)}&apikey=${API_KEY_ZEROTWO}`
const response = await axios.get(audioApiUrl, { responseType: 'arraybuffer' })
const audioBuffer = response.data
if (!audioBuffer || audioBuffer.length === 0) {
return reply("Não foi possível baixar o áudio da faixa.")
}
const filePath = `./temp/${trackItem.title}.mp3`
fs.writeFileSync(filePath, audioBuffer)
const convertedFilePath = `./temp/${trackItem.title}-converted.mp3`
const ffmpeg = require('fluent-ffmpeg')
await new Promise((resolve, reject) => {
ffmpeg(filePath)
.audioCodec('libmp3lame')
.audioBitrate('192k')
.audioFrequency(44100)
.on('end', resolve)
.on('error', reject)
.save(convertedFilePath)
})
await zerotwo.sendMessage(from, {audio: fs.readFileSync(convertedFilePath), fileName: `${trackItem.title}.mp3`, mimetype: 'audio/mpeg'}, { quoted: info })
fs.unlinkSync(filePath)
fs.unlinkSync(convertedFilePath)
} catch (e) {
console.log("Erro ao buscar ou enviar detalhes da faixa do SoundCloud:", e)
return reply("Houve um problema ao buscar os detalhes da faixa ou enviar o áudio, tente novamente.")
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: spotify
└─────────────────────────────────────────────────┘
*/
case 'spotify':
if (!q) return reply(`Use: ${prefix + command} nome da música`)
try {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
//Canal: https://whatsapp.com/channel/0029Va6riekH5JLwLUFI7P2B
reagir(from, "🔎")
const searchUrl = `${zerosite}/api/spotify/search?query=${encodeURIComponent(q)}&apikey=${API_KEY_ZEROTWO}`
const searchResult = await fetchJson(searchUrl)
if (!searchResult.resultado || !searchResult.resultado.items || searchResult.resultado.items.length === 0) {
return reply("Nenhuma música encontrada. Tente outro nome.")
}
const track = searchResult.resultado.items[0]
const downloadUrl = `${zerosite}/api/spotify/preview?url=${encodeURIComponent(track.external_urls.spotify)}&apikey=${API_KEY_ZEROTWO}`
const downloadResult = await fetchJson(downloadUrl)
if (!downloadResult.success || !downloadResult.resultado || !downloadResult.resultado.audio) {
return reply("Erro ao baixar a música. Por favor, tente novamente mais tarde.")
}
const details = downloadResult.resultado
const audioUrl = details.audio
const artistNames = track.artists.map(artist => artist.name).join(", ")
const albumImage = track.album.images[0]?.url || 'Imagem não disponível'
const duration = Math.floor(track.duration_ms / 60000) + ":" + Math.floor((track.duration_ms % 60000) / 1000).toString().padStart(2, '0')
const txt = `🎧 𝐒𝐏𝐎𝐓𝐈𝐅𝐘 🎧

❪🎵 𝙼ú𝚜𝚒𝚌𝚊: ${track.name}
❪⏱️ 𝙳𝚞𝚛𝚊çã𝚘: ${duration}
❪👥 𝙰𝚛𝚝𝚒𝚜𝚝𝚊(𝚜): ${artistNames}
❪💽 𝙰𝚕𝚋𝚞𝚖: ${track.album.name}
❪🌟 𝙿𝚘𝚙𝚞𝚕𝚊𝚛𝚒𝚍𝚊𝚍𝚎: ${details.popularidade || 'N/A'}
𖡋ꦿ 𝙻𝚒𝚗𝚔: ${track.external_urls.spotify}
----------------------------------------------
𝙱𝚢 ${NomeDoBot}`
await sendUrlText(from, txt, `Ouça agora ${track.name} em seu aplicativo Spotify 🔥`, `Music • Duração: ${duration}`, albumImage, track.external_urls.spotify, selolucas)
if (audioUrl) {
await sendAudio(from, audioUrl, "audio/mpeg", selolucas)
} else {
reply("Prévia de áudio não disponível.")
}
} catch (e) {
console.log('Error in Spotify command:', e)
return reply("Ocorreu um erro ao processar sua solicitação. Tente novamente.")
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: thdl
└─────────────────────────────────────────────────┘
*/
case 'thdl':
try {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
if (q.length < 5) return reply(`Exemplo: ${prefix+command} o link`)
reply(`❪𝙴𝚗𝚟𝚒𝚊𝚗𝚍𝚘 𝚂𝚎𝚞 𝚅í𝚍𝚎𝚘 𝚘𝚞 𝙸𝚖𝚊𝚐𝚎𝚖ฺ࣭࣪͘ꕸ▸`)
const isSpecificLink = q.includes('https://www.threads.net/')
if (isSpecificLink) {
let threadsResult = await fetchJson(`${zerosite}/api/dl/threads?url=${encodeURIComponent(q)}&apikey=${API_KEY_ZEROTWO}`)
if (threadsResult.status === 200) {
let creator = threadsResult.criador
let imageUrls = threadsResult.resultado.image_urls
let videoUrls = threadsResult.resultado.video_urls
if (imageUrls.length > 0) {
for (let imageUrl of imageUrls) {
await sendImage(from, imageUrl, `❯❯ *Criador*: ${creator}`)
}
}
if (videoUrls.length > 0) {
for (let video of videoUrls) {
let videoUrl = video.download_url
await sendVideo(from, videoUrl, `❯❯ *Criador*: ${creator}`, selolucas)
}
}
return
} else {
return reply(`Não foi possível obter mídias da URL fornecida.`)
}
} else {
return reply(`URL inválida para o comando ${prefix}${command}`)
}
} catch (e) {
console.log(e)
return reply("Erro ao processar o comando.")
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: tiger
└─────────────────────────────────────────────────┘
*/
case 'tiger':
textin = args.join(" ")
if(!textin) return reply("KD o texto ?")
reply(`ৎ❥̤֟٭ۣۜ𝙶𝚎𝚛𝚊𝚗𝚍𝚘 𝚂𝚞𝚊 𝙻𝚘𝚐𝚘🍧.ᩦ୭✧ࣶᭂ`)
bla = await getBuffer(`${zerosite}/api/ephoto/${command}?texto=${textin}&apikey=`+API_KEY_ZEROTWO)
zerotwo.sendMessage(from, {video: bla}, {quoted: selolucas}).catch(e =>{
reply("Erro ao criar sua logo em vídeo! Tente novamente mais tarde.")
})
break

// FIM DAS LOGOS

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: tiktok2
└─────────────────────────────────────────────────┘
*/
case 'tiktok2':
reagir(from, "🎥")
try {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
if (!q.includes("tiktok")) return reply(`${prefix + command} link do Tiktok`)
let ABC = await fetchJson(`${zerosite}/download/tiktok?url=${q}&apikey=` + API_KEY_ZEROTWO)
if (ABC.status !== true) {
return reply(downoff)
}
let videoInfo = ABC.resultado.data
let authorInfo = videoInfo.author
let musicInfo = videoInfo.music_info
let caption = `
❯❯〘 ${authorInfo.nickname} (@${authorInfo.unique_id}) 〙❮❮

〘🆔〙 *ID do Vídeo*: ${videoInfo.id}
〘🌎〙 *Região*: ${videoInfo.region}
〘📅〙 *Criado em*: ${new Date(videoInfo.create_time * 1000).toLocaleString()}
〘🕒〙 *Duração*: ${videoInfo.duration}s
〘▶️〙 *Visualizações*: ${videoInfo.play_count}
〘❤️〙 *Curtidas*: ${videoInfo.digg_count}
〘💬〙 *Comentários*: ${videoInfo.comment_count}
〘🔄〙 *Compartilhamentos*: ${videoInfo.share_count}
〘📥〙 *Downloads*: ${videoInfo.download_count}
〘💾〙 *Salvos*: ${videoInfo.collect_count}
〘📜〙 *Descrição*: ${videoInfo.title}

🎶 *Música do Vídeo*
〘🎶〙 *Título*: ${musicInfo.title}
〘🎤〙 *Autor*: ${musicInfo.author}
〘⏳〙 *Duração*: ${musicInfo.duration}s

❯ BAIXADO POR ${NomeDoBot}
`
await zerotwo.sendMessage(from, { video: { url: videoInfo.play }, caption: caption, mimetype: "video/mp4", }, { quoted: selolucas })
if (videoInfo.music) {
await zerotwo.sendMessage(from, { audio: { url: videoInfo.music }, mimetype: "audio/mpeg" },{ quoted: selolucas })
}
} catch (e) {
return reply(downoff)
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: tiktok3
└─────────────────────────────────────────────────┘
*/
case 'tiktok3':
reagir(from, "🎥")
try {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
if (!q.includes("tiktok")) return reply(`${prefix+command} link do Tiktok`)
let ABC = await fetchJson(`${zerosite}/download/tiktok?url=${q}&apikey=`+API_KEY_ZEROTWO)
if (ABC.status !== true) {
return reply(downoff)
}
reply(`❪𝙴𝚗𝚟𝚒𝚊𝚗𝚍𝚘 𝚂𝚎𝚞 𝚅í𝚍𝚎𝚘ฺ࣭࣪͘ꕸ▸`)
let caption = `
❯❯〘 ${ABC.resultado.author.nickname} (@${ABC.resultado.author.username}) 〙❮❮

〘⏳〙 *Duração*: ${ABC.resultado.duration}s
〘▶️〙 *Visualizações*: ${ABC.resultado.statistic.play_count}
〘❤️〙 *Curtidas*: ${ABC.resultado.statistic.like_count}
〘🔄〙 *Compartilhamentos*: ${ABC.resultado.statistic.share_count}
〘💬〙 *Comentários*: ${ABC.resultado.statistic.comment_count}
〘🎬〙 *Descrição*: ${ABC.resultado.title}

❯ BAIXADO POR ${NomeDoBot}
`
zerotwo.sendMessage(from, { video: { url: ABC.resultado.link }, caption: caption, mimetype: "video/mp4" }, { quoted: selolucas }).catch(e => {
return reply(downon)
})
} catch (e) {
return reply(downoff)
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: tiktokdl
└─────────────────────────────────────────────────┘
*/
case 'tiktokdl':
reagir(from, "🎥")
try {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
//Canal: https://whatsapp.com/channel/0029Va6riekH5JLwLUFI7P2B
if (!q.includes("tiktok")) {
return reply(`${prefix + command} link do Tiktok`)
}
let response = await fetchJson(`${zerosite}/api/tiktok-download?url=${q}&apikey=${API_KEY_ZEROTWO}`)
if (!response || !response.links_download) {
return reply(downoff)
}
const { titulo, links_download } = response
let caption = `
❯❯〘 ${titulo} 〙❮❮

❯ BAIXADO POR ${NomeDoBot}
`
let audioSent = false
if (links_download.video_mp4_2) {
await zerotwo.sendMessage(from, { video: { url: links_download.video_mp4_2 }, caption: caption, mimetype: "video/mp4" }, { quoted: selolucas })
if (links_download.mp3) {
await reply(`
🎧 *Agora, o áudio do vídeo será enviado!*

⏳ *Aguarde enquanto enviamos a música...*
`)
await zerotwo.sendMessage(from, { audio: { url: links_download.mp3 }, mimetype: "audio/mpeg", ptt: true }, { quoted: selolucas })
audioSent = true
}
} 
if (!links_download.video_mp4_2 && links_download.imagens && links_download.imagens.length > 0) {
for (let link of links_download.imagens) {
try {
if (link.includes("http")) {
await zerotwo.sendMessage(from, { image: { url: link }, caption: `
❯❯〘 ${titulo} 〙❮❮

❯ BAIXADO POR ${NomeDoBot}
` }, { quoted: selolucas })
}
} catch (err) {
console.log(`Erro ao enviar a imagem: ${link}`, err)}
}
if (links_download.mp3 && !audioSent) {
await reply(`
🎧 *Agora, o áudio das imagens será enviado!*

⏳ *Aguarde enquanto enviamos a música...*`)
await zerotwo.sendMessage(from, { audio: { url: links_download.mp3 }, mimetype: "audio/mpeg", ptt: true }, { quoted: selolucas })
}
} 
if (!links_download.video_mp4_2 && (!links_download.imagens || links_download.imagens.length === 0)) {
return reply("Nenhum vídeo ou imagem encontrado para download.")
}
} catch (e) {
console.log(e)
return reply(downoff)
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: tiktokhd
└─────────────────────────────────────────────────┘
*/
case 'tiktokhd':
reagir(from, "🎥")
try {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
//Canal: https://whatsapp.com/channel/0029Va6riekH5JLwLUFI7P2B
if (!q.includes("tiktok")) {
return reply(`${prefix + command} link do Tiktok`)
}
let response = await fetchJson(`${zerosite}/api/tiktok-download?url=${q}&apikey=${API_KEY_ZEROTWO}`)
if (!response || !response.links_download) {
return reply(downoff)
}
const { titulo, links_download } = response
let caption = `
❯❯〘 ${titulo} 〙❮❮

❯ BAIXADO POR ${NomeDoBot}
`
let audioSent = false
if (links_download.video_hd) {
await zerotwo.sendMessage(from, { video: { url: links_download.video_hd }, caption: caption, mimetype: "video/mp4" }, { quoted: selolucas })
if (links_download.mp3) {
await reply(`
🎧 *Agora, o áudio do vídeo será enviado!*

⏳ *Aguarde enquanto enviamos a música...*
`)
await zerotwo.sendMessage(from, { audio: { url: links_download.mp3 }, mimetype: "audio/mpeg", ptt: true }, { quoted: selolucas })
audioSent = true
}
} 
if (!links_download.video_hd && links_download.imagens && links_download.imagens.length > 0) {
for (let link of links_download.imagens) {
try {
if (link.includes("http")) {
await zerotwo.sendMessage(from, { image: { url: link }, caption: `
❯❯〘 ${titulo} 〙❮❮

❯ BAIXADO POR ${NomeDoBot}
` }, { quoted: selolucas })
}
} catch (err) {
console.log(`Erro ao enviar a imagem: ${link}`, err)}
}
if (links_download.mp3 && !audioSent) {
await reply(`
🎧 *Agora, o áudio das imagens será enviado!*

⏳ *Aguarde enquanto enviamos a música...*`)
await zerotwo.sendMessage(from, { audio: { url: links_download.mp3 }, mimetype: "audio/mpeg", ptt: true }, { quoted: selolucas })
}
} 
if (!links_download.video_hd && (!links_download.imagens || links_download.imagens.length === 0)) {
return reply("Nenhum vídeo ou imagem encontrado para download.")
}
} catch (e) {
console.log(e)
return reply(downoff)
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: tiktoksearch
└─────────────────────────────────────────────────┘
*/
case 'tiktoksearch':
if (!q) return reply(`Cadê o termo de busca para o TikTok?\n*Exemplo:* ${prefix + command} lisa`)
async function shortenUrl(url) {
try {
let response = await axios.get(`https://tinyurl.com/api-create.php?url=${encodeURIComponent(url)}`)
return response.data
} catch (error) {
console.log('Erro ao encurtar URL:', error)
return url
}
}
try {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
//Canal: https://whatsapp.com/channel/0029Va6riekH5JLwLUFI7P2B
reagir(from, "🔎")
let apiResponse = await axios.get(`${zerosite}/download/tiktoksearch?username=${encodeURIComponent(q)}&apikey=${API_KEY_ZEROTWO}`)
let res = apiResponse.data
if (!res.status || !res.resultado) {
return reply(`Não foi possível encontrar resultados para '${q}' no TikTok.`)
}
let result = res.resultado
let shortenedUrl = await shortenUrl(result.no_watermark)
let legenda = `
❯❯ ZERO TWO - SEARCH TIKTOK ❮❮

*❯ Título:* ${result.title}

*❯ Visualizar no Chrome:*
${shortenedUrl}

❯❯〘 BAIXADO PELA ZERO TWO 〙❮❮`
let contextInfo = {
mentionedJid: [sender],
externalAdReply: {
title: `💞 ${NomeDoBot} 💞\n》ｃｌｉｃｋ ａｑｕｉ《`,
sourceUrl: shortenedUrl,
thumbnail: await getBuffer(result.cover),
mediaType: 1, 
mediaUrl: result.watermark
}
}
if (result.no_watermark) {
await sendVideo(from, result.no_watermark, legenda, contextInfo, selolucas)
} else {
reply('Não foi possível encontrar o vídeo para download.')
}
if (result.music) {
await sendAudio(from, result.music, 'audio/mpeg', selolucas)
} else {
reply('Não foi possível encontrar o áudio para download.')
}
} catch (e) {
console.log('Erro ao buscar informações no TikTok:', e)
reply('Ocorreu um erro ao buscar informações no TikTok. Por favor, tente novamente mais tarde.')
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: tiktokstalk
└─────────────────────────────────────────────────┘
*/
case 'tiktokstalk':
if (!isChatOfc && !isAdvencedVip(sender) && !isAdvencedGroupVip(from)) return reply(enviar.msg.vip)
if (!q) return reply('❯❯〘 ⚠️ Você precisa fornecer um nome de usuário do Instagram! ⚠️〙❮❮')
const tiktokApiUrl = `${zerosite}/api/tiktokstalker?usuario=${q}&apikey=`+API_KEY_ZEROTWO
try {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
zerotwo.sendMessage(from, { react: { text: `🙇🏻‍♀️`, key: info.key }})
const response = await fetchJson(tiktokApiUrl)
if (response && response.resultado) {
const data = response.resultado
const tiktokMessage = `
❯❯ ${NomeDoBot} - TIKTOK STALK ❮❮

*❒᭄➭ Nome de usuário:* ${data.usuário}
*❒᭄➭ Nome:* ${data.nome}
*❒᭄➭ Seguidores:* ${data.seguidores}
*❒᭄➭ Seguindo:* ${data.seguindo}
*❒᭄➭ Descrição:* ${data.descrição}
`
await zerotwo.sendMessage(from, {image: { url: data.profile_photo }, caption: tiktokMessage}, {quoted: selolucas})
} else {
await zerotwo.sendMessage(from, { text: '❯❯〘 ⚠️ Não foi possível encontrar informações para este usuário. ⚠️〙❮❮' }, {quoted: selolucas})
}
} catch (error) {
if (error.code === 'ECONNREFUSED') {
await zerotwo.sendMessage(from, { text: '❯❯〘 ⚠️ Não foi possível conectar ao servidor. Por favor, tente novamente mais tarde. ⚠️〙❮❮' }, {quoted: selolucas})
} else {
console.log(error)
await zerotwo.sendMessage(from, { text: '❯❯〘 ⚠️ Ocorreu um erro ao tentar buscar as informações do TikTok! ⚠️〙❮❮' }, {quoted: selolucas})
}
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: tiktokstalk2
└─────────────────────────────────────────────────┘
*/
case 'tiktokstalk2':
try {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
if (!isVip) return reply(enviar.msg.vip)
if (!q) return reply(`❓ *Por favor, informe o username do TikTok!* Exemplo: ${prefix}tiktokstalk lucas_mod_domina`)
reply("⏳ *Consultando o perfil informado, aguarde...*")
const response = await fetchJson(`${zerosite}/api/tiktokStalk?username=${q}&apikey=${API_KEY_ZEROTWO}`)
zerotwo.sendMessage(from, { react: { text: `🙇🏻‍♀️`, key: info.key }})
const data = response.resultado
if (!data) return reply("❌ *Nenhum perfil encontrado!*")
const formatNumber = (num) => {
if (num >= 1e6) return (num / 1e6).toFixed(2) + 'M'
if (num >= 1e3) return (num / 1e3).toFixed(2) + 'K'
return num
}
const stalkResult = `📱 *TikTok Stalker* 📱

───────────────
👤 *Username:* ${data.username}
💬 *Nickname:* ${data.nickname}
📖 *Bio:* ${data.description || 'Sem descrição'}
✅ *Verificado:* ${data.verificado ? "Sim" : "Não"}
🔒 *Conta Privada:* ${data.contaPriv ? "Sim" : "Não"}
🏢 *Conta Comercial:* ${data.contaComercial ? "Sim" : "Não"}
🌎 *Região:* ${data.região || 'Não informado'}
👥 *Seguidores:* ${formatNumber(data.seguidores)}
🔗 *Seguindo:* ${data.seguindo}
🧑‍🤝‍🧑 *Amigos:* ${data.amigos}
❤️ *Likes:* ${formatNumber(data.likes)}
🎬 *Vídeos:* ${data.videos}
📂 *Posts:* ${data.posts}
───────────────
`
const profilePicUrl = data.profilePicture
const imageResponse = await fetch(profilePicUrl)
if (!imageResponse.ok) throw new Error('Falha ao obter a imagem da URL')
const arrayBuffer = await imageResponse.arrayBuffer()
const imageBuffer = Buffer.from(arrayBuffer)
const uploadedImageUrl = await upload(imageBuffer)
const hdImageUrl = `${zerosite}/api/ia/tohd?link=${uploadedImageUrl}&apikey=${API_KEY_ZEROTWO}`
const preparedImage = await prepareWAMessageMedia({ image: { url: hdImageUrl } }, { upload: zerotwo.waUploadToServer })
zerotwo.relayMessage(from, {
interactiveMessage: {
header: {
hasMediaAttachment: true,
imageMessage: preparedImage.imageMessage
},
headerType: 'IMAGE',
body: { text: stalkResult },
footer: { text: '© Zero Two' },
nativeFlowMessage: {
buttons: [{
name: "cta_url",
buttonParamsJson: JSON.stringify({
display_text: "Veja O Perfil Stalkeado",
url: `https://www.tiktok.com/@${q}`,
merchant_url: `https://www.tiktok.com/@${q}`
})
}]
}
}
}, {})
} catch (e) {
reply('❌ *Erro ao consultar o perfil do TikTok!*')
console.error(e)
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: tinder
└─────────────────────────────────────────────────┘
*/
case 'tinder':
reagir(from, "🔥")
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(enviar.msg.modobz)
try {
ABC = await fetchJson(`${zerosite}/tinder/find?usu=${sender}&apikey=`+API_KEY_ZEROTWO)
data = await fetchJson(`${zerosite}/tinder/perfil?usu=${sender}&apikey=`+API_KEY_ZEROTWO)
txt = `
ㅤㅤㅤ🔥 𝒁𝒆𝒓𝒐 𝑻𝒘𝒐 𝒕𝒊𝒏𝒅𝒆𝒓 🔥
╔══════════════════╣
╟ ❪😍ฺ࣭࣪͘ꕸ▸ ɴᴏᴍᴇ: ${ABC.dados[0].nome}
║
╟ ❪😏ฺ࣭࣪͘ꕸ▸ ᴡʜᴀᴛꜱᴀᴩᴩ: wa.me/${ABC.dados[0].nmr}
║
╟ ❪🤫ฺ࣭࣪͘ꕸ▸ ɪᴅᴀᴅᴇ: ${ABC.dados[0].idade} anos
║
╟ ❪🤭ฺ࣭࣪͘ꕸ▸ ꜱᴇxᴜᴀʟɪᴅᴀᴅᴇ: ${ABC.dados[0].sexualidade}
║
╟ ❪🫣ฺ࣭࣪͘ꕸ▸ ɢêɴᴇʀᴏ: ${ABC.dados[0].gene}
║
╩ 𖥨ํ∘̥⃟⸽⃟💌৴▸ ʙɪᴏ: ${ABC.dados[0].bio}

_Exibindo perfil nº${ABC.dados[0].id} de ${ABC.dados[0].total} usuário${ABC.dados[0].total > 1 ? 's' : ''} registrado${ABC.dados[0].total > 1 ? 's' : ''}_
`
zerotwo.sendMessage(from, {image: {url: `${zerosite}/api/canvas/ship?foto1=${data.dados[0].foto}&foto2=${ABC.dados[0].foto}&mat=${alerandom(100)}&fundo=https://telegra.ph/file/b41f8e7f2ca966c8a6667.jpg`}, caption: txt}, {quoted: selolucas})
} catch { reply(resptinder(ABC.message || "Erro")) }
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: tinderfoto
└─────────────────────────────────────────────────┘
*/
case 'tinderfoto':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(enviar.msg.modobz)
try {
ABC = await fetchJson(`${zerosite}/tinder/config?usu=${sender}&mod=${command}&${q && !isQuotedImage ? `q=${q}&` : ``}apikey=`+API_KEY_ZEROTWO)
if(command == "tinderfoto" && isQuotedImage) {
try {
boij = isQuotedImage ? JSON.parse(JSON.stringify(selolucas).replace('quotedM','m')).message.extendedTextMessage.contextInfo.message.imageMessage : info.message.imageMessage
owgi = await getFileBuffer(boij, 'image')
img = await upload(owgi)
BCD = await fetchJson(`${zerosite}/tinder/config?usu=${sender}&mod=${command}&q=${img}&apikey=`+API_KEY_ZEROTWO)
return reply(resptinder(BCD.message))
} catch { return reply("Erro ao salvar a imagem... Tente novamente") }
}
reply(resptinder(ABC.message))
} catch { reply("Erro") }
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: tmgp2
└─────────────────────────────────────────────────┘
*/
case 'tmgp2': {
if (!isOwner) {
return reply(`Ei, Esse Comando e Para O Meu Mestre.`)
}
const mensagem = args.join(" ")
if (!mensagem) {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
return reply(`O Que Deseja Transmitir Mestre?.`)
}
fonte = ['Instagram', 'Tiktok', 'YouTube', 'Kwai', 'Facebook', 'Internet']
gozeinonear = Math.floor(Math.random() * 1000)
const mensagems = `❯❯ ZERO TWO - EDIT ANIME ❮❮
❒ৣ͜͡Categoria: Edit Animes
❒ৣ͜͡Fonte: ${fonte[Math.floor(Math.random() * fonte.length)]} 
❒ৣ͜͡Coleção: Zero Two Oficial 
❒ৣ͜͡Curtidas: ${gozeinonear}

${zerosite}
`
try {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
const getGroups = await zerotwo.groupFetchAllParticipating()
const groups = Object.values(getGroups)
const groupIds = groups.map(group => group.id)
reply(`Realizando a transmissão para ${groupIds.length} grupos.`)
for (let groupId of groupIds) {//𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
await delay(1500)
try {
const groupMembers = await zerotwo.groupMetadata(groupId)
const memberIds = groupMembers.participants.map(member => member.id)
const img = await prepareWAMessageMedia({ video: { url: `${zerosite}/random/aleatorios?apikey=${API_KEY_ZEROTWO}&categoria=aleatorios` }, gifPlayback: true }, { upload: zerotwo.waUploadToServer })
await zerotwo.relayMessage(groupId, {
interactiveMessage: {
header: {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
hasMediaAttachment: true,
videoMessage: img.videoMessage, gifPlayback: true },
headerType: 1,
body: {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
text: mensagem
},
footer: { text: `\nby: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄\n\n${mensagems}` },
contextInfo: {forwardingScore: 999, isForwarded: true, forwardedNewsletterMessageInfo: {newsletterJid: channel, newsletterName: `𝙲𝙾𝙽𝙽𝙴𝙲𝚃𝙴𝙳 𝙲𝙾𝙽𝚃𝙴Ú𝙳𝙾𝚂`}},
nativeFlowMessage: {
buttons: [{//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
name: "quick_reply",
buttonParamsJson: JSON.stringify({
display_text: "❯❯〘 ꪶ𝐌𝐄𝐍𝐔ꫂ 〙❮❮",
id: `${prefix}menu`,
disabled: false
}),
}],
messageParamsJson: "",
},
},
}, {})
} catch (error) {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
console.log(`Erro ao enviar mensagem para o grupo ${groupId}:`, error)
}
}
reply("Transmissão realizada com sucesso.")
} catch (error) {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
console.log('Erro ao realizar a transmissão:', error)
reply("Ocorreu um erro ao realizar a transmissão. Por favor, tente novamente mais tarde.")
}
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: tmgrupo
└─────────────────────────────────────────────────┘
*/
case 'tmgrupo': {
if (!isOwner) {
return reply(`Ei, Esse Comando e Para O Meu Mestre.`)
}
const mensagem = args.join(" ")
if (!mensagem) {//By: Licht San
return reply(`O Que Deseja Transmitir Mestre?.`)
}
try {//By: Licht San
const getGroups = await zerotwo.groupFetchAllParticipating()
const groups = Object.values(getGroups)
const groupIds = groups.map(group => group.id)
reply(`Realizando a transmissão para ${groupIds.length} grupos.`)
for (let groupId of groupIds) {//By: Licht San
await delay(1500)
try {
const groupMembers = await zerotwo.groupMetadata(groupId)
const memberIds = groupMembers.participants.map(member => member.id)
const img = await prepareWAMessageMedia({ image: waifuzdd3 }, { upload: zerotwo.waUploadToServer })
await zerotwo.relayMessage(groupId, {
interactiveMessage: {
header: {//By: Licht San
hasMediaAttachment: true,
imageMessage: img.imageMessage
},
headerType: `IMAGE`,
body: {//By: Licht San
text: mensagem
},
footer: { text: `${zerosite}\nBy: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄` },
contextInfo: {forwardingScore: 999, isForwarded: true, forwardedNewsletterMessageInfo: {newsletterJid: channel, newsletterName: `𝙲𝙾𝙽𝙽𝙴𝙲𝚃𝙴𝙳 𝙲𝙾𝙽𝚃𝙴Ú𝙳𝙾𝚂`}},
nativeFlowMessage: {
buttons: [{//By: Licht San
name: "quick_reply",
buttonParamsJson: JSON.stringify({
display_text: "❯❯〘 ꪶ𝐌𝐄𝐍𝐔ꫂ 〙❮❮",
id: `${prefix}menu`,
disabled: false
}),
}],
messageParamsJson: "",
},
},
}, {})
} catch (error) {//By: Licht San
console.log(`Erro ao enviar mensagem para o grupo ${groupId}:`, error)
}
}
reply("Transmissão realizada com sucesso.")
} catch (error) {//By: Licht San 
console.log('Erro ao realizar a transmissão:', error)
reply("Ocorreu um erro ao realizar a transmissão. Por favor, tente novamente mais tarde.")
}
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: toanime
└─────────────────────────────────────────────────┘
*/
case 'toanime':
if(!isVip && !isGroup) return reply(enviar.msg.pvnotvip)
if((isMedia && !info.message.videoMessage || isQuotedImage)) {
boij = isQuotedImage ? JSON.parse(JSON.stringify(selolucas).replace('quotedM','m')).message.extendedTextMessage.contextInfo.message.imageMessage : info.message.imageMessage
owgi = await getFileBuffer(boij, 'image')
link = await upload(owgi)
reply(`ৎ❥̤֟٭ۣۜDesenhando pixel a pixel, isso pode demorar ❒ `)
const response = await fetch(`${zerosite}/api/ia/${command}?url=${link}&apikey=` + API_KEY_ZEROTWO)
if (!response.ok) throw new Error('Erro ao acessar a API')
const data = await response.json()
if (data.status !== 'success' || !data.resultado?.img) {
throw new Error('Resposta inválida da API')
}
const imageUrl = data.resultado.img
zerotwo.sendMessage(from, {image: {url: imageUrl}, contextInfo: { mentionedJid: [sender], externalAdReply: { showAdAttribution: true, mediaType: 'VIDEO', mediaUrl: null, title: `💞 ${NomeDoBot} 💞\n》🅒🅛🅘🅠🅤🅔 🅐🅠🅤🅘《`, body: null, sourceUrl: `${links.linkss}`, mediaUrl: 'https://youtube.com/@Otaku.mp4', thumbnail: await getBuffer(`${links.logocapa}`)}, forwardingScore: 999, isForwarded: true, forwardedNewsletterMessageInfo: {newsletterJid: channel, newsletterName: `𝙲𝙾𝙽𝙽𝙴𝙲𝚃𝙴𝙳 𝙲𝙾𝙽𝚃𝙴Ú𝙳𝙾𝚂`}}}, {quoted: selolucas}).catch(e => {
console.log(e)
return reply("Erro ao converter a imagem")
})
} else {
reply('Marque uma imagem para eu atribuir o efeito')
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: tozombie
└─────────────────────────────────────────────────┘
*/
case 'tozombie':
if(!isVip && !isGroup) return reply(enviar.msg.pvnotvip)
if((isMedia && !info.message.videoMessage || isQuotedImage)) {
boij = isQuotedImage ? JSON.parse(JSON.stringify(selolucas).replace('quotedM','m')).message.extendedTextMessage.contextInfo.message.imageMessage : info.message.imageMessage
owgi = await getFileBuffer(boij, 'image')
link = await upload(owgi)
reply(`ৎ❥̤֟٭ۣۜDesenhando pixel a pixel, isso pode demorar ❒ `)
const response = await fetch(`${zerosite}/api/ia/${command}?url=${link}&apikey=` + API_KEY_ZEROTWO)
if (!response.ok) throw new Error('Erro ao acessar a API')
const data = await response.json()
if (data.status !== 'success' || !data.resultado) {
throw new Error('Resposta inválida da API')
}
const imageUrl = data.resultado
zerotwo.sendMessage(from, {image: {url: imageUrl}, contextInfo: { mentionedJid: [sender], externalAdReply: { showAdAttribution: true, mediaType: 'VIDEO', mediaUrl: null, title: `💞 ${NomeDoBot} 💞\n》🅒🅛🅘🅠🅤🅔 🅐🅠🅤🅘《`, body: null, sourceUrl: `${links.linkss}`, mediaUrl: 'https://youtube.com/@Otaku.mp4', thumbnail: await getBuffer(`${links.logocapa}`)}, forwardingScore: 999, isForwarded: true, forwardedNewsletterMessageInfo: {newsletterJid: channel, newsletterName: `𝙲𝙾𝙽𝙽𝙴𝙲𝚃𝙴𝙳 𝙲𝙾𝙽𝚃𝙴Ú𝙳𝙾𝚂`}}}, {quoted: selolucas}).catch(e => {
console.log(e)
return reply("Erro ao converter a imagem")
})
} else {
reply('Marque uma imagem para eu atribuir o efeito')
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: traduzir
└─────────────────────────────────────────────────┘
*/
case 'traduzir':
if(!isGroup) return
if(args.length < 2) return reply(`Você precisa selecionar o idioma primeiro e após ele o texto, ex:
${prefix+command} pt i love you`)
txt1 = args[0]
txt2 = q.split(args[0])[1]
try {
ABC = await fetchJson(`${zerosite}/api/info/translate?texto=${encodeURI(txt2)}&ling=${encodeURI(txt1)}&apikey=`+API_KEY_ZEROTWO)
reply(`${ABC.result}`)
} catch {
reply(`Erro 404`)
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: ttp
└─────────────────────────────────────────────────┘
*/
case 'ttp':
try {
if(!q) return reply(`Exemplo: ${prefix+command} ZERO TWO`)
reply(`*Gerando figu com a frase* _"${q}"_`)
link = `${zerosite}/api/ttp?texto=${encodeURI(q)}&apikey=`+API_KEY_ZEROTWO
luquinhas = await getBuffer(link)
bass64 = `data:image/jpeg;base64,${luquinhas.toString('base64')}`
mantap = await convertSticker(bass64, `𝐃𝐎𝐌𝐈𝐍𝐀💡`, `👑 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀`)
stickerM4 = new Buffer.from(mantap, 'base64')
zerotwo.sendMessage(from, {sticker: stickerM4}, {quoted: selolucas})
} catch (e) {
return reply("Erro..")
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: twtdl
└─────────────────────────────────────────────────┘
*/
case 'twtdl':
if(!q) return reply(`Faltando o link válido do twitter para download do video ou foto.`)
reagir(from, "😸")
try {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
//Canal: https://whatsapp.com/channel/0029Va6riekH5JLwLUFI7P2B
reply(`❪𝙴𝚗𝚟𝚒𝚊𝚗𝚍𝚘ฺ࣭࣪͘ꕸ▸`)
const ABC = await fetchJson(`${zerosite}/api/dl/twitter?url=${q}&apikey=${API_KEY_ZEROTWO}`)
if (ABC.status) {
const dataOriginal = ABC.resultado.date
const data = new Date(dataOriginal)
const dataFormatada = data.toLocaleString('pt-BR', {
weekday: 'short',
day: '2-digit',
month: 'short',
year: 'numeric',
})
const horaFormatada = data.toLocaleString('pt-BR', {
hour: '2-digit',
minute: '2-digit',
second: '2-digit',
hour12: false
})
const caption = `❏ Autor: ${ABC.resultado.authorName} (@${ABC.resultado.authorUsername})\n❏ Data: ${dataFormatada}\n❏ Hora: ${horaFormatada}\n❏ Curtidas: ${ABC.resultado.likes}\n❏ Respostas: ${ABC.resultado.replies}\n❏ Retweets: ${ABC.resultado.retweets}`
if (Array.isArray(ABC.resultado.media) && ABC.resultado.media.length > 0) {
for (let i = 0; i < ABC.resultado.media.length; i++) {
await sleep(1000)
const mytype = ABC.resultado.media[i]
if (mytype.type === "video") {
zerotwo.sendMessage(from, { video: { url: mytype.url }, caption: caption }, { quoted: selolucas })
} else if (mytype.type === "image") {
zerotwo.sendMessage(from, { image: { url: mytype.url }, caption: caption }, { quoted: selolucas })
}
}
} else {
reply(`Nenhuma mídia encontrada no Twitter.`)
}
} else {
reply(`Erro ao processar o conteúdo do Twitter.`)
}
} catch (e) {
console.log(e)
reply(`Erro`)
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: verifkey
└─────────────────────────────────────────────────┘
*/
case 'verifkey':
if (!q) return reply(`⚠️ *Informe o nome da key para verificação!*\n\n📌 Exemplo: *${prefix}${command} luquinhas*`)
const keyName = encodeURIComponent(q)
function parseHtmlToJson(html) {
try {
const $ = cheerio.load(html)
const message = $('h1').text()
const paragraphs = $('p').map((i, el) => $(el).text().trim()).get()
const status = message.toLowerCase().includes('funcionando') || message.toLowerCase().includes('perfeitamente') ? true : false
const jsonData = {
status: status,
message: message || "Erro desconhecido",
motivo: paragraphs[0] || '',
solucao: paragraphs[1] || '',
contato: paragraphs[2] || '',
limite: paragraphs[3] || '',
consultaAtiva: paragraphs[4] || '',
}
return jsonData
} catch (error) {
console.error("Erro ao converter HTML para JSON:", error)
return null
}
}
fetch(`${zerosite}/api/keyerrada?apikey=${keyName}`)
.then(response => response.text())
.then(text => {
try {
return JSON.parse(text)
} catch (e) {
console.warn("A resposta não é JSON, tentando converter HTML...");
const jsonData = parseHtmlToJson(text)
if (!jsonData) throw new Error("A API retornou HTML e não foi possível converter para JSON.")
return jsonData
}
})
.then(data => {
console.log("Dados processados:", data)
if (data.status) {
const limiteRequests = data.limite.match(/\d+/g)?.[0] || 'N/A'
const consultaMatch = data.consultaAtiva.match(/Quantidade:\s*(\d+)/i)
const consultaAtiva = consultaMatch ? parseInt(consultaMatch[1]) : 0
const consultaStatus = consultaAtiva > 0 ? '🟢 Ativada' : '🔴 Desativada'
const statusMsg = `> 🎟️ *VERIFICAÇÃO DE APIKEY* 🎟️\n\n` +
`✅ *Status:* Válida e funcionando!\n` +
`🔢 *Limite de Requests:* ${limiteRequests}\n` +
`🔍 *Consulta:* ${consultaStatus}\n` +
`👾 *Requests Consulta:* ${consultaAtiva}\n\n` +
`> 🔗 *Servidor Seguro:* 🔒`
reply(statusMsg)
} else {
reply(`🚫 *APIKEY INVÁLIDA OU REQUESTS ESGOTADOS!* 🚫\n\n⚠️ Verifique se a chave informada está correta.`)
}
})
.catch(error => {
console.error("Erro ao conectar com a API:", error)
reply("⚠️ Erro ao se conectar com o servidor!\n\n🔄 Tente novamente mais tarde.")
})
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: wallpaperanime
└─────────────────────────────────────────────────┘
*/
case 'wallpaperanime':
reagir(from, "✨")
const { wallpaperss } = require('./database/wallpaperanimes.js') 
var wallpapers = wallpaperss[Math.floor(Math.random() * wallpaperss.length)] 
votoss = Math.floor(Math.random() * 1000)
versao = 'Beta'
const bxx = `
❯❯ ✦『𝐙𝐄𝐑𝐎 𝐓𝐖𝐎』✦ - WALLPAPER ANIMES ❮❮\n\n*❒᭄➭ Fonte:* Internet \n*❒᭄➭ Coleção:* Zero Two Oficial\n*❒᭄➭ Curtidas:* ${votoss}
*❒᭄➭ Categoria:* wallpaperanime`

const image = await prepareWAMessageMedia({ image: { url: wallpapers } }, { upload: zerotwo.waUploadToServer })

zerotwo.relayMessage(
from,
{//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
interactiveMessage: {
header: {
hasMediaAttachment: true,
imageMessage: { ...image.imageMessage, gifPlayback: true }
},
headerType: 'IMAGE',
body: { text: bxx },
footer: { text: `${zerosite}\nBy: lucas_mod_domina` },
contextInfo: {forwardingScore: 999, isForwarded: true, forwardedNewsletterMessageInfo: {newsletterJid: channel, newsletterName: `𝙲𝙾𝙽𝙽𝙴𝙲𝚃𝙴𝙳 𝙲𝙾𝙽𝚃𝙴Ú𝙳𝙾𝚂`}},
nativeFlowMessage: {
buttons: [
{//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
name: "quick_reply",
buttonParamsJson: JSON.stringify({//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
display_text: "❯❯ PRÓXIMA ❮❮",
id: `${prefix+command}`,
disabled: false
}),
}
],
messageParamsJson: "",
},
},
},
{}
)
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: whatsappstalk
└─────────────────────────────────────────────────┘
*/
case 'whatsappstalk':
if (!isChatOfc && !isAdvencedVip(sender) && !isAdvencedGroupVip(from)) return reply(enviar.msg.vip)
if (!q) return reply('❯❯〘 ⚠️ Você precisa fornecer o link do canal do WhatsApp! ⚠️〙❮❮')
try {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
//Canal: https://whatsapp.com/channel/0029Va6riekH5JLwLUFI7P2B
zerotwo.sendMessage(from, { react: { text: `🔍`, key: info.key }})
const whatsappChannelApiUrl = `${zerosite}/api/stalker/whatsapp-channel?url=${q}&apikey=${API_KEY_ZEROTWO}`
const response = await fetchJson(whatsappChannelApiUrl)
if (response && response.status) {
const data = response.resultado
const channelMessage = `
❯❯ ${NomeDoBot} - WHATSAPP CHANNEL STALK ❮❮

*❒᭄➭ Criador:* ${response.criador}
*❒᭄➭ Nome do Canal:* ${data.channelName}
*❒᭄➭ Seguidores:* ${data.followersCount}
*❒᭄➭ Descrição:* ${data.description}

----------------------------------------------------------------
🔗 *Link do Canal:* ${q}
----------------------------------------------------------------
`
await zerotwo.sendMessage(from, { image: { url: data.imageUrl }, caption: channelMessage }, { quoted: selolucas })
} else {
await zerotwo.sendMessage(from, { text: '❯❯〘 ⚠️ Não foi possível encontrar informações para este canal. ⚠️〙❮❮' }, { quoted: selolucas })
}
} catch (error) {
if (error.code === 'ECONNREFUSED') {
await zerotwo.sendMessage(from, { text: '❯❯〘 ⚠️ Não foi possível conectar ao servidor. Por favor, tente novamente mais tarde. ⚠️〙❮❮' }, { quoted: selolucas })
} else {
console.log(error)
await zerotwo.sendMessage(from, { text: '❯❯〘 ⚠️ Ocorreu um erro ao tentar buscar as informações do canal do WhatsApp! ⚠️〙❮❮' }, { quoted: selolucas })
}
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: xnxx
└─────────────────────────────────────────────────┘
*/
case 'xnxx':
reagir(from, "🔥")
if(isGroup && !isNsfw) return reply(enviar.msg.modonsfw)
if (!isChatOfc && !isAdvencedVip(sender) && !isAdvencedGroupVip(from)) return reply(enviar.msg.vip)
if(!q) return reply(prefix+command+" link ou nome")
try {
if(!isUrl(q)) {
ABC = await fetchJson(zerosite+`/api/xnxx?q=${encodeURI(q)}&apikey=`+API_KEY_ZEROTWO)
if(ABC.resultado.length <= 0) return reply(`Sem resultados disponíveis..`)
i = ABC.resultado[alerandom(ABC.resultado.length)]
media = await fetchJson(zerosite+`/api/xnxxdl?url=${i.link}&apikey=`+API_KEY_ZEROTWO)
txt =
`📝 *TÍTULO:* ${i.title}
⏳ *DURAÇÃO:* ${i.duration}
🥏 *QUALIDADE:* ${i.quality}
📊 *VIEWS:* ${i.views}
🔗 *LINK:* ${i.link}`
sendUrlText(sender, txt, `🧿 Search XNXX - `+i.title, media.resultado.keyword, i.thumb, i.link, selolucas)
sendVideo(sender, media.resultado.url)
} else {
media = await fetchJson(zerosite+`/api/xnxxdl?url=${q}&apikey=`+API_KEY_ZEROTWO)
if(isGroup) reply(`Chega PV lek 😈`)
await sleep(1000)
sendVideo(sender, media.resultado.url)
}
} catch(e) { console.log(e)
reply("Erro") }
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: xv
└─────────────────────────────────────────────────┘
*/
case 'xv':
reagir(from, "😳")
if(isGroup && !isNsfw) return reply(enviar.msg.modonsfw)
if (!isChatOfc && !isAdvencedVip(sender) && !isAdvencedGroupVip(from)) return reply(enviar.msg.vip)
if(!q) return reply(prefix+command+" link ou nome")
try {
if(!isUrl(q)) {
ABC = await fetchJson(`${zerosite}/api/xvsearch?q=${encodeURI(q)}&apikey=`+API_KEY_ZEROTWO)
if(ABC.resultado.length <= 0) return reply(`Sem resultados disponíveis..`)
i = ABC.resultado[alerandom(ABC.resultado.length)]
media = await fetchJson(`${zerosite}/api/xvideos?url=${i.link}&apikey=`+API_KEY_ZEROTWO)
txt = `📝 *TÍTULO:* ${i.titulo}
🤭 *DESCRIÇÃO:* ${media.resultado.desc}
⏳ *DURAÇÃO:* ${i.duracao}
🔗 *LINK:* ${i.link}`
sendUrlText(sender, txt, `🔞 Search XV - `+i.titulo, media.resultado.desc, i.thumbnail, i.link, selolucas)
await sleep(1000)
sendVideo(sender, media.resultado.download)
} else {
media = await fetchJson(`${zerosite}/api/xvideos?url=${q}&apikey=`+API_KEY_ZEROTWO)
ABC = await fetchJson(`${zerosite}/api/info/translate?texto=${encodeURI(media.resultado.titulo)}&ling=pt&apikey=`+API_KEY_ZEROTWO)
if(isGroup) reply(`Chega PV lek 😈`)
await sleep(1000)
sendVideo(sender, media.resultado.download, "🔞 XV - "+ABC.result, selolucas)
}
} catch(e) { console.log(e)
reply("Erro") }
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: you
└─────────────────────────────────────────────────┘
*/
case 'you':
if (command == `you`) {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
if (!isOwner) return reply(enviar.msg.donosmt)
if (!marc_tds) return reply("Marque o usuário que vc quer puxar o saldo")
usu = marc_tds
} else {
usu = sender
}
registrarUsuInVirtualBalance(usu)
try {
ppimg = await zerotwo.profilePictureUrl(`${usu.split('@')[0]}@c.us`, 'image')
} catch {
ppimg = semfoto
}
i = getCoinsUsu(usu)
keyNamees = API_KEY_ZEROTWO
let limiteRequests, consulta
await fetch(`${zerosite}/api/keyerrada?apikey=${keyNamees}`)
.then(response => response.json())
.then(data => {
if (data.status) {
limiteRequests = data.limite_de_request;
consulta = data.consulta.ativa ? 'Ativada' : 'Desativada'
} else {
limiteRequests = 'Infinito'
consulta = 'Desativada'
}
})
.catch(error => {
limiteRequests = 'Erro ao verificar'
consulta = 'Desativada'
})
txt = `📖 *NOME:* ${getSepCoins(usu)[0]}
🔢 *REQUESTS:* ${limiteRequests}
🔍 *CONSULTA:* ${consulta}
💸 *SALDO:* R$ ${getSepCoins(usu)[2]}
📱 *WHATSAPP:* wa.me/${i.id.split('@')[0]}
🆔 *ID:* ${i.UID}
💳 *CORTESIAS:* ${i.cortesia} ${i.keys.length > 0 ? `

🔑 *KEYS:*
${i.keys.map(k => `• *chave:* ${isGroup ? k.key.slice(0, 10) + `#`.repeat(k.key.length - 10) : k.key}
• *tipo:* "${k.tipo == 1 ? `aluguel` : k.tipo == 2 ? `cortesia` : k.tipo == 3 ? `vip` : k.tipo == 4 ? `grupo vip` : `card xp`}"
• *tempo:* ${k.tempo <= 0 ? `∞ INFINITO` : k.tipo == 1 || k.tipo == 2 || k.tipo == 5 ? String((k.tempo - (k.tempo % 24)) / 24) + `d` + ((k.tempo % 24) > 0 ? ` e ` + String(k.tempo % 24) + `h` : ``) : String(k.tempo) + `d`}`).join(`\n\n`)}` : ``}

_Registrado em ${i.rg}_`
sendUrlText(from, txt, NomeDoBot, `Zero Two a sua disposição ヅ`, ppimg, `https://wa.me/` + usu.split("@")[0], seloctt)
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: ytall
└─────────────────────────────────────────────────┘
*/
case 'ytall':
if(!q) return reply(`Por favor, insira um link de um *vídeo do YouTube* após o comando.\n • Exemplo: *${prefix+command} https://youtube.com/watch?v=JXGpTLg7qoQ*`)
reagir(from, "🆙")
try {
console.log(color('[YTALL]', 'magenta'), color(`PROCURANDO MÍDIA MENCIONADA NO LINK`, 'yellow')) 
zerotwo.sendMessage(from, {audio: {url: `${zerosite}/api/dl/ytaudio?url=${encodeURIComponent(q)}&apikey=`+API_KEY_ZEROTWO}, mimetype: 'audio/mpeg', ptt: true}, {quoted: selolucas})
zerotwo.sendMessage(from, {video: {url: `${zerosite}/api/dl/ytvideo?url=${encodeURIComponent(q)}&apikey=`+API_KEY_ZEROTWO}, mimetype: "video/mp4"})
} catch(e) {
return console.log(e)
}
break

/*

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: ytsearch
└─────────────────────────────────────────────────┘
*/
case 'ytsearch':
if(q.trim().length < 4) return reply(`> Exemplo: ${prefix+command} Mc Cabelinho`)
try {
ABC = await fetchJson(`${zerosite}/api/ytsrc/videos?q=${q}&apikey=`+API_KEY_ZEROTWO)
console.log(color('[YT PLAY SEARCH]', 'magenta'), color(`FAZENDO PESQUISAR QUE FOI SOLICITADA NO YT`, 'yellow')) 
RST = `> 🎥 [Total: ${ABC.resultado.length}] – *Pesquisa YouTube:*\n• Deseja realizar o download do áudio? Use o comando: *${prefix}ytall [link]*\n• Fazer download do vídeo? É fácil! Só usar o comando: *${prefix}ytall [link]*\n–\n`
RST += `${ABC.resultado.map((v, index) => `*${index+1}.* Link: *${v.url}*\n• Título: *${v.title}*\n• Duração: *${v.duration.timestamp} | ${v.duration.seconds} segundos.*`).join('\n–\n')}`
reply(RST)
} catch(e) {
return reply(`> Erro 404`)
}
break
/*

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: ytstalk
└─────────────────────────────────────────────────┘
*/
case 'ytstalk':
if (!isVip) return reply(enviar.msg.vip)
if (!q) return reply(`Cadê o canal do YouTube que você deseja pesquisar? \n*Exemplo:* ${prefix + command} @Otaku.mp4`)
zerotwo.sendMessage(from, { react: { text: `🔍`, key: info.key }})
try {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
console.log(color('[YOUTUBE STALK]', 'magenta'), color(`BUSCANDO INFORMAÇÕES DO CANAL NO YOUTUBE`, 'yellow'))
res = await fetchJson(`${zerosite}/vip/youtube-channel?query=${encodeURIComponent(q)}&apikey=`+API_KEY_ZEROTWO)
let channel = res.resultado[0]
let responseMessage = `*⏤͟͟͞͞⃝💨Nome do Canal*: ${channel.channel_name}\n` +
`*⏤͟͟͞͞⃝📅Criado em*: ${new Date(channel.channel_created).toLocaleDateString()}\n` +
`*⏤͟͟͞͞⃝📝Sobre*: ${channel.channel_about}\n` +
`*⏤͟͟͞͞⃝🔔ID do Canal*: ${channel.channel_id}\n`
await zerotwo.sendMessage(from, {image: await getBuffer(channel.channel_picture.high.url), caption: responseMessage}, { quoted: selolucas }).catch(e => {
reply('*Vix, Api caiu ou não encontrei o canal informado.*')
})
} catch (e) {
if (String(e).includes("invalid json response body at")) {
console.log("A api caiu ou não foi possível executar esta ação, espere retornar")
} else {//By: 𖧄 𝐋𝐔𝐂𝐀𝐒 𝐌𝐎𝐃 𝐃𝐎𝐌𝐈𝐍𝐀 𖧄
reply('Nenhum canal foi encontrado, verifique se o nome do canal está correto.')
}
}
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: zerolink
└─────────────────────────────────────────────────┘
*/
case 'zerolink':
reagir(from, "🌐")
sendUrlText(from,
`*Site oficial da zero two:*🍧.ᩦ୭✧ࣶᭂ\n\n`+zerosite,
`🔎 ${NomeDoBot} 🔍`,
`Um site para Dev's e programadores de bot`,
logoslink.menu,
zerosite,
selolucas)
break

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: zerosite
└─────────────────────────────────────────────────┘
*/
case 'zerosite':

/* --------------------------------------------- */

/*
┌─────────────────────────────────────────────────┐
│📌 **Case**: zerotwo
└─────────────────────────────────────────────────┘
*/
case 'zerotwo':
if(!q) return reply("Retorne após o comando o título de sua pesquisa")
try {
reply("*Aguarde enquanto eu pesquiso...* 🫡")
ABC = await fetchJson(`${zerosite}/api/ia/zerotwo?query=${encodeURI(q)}&apikey=`+API_KEY_ZEROTWO)
if(ABC.status == true) return zerotwo.sendMessage(from, {image:waifuzdd3, caption: ABC.resposta}, {quoted: selolucas})
reply(ABC.resultado)
} catch(e) {
console.log(e)
reply("Erro")
}
break

